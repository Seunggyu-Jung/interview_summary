[
  {
    "title": "목차",
    "items": [
      {
        "id": "1",
        "title": "JavaScript",
        "topic": "객체",
        "texture": "# 1. 주제 선정 이유:\n\n자바스크립트가 객체 지향 언어라는 것은 다들 알고 있을 것이다. 그럼 여기서 말하는 객체란 과연 무엇인가?\n우리가 알고 있는 객체는 키와 값으로 이루어진 중괄호 라고 알고있는데, 이에 대해 자세히 파악하여 **수업을 하거나 협업을 할 때, 보다 더 원활하게 소통할 수 있도록 돕고자** 조사해봤다.\n\n# Ⅱ. 객체\n\n## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```\n\n### 4). 추상화\n\n- 객체의 핵심적인 특징을 강조하고, 불필요한 부분을 생략하는 것\n- 객체를 단순화시키고, 객체가 내부적으로 어떻게 구현되었는지 숨기기 때문에 코드의 가독성과 안정성이 향상\n\n## 3-2). 객체 지향 프로그래밍 언어의 장점\n\n### 1). 재사용성\n\n- 객체간에 계층이 부여되면 상속을 할 수 있고, 그 과정에서 공통된 코드는 다시 작성할 필요가 없어 **구동 시간이나 로딩 시간이 상당히 절약됨**\n\n### 2). 가독성\n\n- 객체지향 프로그래밍에서는 객체의 속성과 메서드를 **명확하게 정의**하고, 객체 간의 상호작용을 **명확하게 표현 가능**\n- 이를 통해 코드의 가독성이 높아지며, 코드의 이해 및 유지보수가 용이해짐\n\n### 3). 유지보수성\n\n- 객체지향 프로그래밍에서는 코드를 **객체 단위로 모듈화**하여 작성하기 때문에, **수정이나 추가를 할 때 해당 객체만 수정**하면 되기에 관리에 용이\n\n※ 모듈화 : 코드를 하나의 파일에 작성하는 것이 아니라, **나누어** 마치 조립하듯이 구조화시키는 것을 의미\n\n- 자바스크립트의 경우, ES6(ES2015)의 모듈 방식을 주로 사용하는데, 이는 import와 export를 사용하는 방식이며, 이를 위해 **Babel**과 같은 도구를 사용하여 코드를 컴파일해야 함\n\n```jsx\n// myModule.js // 보내는 모듈\nexport const foo = function() {\n  console.log('Hello, World!');\n};\nexport const bar = function() {\n  console.log('Bye, World!');\n};\n\n// app.js  // 받는 모듈\nimport { foo, bar } from './myModule';\nfoo(); // 'Hello, World!' 출력\nbar(); // 'Bye, World!' 출력\n\n```\n\n# **번외)**. 함께 알아두면 좋은 용어\n\n### 1. Babel\n\n- 자바스크립트 코드를 컴파일러로 변환해주는 오픈소스 도구\n- 주로 최신 버전의 자바스크립트 코드를 예전 버전으로 변환하여, 구형 브라우저에서도 실행 가능한 코드로 변환하는데 사용\n\n### 2. 컴파일러(Compiler)\n\n- 프로그래밍 언어로 작성된 소스 코드를 기계어로 변환해주는 소프트웨어\n- 자바스크립트의 경우, 인터프리터 언어라서 별도의 컴파일러가 필요\n\n### 3. 인터프리터 언어\n\n- 프로그램의 소스 코드를 직접 실행하는 언어로, 컴파일러와는 달리 컴파일 과정 없이 소스 코드를 바로 실행\n- 대표적인 인터프리터 언어 : JavaScript, Ruby, PHP...\n- 코드를 한 줄 한 줄씩 읽어 들이며 실행하기에 명령 자체의 속도는 컴파일러 언어에 비해 느리다는 단점이 있음\n- 오류 발견 즉시 해결할 수 있다는 장점이 있음",
        "qna": "아직 없음"
      },
      {
        "id": "2",
        "title": "JavaScript",
        "topic": "상속",
        "texture": "# 1. 주제 선정 이유\n\n코딩을 하다보면, 종종 상속이라는 용어를 많이 들어봤을 것이다. 물론, 상속의 사전적인 개념인 '하위존재가 상위존재로부터 무언가를 물림받는다.' 는 것 정도는 유추할 수 있을 것이다. 하지만, 코딩이나 IT업계에서 언급하는 상속에 대해 제대로 알고 넘어가는 것이 실제로 프로젝트에 적용할 때, 보다 수월하고 익숙하게 사용할 수 있을 것이기에 선정했다.\n\n# 2. 상속\n\n## 2-1. 상속의 정의 및 종류\n\n- 자바스크립트에서 사용되는 상속은 프로토타입 상속과 클래스 상속 크게 두 가지로 나뉜다. \n- 프로토타입 상속 : 상속을 받든 객체가 상속을 해주는 객체의 프로퍼티나 메서드를 추가로 사용할 수 있게 해주는 체계를 의미한다. \n- 클래스 상속 : 기존의 클래스를 확장시키는 개념으로 이해하면 좋다. 상속받은 기존의 클래스를 토대로 새로운 기능을 추가하는 시스템을 의미한다.\n\n## 2-2. 프로토타입과 상속의 관계\n\n- 프로토타입 (객체) : 다른 객체에 대한 참조 하는 대상을 의미한다. 모든 객체는 [[prototype]]이라는 내부 프로퍼티를 갖는다. [[prototype]]를 저장창고라고 이해면 좋다.\n\n - 예를 들어, 아래의 경우, 전부 객체로 이루어져있기에 객체의 프로토타입은, [[prototype]] : Object 즉, Object.prototype이다. 그리고 상속받는 객체들이 [[prototype]]안으로 들어간다. \n- `__proto__` : 객체가 자신의 프로토타입에 접근하도록 해주는 접근자 프로퍼티이다. 일종의 **다리(bridge)**라고 이해하면 좋을 듯하다. 해당 프로퍼티를 사용하여 상속받을 객체가 자신의 프로토타입에 들어갈 수 있도록 연결해준다. \n - 즉, `__proto__` 를 사용하여 상위(부모) 객체가 하위(자식) 객체의 프로토타입에 추가되는 과정을 상속이라고 한다.\n\n![사진](https://velog.velcdn.com/images/dainel-q/post/0ba7368c-6a60-4f68-8da4-be69a0422c37/image.png) \n\n## Q. 그런데 왜 프로토타입 상속을 하는 것인가요??\n\n -우선은 한 사례를 통해 살펴보자\n\n![사진](https://velog.velcdn.com/images/dainel-q/post/7f14b541-0997-4b62-b31f-86a9e4328d7c/image.png)\n - 위 예시의 경우, food를 상속받은 pasta 객체가 cook이라는 메서드를 자유롭게 사용할 수 있는 사례이다. 즉, pasta 객체에서 cook메서드를 더 만들지 않고 상속받아 편하게 사용할 수 있다는 것을 의미한다. 이는 곧, 코드의 재사용성을 높이고 , 관리를 용이하게 해준다는 장점을 갖고 있다.\n\n## 2-3. 클래스와 상속의 관계\n\n- 클래스(class) : 하나의 생성자 함수를 여러개 찍어낼 수 있게 해주는 문법으로 흔히 붕어빵 틀에 비유한다. - 먼저 상속을 할 부모 클래스를 생성한다.\n\nclass Food {\n constructor (name) {\n this.name = name;\n this.won = 0;\n }\n\n price(won) {\n this.won = won;\n console.log(${this.name}의 가격은 ${this.won}원 입니다.)\n }\n\n pay(){\n console.log(${this.won}원을 지불하셨습니다.)\n }\n}\n\nconst food = new Food('음식');\n\nclass Pasta extends Food {\n tasty(){\n console.log(${this.name} 맛있네요!)\n }\n}\n\nconst pasta = new Pasta('아라비따 파스타');\n\n- 위 예시를 합치면\nclass Food {\n constructor (name) {\n this.name = name;\n this.won = 0;\n }\n\n price(won) {\n this.won = won;\n console.log(${this.name}의 가격은 ${this.won}원 입니다.)\n }\n\n pay(){\n console.log(${this.won}원을 지불하셨습니다.)\n }\n}\n\nconst food = new Food('음식');\n\nclass Pasta extends Food {\n tasty(){\n console.log(${this.name} 맛있네요!)\n }\n}\n\nconst pasta = new Pasta('아라비따 파스타');\n\n- pasta클래스는 food 클래스를 상속받고 있다는 것을 의미한다. 그렇기에 food클래스의 메서드를 사용할 수 있다.\npasta.price(12000; // 아라비따 파스타의 가격은 12000원 입니다.\npasta.pay(12000); // 12000원을 지불하셨습니다.\npasta.tasty(); // 아라비따 파스타 맛있네요!\n\n## Q. 그런데 왜 클래스 상속을 하는 것인가요??\n\n- 프로토타입의 상속을 하는 이유와 유사하게, 상속을 주고 받기에, 작성해야할 코드의 양이 줄어든다. 특히, 클래스의 경우, 생성자 메서드등 작성해야할 내용이 많기에, 상속의 장점이 더욱 부각된다. - 코드의 재사용성을 높이고 , 관리를 용이하게 해준다는 장점이 있기 때문에 사용한다.",
        "qna": "# 3. 요약 정리 및 면접형 QnA\n\nQnA: 자바스크립트에서 사용하는 상속은 무엇이고, 그 기능이 무엇인가요?\n\n상속은 상속받는 자식요소가 상속해주는 부모요소의 프로퍼티나 메서드를 **추가로** 사용할 수 있도록 **확장**해주는 기능입니다. 자바스크립트의 경우, **프로토타입 상속**과 **클래스 상속** 두 가지 유형의 상속이 있습니다.\n\n- 프로토타입의 상속은, 객체 안의 `[[prototype]]`라는 내부 프로퍼티 안에 `__proto__`라는 접근자 프로퍼티로 객체들을 상속받아 저장하여 사용합니다.\n- 클래스 상속은, 부모 클래스를 `extends`라는 키워드를 사용하여 자식 클래스가 상속받아 사용합니다.\n\n상속을 사용하는 이유는 코드의 재사용성을 높이고, 유지보수가 필요한 경우 특정 부분만 수정해도 되기에 관리를 용이하게 만든다는 장점이 있습니다."
      },
      {
        "id": "3",
        "title": "CS",
        "topic": "API란 무엇인가",
        "texture": " ## 1. 주제 선정 이유\n\n💡 IT업계에서 API라는 용어를 상당히 많이 사용하는 것을 목격할 수 있다. 물론 이러한 문화에 친화적인 개발자라면 당연히 이해하고 넘어갔을 것이지만, 업계에 처음 진입한 사람에게는 너무나도 낯설은 용어라고 생각한다. 특히, 필자인 내가 그랬다. 그래서 이번 기회에 API에 대한 기초적인 개념을 쉬운 비유에 빗대어 설명하고자 한다.\n\n ## 2. API\n\n## 2-1. API의 개념\n\n- API는 Application Programming Interface의 앞자리를 조합하여 만든 용어이다.\n- Application은 기능이나 응용 프로그램을 의미하며, Interface는 상호작용을 의미한다.\n- 즉, API는 **응용 프로그램을 프로그래밍하기 위해 서로 데이터를 주고 받는 상호작용의 방법**이라고 정의할 수 있다.\n\n## 2-2. API의 기능\n\n- API를 실상의 예로 설명한다면, 식당의 메뉴가 적힌 **메뉴판**이라고 빗대어 표현할 수 있다.\n- 여기서 메뉴는 API가 제공하는 데이터 형식의 정보라고 생각하면 된다.\n- 식당에 들어온 손님은 메뉴판을 보고 주방장에게 메뉴를 요청하고, 주방장은 그 메뉴에 맞는 음식을 손님에게 제공한다.\n- 데이터를 요청하는 클라이언트(프론트엔드)에게 서버(백엔드)가 데이터를 제공해주며, 이러한 상호작용을 가능하게 해주는 것이 API이다.\n\n## 2-3. API의 형태\n\n- 웹에서 사용하는 API를 '웹 API'라고 부르며, 모바일에서 사용하는 API를 '모바일 API'라고 부르며, 프론트엔드 개발자가 주로 접하는 API는 HTTP API이다.\n- HTTP는 HyperText Transfer Protocol의 약자로, 인터넷에서 웹페이지를 전송하기 위해 사용하는 프로토콜(규칙)을 의미한다. HTTP는 클라이언트와 서버 간에 데이터를 주고받는 방식을 정의하고 있으며, 웹 브라우저와 웹 서버 간의 통신에 주로 사용한다 ex).네이버 URL : https://www.naver.com/\n- API는 요청방식, 요청자료내용, 자료요청에 필요한 추가정보 순으로 구성되어있다.\nex). 클라이언트가 서버에 영화정보를 요청하는 HTTP API: GET /movies/123456789\n서버가 갖고있는 영화정보:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  'id': 123456789,\n  'title': 'The Shawshank Redemption',\n  'year': 1994,\n  'director': 'Frank Darabont',\n  'genres': ['Drama', 'Crime'],\n  'rating': 9.3\n}\n\n``` \n\n- GET /movies/123456789 : 요청방식 / 요청자료내용 / 추가정보\n\n## 2-4. REST API\n\n- Representational State Transfer의 약자로, 웹 서비스를 위한 아키텍처 스타일, 일종의 **방법론**이라 이해하면 편하다.\n- REST API는 HTTP 프로토콜을 기반으로 동작하며, 클라이언트와 서버 간의 통신을 위해 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용한다.\n- REST API의 특징:\n1. 자원(Resource) 중심적: 리소스(데이터)를 중심으로 API를 설계한다. 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하다.\n2. 상태를 전달(Stateless): 서버는 클라이언트의 상태를 관리하지 않는다. 요청은 필요한 모든 정보를 포함하고, 서버는 각 요청을 독립적으로 처리한다. 클라이언트의 세션 상태는 서버에 저장되지 않으며, 클라이언트는 필요한 경우 인증 토큰 등을 요청에 포함시켜 식별할 수 있다.\n3. 표준화된 인터페이스: REST API는 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)와 HTTP 상태 코드(200 OK, 404 Not Found 등)를 사용하여 일관된 인터페이스를 제공한다. 이는 개발자가 API를 이해하고 사용하기 쉽도록 도와준다.\n4. 계층 구조(Layered System): RESTful 서비스는 다중 계층으로 구성될 수 있다. 중간 서버, 로드 밸런서, 캐싱 서버 등을 통해 보안, 로드 분산, 성능 향상 등을 달성할 수 있다.\n- 정리하면, **REST API는 HTTP API기반으로 개발자들이 보다 쉽게 서버와 상호작용할 수 있도록 하는 표준화된 방법으로, 단순하고 가독성이 좋다는 장점이 있다.**\n\nREST API에 대한 자세한 설명자료영상 :\n\n [![이미지 텍스트](https://img.youtube.com/vi/lsMQRaeKNDk/0.jpg)](https://www.youtube.com/watch?v=lsMQRaeKNDk) \n\n## 2-5. API의 종류\n\n- API의 종류에는 크게 3가지가 있다.\n1. public API(open API) : 누구나 사용가능한 공개 API (ex. 기상청 : https://www.data.go.kr/data/15095109/openapi.do#tab_layer_detail_function)\n2. private API : 사내에서만 사용하는 API\n3. partner API : 미리 정해준 사용자끼리 사용하는 API",
        "qna": " ## 3. 요약 정리 및 면접형 QnA\n\n # QnA : API는 무엇인가요?\n\n- API는 Application Programming Interface의 약자로, 응용 프로그램을 프로그래밍하기 위해 클라이언트와 서버가 서로 데이터를 주고 받는 상호작용의 방법입니다.\n\n# QnA : 혹시 REST API가 무엇인지 알고 계신가요?\n\n- REST API는 Representational State Transfer의 약자로, HTTP API기반하여 개발자들이 보다 쉽게 서버와 상호작용할 수 있도록 하는 표준화된 API 스타일입니다. 특히 자원중심적인 스타일이기에, 각 리소스가 고유한 URI를 가져 가독성이 좋으며, 표준화된 HTTP 메서드를 사용하기에 단순하다는 장점이 있기 때문에, 현업에서 거의 REST 방식을 사용합니다."
      },
      {
        "id": "4",
        "title": "CS",
        "topic": "REST API란 무엇인가",
        "texture": "## 1. 주제 선정 이유 \n\n지난 IT용어 정리에서 API에 대한 설명을 했으나, 가장 중요한 REST API에 대한 설명을 간략하게 했다고 생각해서 해당 주제에 대해 자세히 설명하고자 선정했다. 프론트 엔드뿐만 아니라 IT업계에서 가장 많이 사용하는 API 방식이기에 이에 대한 정확한 개념은 반드시 숙지해야 할 것이다.\n\n## 2. API란 무엇인가? === 메뉴판 \n\n- Application Programming Interface의 앞자리를 조합하여 만든 용어로, **응용 프로그램을 프로그래밍하기 위해 서로 데이터를 주고 받는 상호작용의 방법**이라고 정의할 수 있다.\n\n- 데이터를 요청하는 클라이언트(프론트엔드)에게 서버(백엔드)가 데이터를 제공해주며, 이러한 상호작용을 가능하게 해주는 것이 API이다.\n\n## 3. REST API란 무엇인가?\n\n# 3-1. REST API의 개념\n- REpresentational State Transfer의 약자로, 웹 서비스를 위한 아키텍처 스타일이다.\n- 어원적으로 분석하면 '대표적인 상태 전달자'로 API 방식 중 가장 많이 그리고 표준적으로 사용되는 **방법론**이다.\n- 아키텍처는 시스템을 구성하는 구성요소들의 조합과 그들 간의 상호작용 방식을 **설계하는 것**을 의미하며, REST API에서 언급하는 웹 서비스를 위한 아키텍처는 **클라이언트-서버 아키텍처**를 의미한다.\n- 클라이언트-서버 아키텍츠는 클라이언트와 서버가 각자의 역할을 분배하여 시스템을 구성한다. 클라이언트는 사용자 인터페이스나 요청을 처리하고, 서버는 그에 필요한 데이터를 전달 및 처리를 하는 역할을 수행한다.\n- 즉, REST API는 웹 서비스를 위한 클라이언트와 서버의 시스템(아키텍처)적 스타일이라 정리 할 수 있다.\n- **REST API는 HTTP 프로토콜을 기반으로 동작한다.**\n\n# 3-2. REST API를 사용하는 이유\n- 자원(Resource) 중심적: 리소스(데이터)를 중심으로 API를 설계한다. 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하다.\n- 표준화된 인터페이스: REST API는 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)와 HTTP 상태 코드(200 OK, 404 Not Found 등)를 사용하여 일관된 인터페이스를 제공한다. 이는 개발자가 API를 이해하고 사용하기 쉽도록 도와준다.\n\n# 3-3. HTTP는 무엇인가?\n- HyperText Transfer Protocol의 약자로, 인터넷에서 웹페이지를 전송하기 위해 사용하는 프로토콜(규칙)을 의미한다.\n- HTTP는 클라이언트가 데이터를 '요청'하고 서버가 이에 '응답'하여 데이터를 주고받는 형태로 이루어져 있다.\n- REST API는 HTTP 프로토콜을 기반으로 동작하기에, 각종 HTTP 메서드를 활용하여 사용자에게 표준화된 인터페이스를 제공한다.\n\n## 4. HTTP 메서드 정리\n- **GET** : 요청받은 URI의 정보를 검색하여 응답한다. 주로 사용자가 클릭하는 대부분의 버튼들이 GET 메서드를 사용한다고 생각해도 무방하다.\n- **POST** : 요청된 자원을 생성(create)한다. 즉, 서버에 새로운 리소스를 생성하거나, 서버에 데이터를 제출하여 처리하고자 할 때 사용한다. 주로 게시물을 작성하거나, 주문 정보를 생성하거나, 새로운 파일을 업로드 하는 등, **새로운 자원을 생성**할 때 사용한다.\n- **PUT** : 요청된 자원 전체를 수정(update)한다. 기존의 URI에 내용을 수정하는 것이기에 새로운 URI를 생성하는 POST와는 차이를 두어야 한다. 주로 리소스를 업데이트할때 PUT 메서드를 사용한다고 이해하면 된다.\n- **PATCH** : 요청된 자원을 수정(update)한다. 다만, 자원 전체를 수정하는 PUT메서드와는 달리, PATCH메서드의 경우 해당자원의 일부만을 교체한다는 차이점이 있다.\n- **DELETE** : 요청된 자원을 삭제할 것을 요청한다. 하지만 안정성의 문제로 대부분의 서버에서는 비활성화 되어있으며, 주로 PATCH를 통해 수정한다고 한다.\n\n# 4-1. POST와 PUT의 차이는 무엇인가?\n- POST 메서드는 INSERT이며 PUT 메서드는 UPDATE이다.\n- POST메서드의 경우, 멱등하지 않아 동일한 자원을 여러 번 POST하면 서버자원에 변화가 생긴다.\n- PUT메서드의 경우, 생성이 아닌 수정을 하며, 여러번 요청해도 서버 리소스에 변화가 없다.\n\n# 4-2. PUT과 PATCH의 차이는 무엇인가?\n- PUT은 해당 자원의 전체를 교체하지만, PATCH는 일부만 변경한다.\n- PUT은 멱등하지만, PATCH는 멱등하지 못하다.\n\n# 4-3. 멱등(Idempotent)은 무엇인가?\n- 동일한 작업을 여러 번 실행하더라도 결과가 동일하게 유지되는 성질을 의미한다.\n- 즉, 동일한 요청을 여러 번 실행하더라도 처음 요청과 같은 상태와 결과를 얻을 수 있다는 것을 의미한다.\n- 이는 요청의 반복 실행이나 중복 전송이 발생해도 시스템의 상태가 변하지 않는 것을 의미한다.",
        "qna": "## 5. 요약 정리 및 면접형 QnA\n\n# 5-1. Q. REST API가 무엇인가요?\n- REST API는 HTTP 프로토콜을 기반으로 동작하는, 웹 서비스를 위한 클라이언트와 서버의 시스템(아키텍처)적 스타일입니다.\n- REST API가 각광받는 이유는 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하고, 일관된 HTTP 프로토콜을 따르기에 개발자로 하여금 친숙하고 편리하기에 자주 사용됩니다.\n\n# 5-2. Q. POST와 PUT의 차이는 무엇인가?\n- POST 메서드는 INSERT이며 PUT 메서드는 UPDATE이다.\n- POST메서드의 경우, 멱등하지 않아 동일한 자원을 여러번 POST하면 서버자원에 변화가 생긴다.\n- PUT메서드의 경우, 멱등하여 동일한 자원을 여러번 PUT하면 서버자원이 변화하지 않고 동일한 리소스로 응답한다.\n- 즉, POST메서드는 새로운 자원을 생성하기에 여러번 요청하면 서버 리소스에 변화가 생기지만, PUT의 경우, 생성이 아닌 수정을 하며, 여러번 요청해도 서버 리소스에 변화가 없다.\n\n# 5-3. Q. PUT과 PATCH의 차이는 무엇인가?\n- PUT은 해당 자원의 전체를 교체하지만, PATCH는 일부만 변경한다.\n- PUT은 멱등하지만, PATCH는 멱등하지 못하다.\n\n# 5-4. Q. 멱등(Idempotent)은 무엇인가?\n- 동일한 작업을 여러 번 실행하더라도 결과가 동일하게 유지되는 성질을 의미한다.\n- 즉, 동일한 요청을 여러 번 실행하더라도 처음 요청과 같은 상태와 결과를 얻을 수 있다는 것을 의미한다.\n- 이는 요청의 반복 실행이나 중복 전송이 발생해도 시스템의 상태가 변하지 않는 것을 의미한다."
      },
      {
        "id": "5",
        "title": "React",
        "topic": "라이브러리란 무엇인가",
        "texture": "## 1. 주제 선정 이유 \n각종 프로젝트를 준비하는 과정에서 라이브러리의 중요성을 많이 언급되며, 실제 기업에서도 특정 라이브러리를 사용하여 프로젝트를 진행한 경험을 요구하는 경우가 많다고 느꼈을 것이다. 라이브러리가 정확하게 무엇이며 어떤 종류가 있으며, 왜 사용하는지에 대해 자세히 알아보고자 준비함\n\n## 2. 라이브러리란\n\n# 2-1. 라이브러리의 정의\n- 소프트웨어를 개발할 때, 컴퓨터 프로그램이 사용하는 '비휘발성 자원(리소스)'의 집합이다.\n- 사전적 용어인 도서관(library)와 비슷하게, 특정한 코드들(책들)을 모아둔 집합이라 생각하면 된다.\n- 이는 소프트웨어 개발시에 사용되는 프로그램의 구성요소로, 공통으로 사용될 수 있는 특정한 기능들을 모듈(module)화 한 것이다.\n- API와의 차이점 : API는 프로그래밍 언어에서 라이브러리를 사용할 수 있도록 소스코드 수준에서 인터페이스를 노출 시킨 것이지만, 라이브러리는 실제 실행되어 기능을 수행하는 **단편화된 프로그램** 이다.\n- 즉, 라이브러리는 완전한 프로램이 아니라 특정한 기능만을 수행하도록 제작된 프로그램이다.\n\n# 2-2. 라이브러리를 사용하는 이유\n- 모든 기능을 직접 코딩하지 못하며, 시간을 절약하기 위해서이다.동일한 기능을 간단한 코드로 방법화시키는 라이브러리 코드를 본인이 직접짜기엔 너무 많은 시간을 소요되며, 실제로 정해진 기간내에 처리하기도 어렵기 때문이다.\n- 즉, 라이브러리를 사용할수 있으면, 보다 복잡한 코드를 짜는데 **더 빠르고, 더 편리하게** 할 수 있기에, 사용이 권장된다.\n\n# 2-3. 라이브러리의 종류\n- 표준 라이브러리: 특정한 언어의 개발 환경에 기본적으로 포함된 것들로, 언어의 기본 기능을 확장시키는 역할을 담당한다.Python의 표준 라이브러리에는 문자열 처리, 파일 조작, 네트워크 통신 등 다양한 모듈들이 포함되어 있다.참고문헌 : https://docs.python.org/ko/3/library/index.html\n- 웹 개발 라이브러리 : 웹 개발의 편의성을 제공하는 역할을 한다.대표적인 예로 JavaScript의 경우, jQuery, React, Angular 등이 있다.\n- 데이터베이스 라이브러리 : 데이터베이스와 상호 작용하는 역할을 수행한다.\n- 그래픽스 및 시각화 라이브러리 : 데이터 시각화나 그래픽스 작업을 위해 사용하는 라이브러리대표적인 예로 JavaScript의 D3.js가 있다.\n- 상태관리 라이브러리: 애플리케이션의 상태를 보다 효과적으로 관리(상태 업데이트나 추적...)하기 위한 라이브러리대표적인 예로 Redux와 Recoil이 있다.\n\n## 3. 라이브러리와 프레임 워크의 차이점\n- 주도권의 차이라고 설명할 수 있다.\n- 라이브러리의 경우, 개발자가 필요에 따라 선택적으로 사용할 수 있다.\n- 프레임 워크의 경우, 애플리케이션의 개발을 위한 일종의 뼈대 역할을 하기에, 개발자 프레임 워크에 맞춰서 개발을 해야한다.\n\n# 3-1. React는 라이브러리인가 프레임 워크인가?\n- React는 '프레임 워크같은' 라이브러리라 정의할 수 있다.\n- React 개발당시, UI개발을 위한 라이브러리로 개발되었으나, React Router를 통한 라우팅 기능이나, Redux와 같은 다양한 상태관리 라이브러리와의 조합으로 점차 '프레임 워크화'되어간 것이다.\n- 즉, React는 **프레임워크처럼 동작하는 라이브러리**라고 소개하면 된다.",
        "qna": "## 4. 요약 정리 및 면접형 QnA\n\n# Q1. 라이브러리에 대해 설명해주세요\n- 라이브러리는 재사용 가능한 코드의 집합을 의미합니다.\n- 해당 코드에는 특정 기능을 수행하는 함수, 클래스, 모듈 등으로 구성되어 있습니다.\n- 개발자가 필요에 따라 선택적으로 사용할 수 있다는 특징이 있습니다.\n- 프런트엔드 개발자인 저희에게 가장 익숙한 라이브러리에는 웹개발 라이브러리인 React와 상태관리 라이브러리인 Recoil과 Redux가 있습니다.\n\n# Q2. 혹시 Redux와 Recoil의 차이에 대해 설명가능하실까요?\n- Redux와 Recoil은 둘 다 상태 관리를 위한 라이브러리이지만, 사용 범위나 상태 업데이트 방식, 성능면에서 차이를 보입니다.\n- Redux의 경우, JavaScript 기반의 라이브러리(React, Angular, Vue)에서 모두 사용가능합니다. 반면 Recoil의 경우, Meta에서 React만을 위해 개발한 라이브러리여서 오로지 React에서만 작동가능합니다.\n- Redux는 Reducer를 활용한 일방적인 데이터 흐름으로 상태를 업로드 하지만, Recoil은 React의 useState와 유사하게 Atom이라는 상태 단위를 활용하여 상태를 업로드 합니다.\n- Recoil은 Redux보다 간단한 API를 제공하고 성능 최적화면에서도 React의 컴포넌트 라이프사이클과 잘 맞기에 우수합니다.\n\n# Q3. React는 라이브러리일까요, 아니면 프레임워크일까요?\n- React의 개념적으로 라이브러리가 맞습니다. 개발 초창기에 웹개발을 용이하게 하기 위해 개발된 웹개발 라이브러리 였으나, 다양한 상태관리 라이브러리를 함께 사용하고, 라우터를 활용한 라우팅이 가능해져서 컴포넌트간 보다 편리한 매핑이 가능해져 더이상 라이브러리가 아닌 프레임워크로 인식되는 경우가 있습니다.\n- 즉, React는 **프레임워크처럼 동작하는 라이브러리**라고 정의할 수 있습니다."
      },
      {
        "id": "6",
        "title": "React",
        "topic": "React의 상태관리란 무엇인가",
        "texture": "## 1. 주제 선정 이유\n React라이브러리를 사용하다보면 상태관리가 필수이며 그에 따른 각종 기능들을 숙지하고 있어야한다. 이에 대해 알지 못하면 React를 사용하지 않는 수준이며, 협업을 하는데 있어 큰 지장이 되기에 이번 기회에 상태관리에 대한 정확한 정의를 학습하고, React의 상태관리 방법에는 어떤 것들이 있는지 살펴보도록 하자.\n\n## 2. 상태관리란\n\n# 2-1. 상태관리의 정의\n- 상태(State) : 컴퍼넌트 내부에서 관리되며 어플리케이션의 렌더에 영향을 미치는 자바스크립트 객체를 의미. 즉, **변화하는 데이터**라고 이해하면 된다. (ex, 쇼핑몰 사이트에서 구매할 물건의 수량을 늘리고 줄이는 행위를 상태가 변화한다고 한다.)\n- 상태관리 : 상태는 어는 컴퍼넌트에서나 일관되어야 한다. 이를 데이터의 무결성이라 한다. 왜냐하면, 상태가 컴퍼넌트마다 다르다면, 유저나 관리자가 받아들이는 데이터에 차이가 생겨 소통에 차질이 생기기 때문이다.\n따라서 상태를 일관되게 관리해야하며, React의 경우, **신뢰할 수 있는 단일 출처(동일한 데이터는 항상 같은 곳에서 가져온다)**라는 방법론으로 상태를 관리하고 있다.\n\n# 2-2. 상태의 종류\n- 지역상태(localState) : 특정 컴퍼넌트 안에서만 관리되는 상태를 의미한다. 이는 주로 작은 프로젝트처럼 좁은 영역에서만 관리되는 데이터들이다.\n- 컴퍼넌트 간 상태: 다수의 컴퍼넌트에서 사용되고 영향을 주는 데이터들을 의미한다. 대표적인 예시로 여러 컴퍼넌트가 동시에 사용하는 모달창 등이 있다\n2개 이상의 컴퍼넌트간에 상태를 주고 받을 경우, 상위 컴퍼넌트에서 하위 컴퍼넌트로만 상태를 전달하며, 이를 Props Driling이라 한다.\n- 전역 상태(globalState) : 프로젝트 전체에 영향을 끼치는 데이터를 의미한다. 대표적인 예로, 모든 컴퍼넌트에서 사용되는 페이지의 헤더 컴퍼넌트 등이 있다.\n- 상태관리가 필요한 이유: 걱 컴퍼넌트가 부모자식 관계로 되어있지 않은 이상 각 컴퍼넌트간의 직접적인 데이터 전달은 어렵우며, 구조가 복잡하여 Props Driling이 많아지면 Props의 출처를 찾기 어려워기 때문에 이를 관리해줘야 한다.\n\n## 3. React의 상태관리\n\n# 3-1. Context API\n- Context API : React 컴포넌트 트리 안에서 전역 상태를 공유할 수 있도록 만들어진 방법이다.명칭은 API이기는 하지만, 실질적인 관리는 API가 아니라 useState를 통해 이루어진다.\n- useState() :\n`cosnt [state, setState] = useState()`의 형태로 구성되어 있다.\n앞에서서부터 state라는 상태변수와 상태에 변화를 주는 setState라는 함수가 있다. useState()의 파라미터에는 초기 state값이 들어가며, 이후 setState를 통해 state의 값에 변화를 주는 방식으로 상태를 관리한다.\nuseState()는 상태를 새로 추가하거나 삭제하는 것이 아니라 단순 비교를 통해 상태를 업데이트 시키는 원리로 작동한다.\n즉, **동일한 데이터의 key값이면 키의 value값의 차이를 비교하여 최신의 value값으로 갱신하며 상태를 관리한다.**\n이는 중간에 있는 요소들에게 props를 넘기지 않고도 데이터를 가져다 사용할 수 있기에 props Drilling을 피할 수 있으며, 주로 전역적으로 쓰이는 데이터들을 사용할 때 자주 사용된다.\n- context API의 구조 : context, provider, comsumer 로 구성\n context : 전역상태를 저장하는 곳으로 , 내부에는 provider와 consumer로 구성되어있다.\n provider : 전역상태를 제공하는 역할을 한다. 주로 Root Component(index.js / app.js)에서 정의된다.\n consumer 제공받은 전역상태를 받아서 사용하는 역할을 한다.\n\n# 3-2. Redux\n- Redux : 공식 문서에 따르면 자바스크립트 앱을 위한 예측 가능한 상태 컨테이너라고 정의한다.\n 이를 풀어 설명하면, 전역 상태를 관리하는 도구, 즉, 어플리케이션 전체에 대한 중앙 저장소 역할을 한다고 생각하면 된다.\n- 'Store','Action', 'Reducer'로 구성되어 있다.\n Store는 전역상태를 저장하는 저장소 역할을 하며, 오직 Reducer를 통해서만 접근이 가능하다. 주로 index.js에 정의되며 Store는 오직 1개만 존재할 수 있다.\n Action은 Store에 저장된 상태의 변화를 Reducer에 명령하는 자바스크립트 객체이다. 변화를 주기 위해 dispatch라는 메서드를 사용하여 Reducer에게 전달된다.\n Reducer는 변화를 감지하여 상태를 변화시키는 역할을 하는 순수함수로서, 전역 상태를 변경하고 업데이트시킨다. 바닐라 자바스크립트의 '이벤트리스너'와 동일한 역할을 한다고 파악해도 좋다.\n 다만, Redux의 경우, 상태관리를 할 때, 이전상태를 변경시키는 것이 아닌 **새로운 상태의 객체를 생성하여 반환한다**는 점을 명시해야한다.\n *순수함수 : 다른 외부의 상태를 변경하지 않으면서도, 어떤 동일한 인자에 대해 항상 동일한 값을 리턴하는 함수이다.\n\n# 3-3. Recoil 라이브러리\n- 앞서 언급한 Redux는 단방향의 흐름에서 상태관리가 용이하지만, 이를 위한 action, reducer와 같은 초기 세팅이 상당히 번거롭고 React와 잘 맞지 않는다는 여론이 주를 이루었다.\n- React의 상태관리를 보다 React스럽게(hook을 전역으로 확장시킴) 하기 위해, 메타(전 페이스북)사에서 제작한 React 상태관리 라이브러리이다.\n- Recoil은 atom과 selector라는 객체를 사용하여 상태를 관리한다.\n- atom은 구독, 옵저버와 같은 개념을 생각할 필요없이 hook을 사용하듯이 사용하면 된다.\n hook를 사용했던 개발자라면 쉽게 사용할 수 있다.\n- selector를 이용하면 리듀서 없이 복잡한 연산도 간단하게 할 수 있다.",
        "qna": "추가해야함"
      },
      {
        "id": "7",
        "title": "JavaScript",
        "topic": "이벤트 버블링",
        "texture": " ## 1.  정의 : \n\n🎯 이벤트 버블링(event bubbling)은 HTML에서 이벤트가 발생했을 때, 해당 요소에서 이벤트가 처리된 후, **상위 요소로 이벤트가 전파되는 현상**을 말합니다. *(Trigger clicks all the way up)* 이벤트 버블링은 이벤트가 전파되는 동안 부모 요소에서도 이벤트를 감지할 수 있다는 **장점**이 있습니다. 즉, 이벤트를 처리하는 핸들러 함수를 부모 요소에 등록해놓으면, 자식 요소에서 발생한 이벤트도 모두 처리할 수 있습니다. 이를 활용하면, 여러 개의 하위 요소에서 발생하는 이벤트를 하나의 이벤트 핸들러로 바인딩하는 **이벤트 위임 처리**를 할 수 있습니다.\n\n![이벤트 버블링](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F58daf214-1434-4922-8f83-d22f9ea4129c%2FUntitled.png?table=block&id=db53aae9-446e-4eda-9c51-6781a607031b&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1440&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이벤트 버블링\n\n\n![이벤트 흐름 3단계](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6ad187ed-1aaf-4bdf-8294-3dec2e6e6ead%2FUntitled.png?table=block&id=28e1fbd7-40fa-4f4e-94cb-6e26b17b0ff7&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1280&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이벤트 흐름 3단계\n\n```jsx\n//이벤트 버블링\n<style>\n    body * {\n      margin: 10px;\n      border: 1px solid rgb(255, 2, 74);\n    }\n</style>\n\n    <div class='DIV1'>\n      DIV1\n      <div class='DIV2'>\n        DIV2\n        <div class='DIV3'>DIV3</div>\n      </div>\n    </div>\n\n<script>\nconst divs = document.querySelectorAll('div');\n\nconst clickEvent = (e) => {\n  console.log(e.currentTarget.className);\n};\n\ndivs.forEach((div) => {\n  div.addEventListener('click', clickEvent);\n});\n\n</script>\n```\n\n```jsx\n//onclick\n<body>\n  <div class='DIV1'>\n    DIV1\n    <div class='DIV2'>\n      DIV2\n      <div class='DIV3'>DIV3</div>\n    </div>\n  </div>\n\n  <script>\n    const divs = document.querySelectorAll('div');\n\n    divs.forEach((div) => {\n      div.addEventListener('click',function(event){\n        console.log(event.currentTarget.className);\n      };\n    });\n\n  </script>\n</body>\n```\n\n\n## 2.  내용:\n- 이벤트 전파(흐름)가 있는 이유\n\n    *이벤트 전파란*: 브라우저는 사용자로부터 이벤트가 발생하면 가장 상단의 요소부터 하위의 요소까지 내려오고 다시 거슬러 올라가는 식으로 이벤트를 전달하여 발생하도록 한다.\n    \n    - 논리적 측면\n    \n    어쩌면 당연할지도 모르지만, 자식 요소가 부모 요소 영역 안에 위치하고 있기 때문에, 자식 요소만을 클릭했다고 그것은 부모 요소도 클릭한 셈이 되기 때문이다.\n    \n    - 성능적 측면\n    \n    이런 특징은 이벤트 등록 코드를 줄일 수 있는 장점이 있음. 여러개의 리스트가 있다고하고, 몇번째를 클릭하든 같은 종류의 이벤트를 발생시키고 싶다고하자. 그러면 일일히 이벤트를 등록해야하는데, 부모요소인 ul에만 이벤트 등록을하면, 전파에 의해 어떠한 li를 클릭해도 이벤트를 사용할 수 있음. 이를 이벤트 위임이라고 한다.\n    \n- **이벤트 버블링과 캡쳐링의 차이점에 대해서 구분해서 인지한다.**\n    \n    **이벤트 캡처링**\n    \n    이벤트가 하위 요소로 전파되는 단계. 캡처링은 버블링과는 반대로 최상위 태그에서 해당 태그를 찾아 내려간다.\n    \n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1baa6ba7-8fc6-41f1-883a-b79ea096ddca%2FUntitled.png?table=block&id=07802a68-ab20-4e72-8b71-8a07315494bd&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1840&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n    \n    위 그림처럼 특정 이벤트가 발생했을 때 최상위 요소인 body 태그에서 해당 태그를 찾아 내려갑니다. 캡처링 단계를 이용해야 하는 경우는 흔치 않기 때문에, 캡처링 단계에서 이벤트를 잡아내려면 `addEventListener` 의 옵션 객체에 `{ capture: true }` 또는 `true` 를 설정해주면 캡처링을 구현할 수 있다.\n    \n    ```jsx\n    target.addEventListener('이벤트', 콜백 함수, {capture:ture});\n    target.addEventListener('이벤트', 콜백 함수, true);\n    ```\n    \n    - `false`이면(default 값) 핸들러는 버블링 단계에서 동작합니다. (*default 값은 false이고 생략가능합니다.*)\n    - `true`이면 핸들러는 캡처링 단계에서 동작합니다.\n    \n    ```jsx\n    //이벤트 캡처링\n    <style>\n        body * {\n          margin: 10px;\n          border: 1px solid rgb(255, 2, 74);\n        }\n    </style>\n    \n    <body>\n        <div class='DIV1'>\n          DIV1\n          <div class='DIV2'>\n            DIV2\n            <div class='DIV3'>DIV3</div>\n          </div>\n        </div>\n      </body>\n    \n    <script>\n    const divs = document.querySelectorAll('div');\n    \n    const clickEvent = (event) => {\n      console.log(event.currentTarget.className); //DIV1 DIV2 DIV3\n    };\n    \n    divs.forEach((div) => {\n      div.addEventListener('click', clickEvent, { capture: true });\n    // {capture: true} 대신, true를 써줘도 됩니다.\n    });\n    </script>\n    ```\n    \n- **이벤트 위임 패턴을 이해한다.**\n    \n    이벤트 위임(Event Delegation)이란 ‘**하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식**’입니다. 캡처링과 버블링을 활용하면 강력한 이벤트 핸들링 패턴인 *이벤트 위임(event delegation)* 을 구현할 수 있습니다. \n    \n    ```html\n    <h1>오늘의 할 일</h1>\n      <ul class='itemList'>\n        <li>\n          <input type='checkbox' id='item1'>\n          <label for='item1'>이벤트 버블링 학습</label>\n        </li>\n        <li>\n          <input type='checkbox' id='item2'>\n          <label for='item2'>이벤트 캡쳐 학습</label>\n        </li>\n      </ul>\n      <script>\n        //이벤트 위임 전, 각 인풋 박스의 요소에 클릭 이벤트 리스너를 추가\n        var inputs = document.querySelectorAll('input');\n        inputs.forEach(function (input) {\n          input.addEventListener('click', function (event) {\n            alert('clicked');\n          });\n        });\n    \n        //이벤트 위임 후\n        // var itemList = document.querySelector('.itemList');\n        // itemList.addEventListener('click', function (event) {\n        //   alert('clicked');\n        // });\n    \n        // 새 리스트 아이템을 추가하는 코드,  새 리스트를 추가할 때에는, li가 2개가 있는 시점 다음이기 때문에, 새로 생기는 li들은 이벤트가 적용되지 않는다.\n        // var itemList = document.querySelector('.itemList');\n    \n        // var li = document.createElement('li');\n        // var input = document.createElement('input');\n        // var label = document.createElement('label');\n        // var labelText = document.createTextNode('이벤트 위임 학습');\n    \n        // input.setAttribute('type', 'checkbox');\n        // input.setAttribute('id', 'item3');\n        // label.setAttribute('for', 'item3');\n        // label.appendChild(labelText);\n        // li.appendChild(input);\n        // li.appendChild(label);\n        // itemList.appendChild(li);\n      </script>\n    ```\n    \n    **이벤트 위임의 목적?**\n    \n    ```html\n    <div id='div-content'>\n      <span id='span-content'>\n        <button id='btn'>버튼</button>\n      </span>\n    </div>\n    ```\n    \n    [이벤트 위임 사용 전]\n    \n    ```jsx\n    // 개별 요소를 접근해야함\n    const divNode = document.getElementById('div-content');\n    const spanNode = document.getElementById('span-content');\n    const btnNode = document.getElementById('btn');\n    \n    // 개별 요소마다 이벤트 리스너를 등록해야함\n    divNode.addEventListener('click', function () {\n      console.log('divNode Click');\n    });\n    \n    spanNode.addEventListener('click', function () {\n      console.log('spanNode Click');\n    });\n    \n    btnNode.addEventListener('click', function () {\n      console.log('btnNode Click');\n    });\n    ```\n    \n    여러 개의 이벤트 리스너를 등록하면 이벤트 버블링에 의해 상위 요소의 이벤트 리스너도 실행됩니다. 이벤트 버블링에 의해 <button> 태그에서 click 이벤트가 발생하면, 해당 이벤트는 최상위 객체인 Document까지 전파됩니다. 위 코드의 문제점은 **상위 요소의 이벤트도 실행**함으로써 t상위 요소 이벤트 리스너에 문제가 되는 코드가 존재한다면.. 개발자가 **원하지 않는 결과**를 발생시킬 수 있습니다.\n    \n    ![img.gif](https://file.notion.so/f/s/dca28498-1342-48a1-82a7-a0de390e9738/img.gif?id=46fee168-0dc5-48ad-b4a1-40e24cb2fbd3&table=block&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&expirationTimestamp=1693972800000&signature=I1B4tmgdogxyH1hH2MyUOkK_4o7GyueSUAB94zxKkx4)\n    \n    [이벤트 위임 적용 후]\n    \n    - JavaScript에서 함수는 객체입니다. 함수가 많을수록 메모리 사용량이 증가하고 함수가 적을수록 메모리 사용량이 감소합니다.\n    - 이벤트 위임을 적용하면 조건문에 의해 원하는 요소에 원하는 동작을 수행하도록 코드를 구현할 수 있습니다.\n    - 코드의 간결화, 메모리 사용량 감소, 성능향상,\n    \n    ```jsx\n    // 상위 요소인 id가 'div-content'인 div 노드만 접근함\n    const divNode = document.getElementById('div-content');\n    \n    // div 노드에만 이벤트 리스너를 설정\n    divNode.addEventListener('click', function (e) {\n      const tagName = e.target.tagName;\n    \n      if (tagName === 'DIV') {\n        console.log('div Click');\n      } else if (tagName === 'SPAN') {\n        console.log('span id Click');\n      } else if (tagName === 'BUTTON') {\n        console.log('button Click');\n      }\n    });\n    ```\n    \n- stopPropagation() 이란?\n    \n    *이렇게 복잡한 이벤트 전달 방식 알고 싶지 않고, 그냥 원하는 화면 요소의 이벤트만 신경 쓰고 싶어요. →* Event객체의  **`stopPropagation()` 메서드를 활용해서 현재 이벤트가 캡처링/버블링 단계에서 더 이상 전파되지 않도록 방지합니다.\n    \n    *이벤트 버블링의 경우*에는 **클릭한 요소의 이벤트만 발생시키고 상위 요소로 이벤트를 전달하는 것을 방해**합니다. *이벤트 캡쳐의 경우*에는 **클릭한 요소의 최상위 요소의 이벤트만 동작시키고** 하위 요소들로 이벤트를 전달하지 않습니다.\n    \n    ```html\n    <div class='DIV1'>\n        DIV1\n        <div class='DIV2'>\n          DIV2\n          <div class='DIV3'>DIV3</div>\n        </div>\n    ```\n    \n    ```jsx\n    //캡처링 stopPropagation()\n    <script>\n    const divs = document.querySelectorAll('div');\n\n    const clickEvent = (event) => {\n      event.stopPropagation();\n      console.log(event.currentTarget.className); //DIV1\n    };\n    \n    divs.forEach((div) => {\n      div.addEventListener('click', clickEvent, { capture: true });\n    });\n    </script>\n    ```\n    \n    ```jsx\n    //버블링 stopPropagation()\n    <script>\n    const divs = document.querySelectorAll('div');\n    \n    const clickEvent = (event) => {\nevent.stopPropagation();\n      console.log(event.currentTarget.className); //DIV3\n};\n\ndivs.forEach((div) => {\ndiv.addEventListener('click', clickEvent);\n});\n</script>\n    ```",
        "qna": "추가해야함"
      },
      {
        "id": "8",
        "title": "JavaScript",
        "topic": "this",
        "texture": "## this\n\nthis는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. \n\nthis는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다. 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. \n\n단, 자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.\n\n🧐 **arguments 객체는 무엇인가..?** \n\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F928ac1fc-a7a3-487f-9694-5f63e231cfb8%2FUntitled.png?table=block&id=f0e6eeef-d205-4c31-9d05-6c0d9845c5ff&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1340&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n🧐 **this 바인딩**\n\n바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어, 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다. this 바인딩은 this와 this가 가리킬 객체를 바인딩하는 것이다. \n\n```jsx\n// this는 어디서든지 참조 가능하다.\n// 전역에서 this는 전역 객체 window를 가리킨다.\nconsole.log(this); // window\n\nfunction square(number) {\n\t// 일반 함수 내부에서 this는 전역 객체 window를 가리킨다.\n  console.log(this); // window\n\treturn number * number;\n}\nsquare(2);\n\nconst person = {\n\tname: 'Lee',\n\tgetName() {\n\t\t// 메서드 내부에서 this는 메서드를 호출한 객체를 가리킨다. \n    console.log(this); {name: 'Lee', getName: f}\n\t\treturn this.hame;\n  }\n};\nconsole.log(person.getName()); // Lee\n\nfunction Person(name) {\n\tthis.name = name;\n  // 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.\n  console.log(this); // Person {name: 'Lee}\n}\n\nconst me = new Person('Lee');\n```\n\n하지만 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반적으로 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다. 따라서 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다. 일반 함수 내부에서 this를 사용할 필요가 없기 때문이다. \n\n## 함수 호출 방식과 this 바인딩\n\n**this바인딩(this에 바인딩될 값)은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.** \n\n🧐**렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.**\n\n함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. 하지만 this 바인딩은 함수 호출 시점에 결정된다.\n\n함수를 호출하는 방식 \n\n1. 일반 함수 호출\n2. 메서드 호출\n3. 생성자 함수 호출\n4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출\n\n### 1. 일반 함수 호출\n\n기본적으로 this에는 전역 객체(global object)가 바인딩된다.\n\n```jsx\nfunction foo() {\n\tconsole.log(\"foo's this: \", this); // window\n  function bar() {\n\t  console.log(\"bar's this: \", this); // window\n  }\n  bar();\n}\nfoo();\n```\n\n전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.                                           \n\n다만 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 객체를 생성하지 않는 일반 함수에서 this는 의미가 없다. 따라서 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다.                                                                         \n\n일반 함수로 호출된 모든 함수(중첩함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.\n\n하지만 메서드 내에서 정의한 중첩 함수나 메서드에게 전달한 콜백 함수(보조 함수)가 일반 함수로 호출될 때 메서드 내의 중첩 함수 또는 콜백 함수의 this가 전역 객체를 바인딩하는 것은 문제가 있다. 중첩 함수 또는 콜백 함수는 외부 함수를 돕는 헬퍼 함수의 역할을 하므로 외부 함수의 일부 로직을 대신하는 경우가 대부분이다. 하지만 외부 함수인 메서드와 중첩 함수 또는 콜백 함수의 this가 일치하지 않는다는 것은 중첩 함수 또는 콜백 함수를 헬퍼 함수로 동작하기 어렵게 만든다. \n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n\tconsole.log(\"foo's this: \", this); // {value: 100, foo: f}\n    // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.\n    setTimeout(function () {\n\t\tconsole.log(\"callback's this: \", this); // window\n      console.log(\"callback's this.value: \", this.value); // 1\n    }, 100);\n  }\n};\n\nobj.foo()\n```\n\n메서드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메서드의 this 바인딩과 일치시키기 위한 방법은 다음과 같다. \n\n방법①\n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n  // this 바인딩(obj)을 변수 that에 할당한다.\n  const that = this;\n  \n  // 콜백 함수 내부에서 this 대신 that을 참조한다.\n  setTimeout(function () {\n\t\tconsole.log(that.value); // 100\n\t}, 100);\n }\n};\n\nobj.foo();\n```\n\n방법② \n\n- this를 명시적으로 바인딩할 수 있는 Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메서드 사용하기 \n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n\tfoo() {\n\t\t// 콜백 함수에 명시적으로 this를 바인딩한다.\n    setTimeout(function () {\n\t\t\tconsole.log(this.value); // 100\n    }.bind(this), 100);\n  }\n};\n\nobj.foo();\n```\n\n방법③ \n\n- 화살표 함수를 사용해서 this 바인딩을 일치시키기\n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n\t\t// 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.\n  setTimeout(() => console.log(this.value), 100); // 100\n  }\n};\n\nobj.foo(); \n```\n\n### 2. 메서드 호출\n\n메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다. 주의할 것은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다. \n\n```jsx\nconst person = {\n\tname: 'Lee',\n  getName() {\n\t\t// 메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다. \n    console.log(this); {name: 'Lee', getName: f}\n\t\treturn this.name;\n  }\n};\n\n// 메서드 getName을 호출한 객체는 person이다.\nconsole.log(person.getName()); // Lee  \n```\n\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbbcb928d-8ddf-465c-909d-7af0fbd7215a%2FUntitled.png?table=block&id=68a5ce2d-c73a-4b2d-8220-561ff980a838&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1770&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n### 3. 생성자 함수 호출\n\n생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.\n\n```jsx\nfunction Circle(radius) {\n\t// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.\n  this.radius = radius;\n  this.getDiameter = function () {\n\t\treturn 2 * this.radius;\n  };\n}\n\n// 반지름이 5인 Circle 객체를 생성\nconst circle1 = new Circle(5);\n// 반지름이 10인 Circle 객체를 생성\nconst circle2 = new Circle(10);\n\nconsole.log(circle1.getDiameter()); // 10\nconsole.log(circle2.getDiameter()); // 20 \n```\n\n### 4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출\n\napply, call, bind 메서드는 Function.prototype의 메서드다. 즉 이들 메서드는 모든 함수가 상속받아 사용할 수 있다. \n\nFunction.prototype.apply,  Function.prototype.call 메서드는 this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 호출한다.\n\n```jsx\nfunction getThisBinding() {\n\treturn this;\n}\n\n// this로 사용할 객체\nconst thisArg = {a: 1};\n\nconsole.log(getThisBinding()); // window\n\n// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.\nconsole.log(getThisBinding.apply(this.Arg)); // {a: 1}\nconsole.log(getThisBinding.call(this.Arg)); // {a: 1} \n```\n\napply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다. \n\napply와 call 메서드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작한다. apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다. call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다. \n\n 그렇다면 apply와 call 메서드의 용도는 무엇일까? \n\napply와 call 메서드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice 같은 배열의 메서드를 사용할 수 없으나 apply와 call 메서드를 이용하면 가능하다. \n\n```jsx\nfunction convertArgsToArray() {\n\tconsole.log(arguments);\n\t\n\t// arguments 객체를 배열로 변환\n  // Array.prototype.slice를 인수 없이 호출하면 배열의 복사본을 생성한다. \n  const arr = Array.prototype.slice.call(arguments);\n  // const arr = Array.prototype.apply(arguments);\n  console.log(arr);\n \n  return arr;\n}\n\nconvertArgsToArray(1, 2, 3); // [1, 2, 3]\n\n```\n\nFunction.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않는다. 다만 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 새롭게 생성해 반환한다. \n\n```jsx\nfunction getThisBinding() {\n\treturn this;\n}\n\n// this로 사용할 객체\nconst thisArg - {a : 1};\n\n// bind 메서드는 첫 번째 인수로 전달한 thisArg로 this 바인딩이 교체된\n// getThisBinding 함수를 새롭게 생성해 반환한다.\nconsole.log(getThisBinding.bind(thisArg)); // getThisBinding\n// bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.\nconsole.log(getThisBinding.bind(thisArg())); // {a : 1}\n```\n\n그렇다면 bind메서드는 언제 사용할까? \n\n```jsx\nconst person = {\n\tname: 'Lee',\n  foo(callback) {\n   // ①\n  setTimeout(callback, 100);\n  }\n};\n\nperson.foo(function () {\n\tconsole.log(`Hi! my name is ${this.name}.`); // ② Hi my name is .\n  // 일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.\n  // 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 '' 이다.\n  // Node.js 환경에서 this.name은 undefined다.\n}); \n```\n\nperson.foo의 콜백 함수가 호출되기 이전인 ①의 시점에서 this는 foo 메서드를 호출한 객체, 즉 person 객체를 가리킨다. \n\n그러나 person.foo의 콜백 함수가 일반 함수로서 호출된 ②의 시점에서 this는 전역 객체 window를 가리킨다. 따라서 person.foo의 콜백 함수 내부에서 this.name은 window.name과 같다.\n\n이때 위 예제에서 person.foo의 콜백 함수는 외부 함수 person.foo를 돕는 헬퍼 함수(보조 함수) 역할을 하기 때문에 외부 함수 person.foo 내부의 this와 콜백 함수 내부의 this가 상이하면 문맥상 문제가 발생한다.\n\n따라서 콜백 함수 내부의 this를 외부 함수 내부의 this와 일치시켜야 한다. 이때 bind 메서드를 사용하여 this를 일치시킬 수 있다.",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. this에 대해서 설명해주세요.\n\n # A.\n\n this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. \n\n그리고 this가 가리키는 값, 즉 this 바인딩(this와 this가 가리킬 객체를 바인딩하는 것)은 함수 호출 방식에 의해 동적으로 결정된다."
      },
      {
        "id": "9",
        "title": "JavaScript",
        "topic": "이터러블",
        "texture": "### 🎈주제 선정 이유?\n\n호이스팅, 브라우저 렌더링 등과 같이 프론트엔드 기술면접 단골질문까진 아니지만, 부트캠프 수업에서 이터러블에 대해 자세히 다룬적이 없어서 이터러블에 대한 이해가 부족했다. 스터디원분들도 마찬가지가 아닐까 싶어서 공부도 할겸 이터러블로 주제를 선정하게 되었다.\n\n### ⛳ 이번 목표\n\n이터러블과 이터레이션에 대해 알아보자\n\n---\n\n### 1. 이터러블\n\n네이버 영어사전에 iterate를 찾아보면 반복하다라는 의미가 있다.\n\n![image](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2F3a892a75-8c16-4b62-9212-55d3a7bb89f8%2Fimage.png?table=block&id=281d1b41-c4b4-4463-baea-99cb8df016ab&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이터러블 프로토콜을 준수한 객체를 이터러블이라한다. 즉, 이터러블은 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다.\n\n```javascript\n// Symbol.iterator를 프로퍼티 키로 사용한 메서드\n [Symbol.iterator]() {\n// 이터레이터 객체 반환\n}\n```\n\n예를 들어, 배열은 Array.prototype의 Symbol.iterator 메서드를 상속받는 이터러블이다. 이터러블은 for ... of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.\n\n Symbol.iterator 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다. 따라서 일반 객체는 for ... of 문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭쳐링 할당의 대상으로 사용할 수 없다.\n\n```javascript\n const obj = {a: 1, b: 2};\n\n// 일반 객체는 Symbol.iterator 메서드를 구현하거나 상속받지 않는다.\n// 따라서 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.\n console.log(Symbol.iterator in obj); // false\n\n// 이터러블이 아닌 일반 객체는 for ... of 문으로 순회할 수 없다.\n for (const item of obj) { // → TypeError: obj is not iterable\n console.log(item);\n}\n\n// 이터러블이 아닌 일반 객체는 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.\n const [a, b] = obj; // → TypeError: obj is not iterable\n```\n\n🤔 그렇다면 이터러블이 아닌 일반 객체는 스프레드 문법도 사용하지 못하겠다라는 생각이 들 수 있다. 하지만 스프레드 프로퍼티 제안(stage 4)은 일반 객체에 스프레드 문법의 사용을 허용한다고 한다.\n\n```javascript\nconst obj = {a: 1, b: 2};\n\n console.log({...obj})l // {a: 1, b: 2};\n```\n\n그리고 일반 객체도 이터러블 프로토콜을 준수하도록 구현하면 이터러블이 된다고 한다.\n\n### 2. 이터레이터\n\n이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 next 메서드를 소유하며 next 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. 이러한 규약을 이터레이터 프로토콜이라 하며, 이터레이터 프로토콜을 준수한 객체를 이터레이터라 한다.\n\n```javascript\n// 배열은 이터러블 프로토콜을 준수한 이터러블이다.\n const array = [1, 2, 3]; \n\n // Symbol.iterator 메서드는 이터레이터를 반환한다.\n const iterator = array[Symbol.iterator]();\n\n// Symbol.iterator 메서드가 반환한 이터레이터는next 메서드를 갖는다.\n console.log('next' in iterator); // true\n\n// next 메서드를 호출하면 이터러블을 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다.\n// 이터레이터 리절트 객체는 value와 done 프로퍼티를 갖는 객체다.\n console.log(iterator.next());  // { value: 1, done: false }\n console.log(iterator.next());  // { value: 2, done: false }\n console.log(iterator.next());  // { value: 3, done: false }\n console.log(iterator.next());  // { value: undefined, done: true }\n```\n\n### 3. 이터러블과 유사 배열 객체\n\n유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.\n\n유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있고, 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로 가지므로 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.\n\n```javascript\n// 유사 배열 객체\n const arrayLike = {\n0: 1,\n 1: 2,\n 2: 3,\nlength: 3\n};\n\n// 유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있다.\nfor (let i = 0; i < arrayLike.length; i++) {\n  // 유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.\n  console.log(arrayLike[i]); // 1 2 3\n}\n```\n\n🤔 그렇다면 유사 배열 객체는 배열처럼 for ... of 문으로 순회할 수 있을까..?\n\n이에 대한 답은 'NO' 이다. 유사 배열 객체는 이터러블이 아닌 일반 객체다. 따라서 유사 배열 객체에는 Symbol.iterator 메서드가 없기 때문에 for ... of 문으로 순회할 수 없다.\n\n```javascript\n// 유사 배열 객체는 이터러블이 아니기 때문에 for ... of 문으로 순회할 수 없다.\nfor (const item of arrayLike) {\n console.log(item);\n}\n// → TypeError: arrayLike is not iterable\n```\n\n유사 배열 객체이면서 이터러블인 것: arguments, NodeList, HTMLCollection\n\n정확히 말하면 ES6에서 이터러블이 도입되면서 유사 배열 객체인 arguments, NodeList, HTMLCollection 객체에 Symbol.iterator 메서드를 구현하여 이터러블이 되었다. 하지만 이터러블이 된 이후에도 length 프로퍼티를 가지며 인덱스로 접근할 수 있는 것에는 변함이 없으므로 유사 배열 객체이면서 이터러블인 것이다.\n\n→ 모든 유사 배열 객체가 이터러블인 것은 아니다. 유사 배열 객체 중에 이터러블인 것이 있고 아닌 것이 있다.\n\n배열도 마찬가지로 ES6에서 이터러블이 도입되면서 Symbil.iterator 메서드를 구현하여 이터러블이 되었다.\n\n위의 예제에서의 arrayLike 객체는 ES6에서 도입된 Array.from 메서드를 사용하여 배열로 간단히 변환할 수 있다.\n\nArray.from 메서드는 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환하여 반환한다.\n\n```javascript\n// 유사 배열 객체\nconst arraLike = {\n 0: 1,\n 1: 2,\n 2: 3,\n length: 3\n};\n\n// Array.from은 유사 배열 객체 또는 이터러블을 배열로 변환한다.\nconst arr = Array.from(arrayLike);\nconsole.log(arr); // [1, 2, 3]\n```\n\n### 4. 이터레이션 프로토콜의 필요성\n\n💡 그렇다면 왜 이터레이션 프로토콜의 필요한가에 대해 알아보자.\n\nES6 이전의 순회 가능한 데이터 컬렉션(배열, 문자열, 유사 배열 객체, DOM 컬렉션 등)등은 통일한 규약 없이 각자 나름의 구조를 가지고 for 문, for ... in 문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다. ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for ... of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화했다.\n\n이터러블은 for ... of 문, 스프레드 문법, 배열 디스트럭처링 할당과 같은 데이터 소비자에 의해 사용되므로 데이터 공급자의 역할을 한다고 할 수 있다.\n\n만약 다양한 데이터 공급자가 각자의 순회 방식을 갖는다면 데이터 소비자는 다양한 데이터 공급자의 순회 방식을 모두 지원해야 한다. 이는 효율적이지 않다. 하지만 다양한 데이터 공급자가 이터레이션 프로토콜을 준수하도록 규정하면 데이터 소비자는 이터레이션 프로토콜만 지원하도록 구현하면 된다.\n\n즉, 이터러블을 지원하는 데이터 소비자는 내부에서 Symbol.iterator 메서드를 호출해 이터레이터를 생성하고 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 이터레이터 리절트 객체를 반환한다. 그리고 이터레이터 리절트 객체의 value/done 프로퍼티 값을 취득한다.\n\n이처럼 이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 한다.\n\n![image](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2Fa6742119-741e-4d11-bed2-be5624695fdf%2Fimage.png?table=block&id=be23645f-ed39-49ff-aaea-0c029d41be29&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. 이터러블에 대해서 설명해주세요.\n\n # A.\n\n \n이터러블이란 반복이 가능한 객체를 말합니다.\n이터러블은 `Symbol.iterator` 메서드를 가지고 있는데, 이 메서드는 이터레이터를 반환하여, 이터러블 객체의 각 요소를 반복할 수 있도록 해줍니다.\n\n이터레이터는 이터러블 객체에서 값을 순차적으로 가져오는 법을 정의합니다.\n\n이터레이터는`next()`메서드를 호출할 때마다 이터러블 객체에서 다음 값을 가져오고, 가져올 값이 없을 경우 done 프로퍼티가 true인 객체를 반환합니다.\n\n 이터러블과 이터레이터 프로토콜을 사용하여, 다양한 자료구조를 반복할 수 있습니다. \n\n 예를 들어 배열, 문자열, Map, Set, NodeList 등의 객체는 모두 이터러블입니다. 따라서 for ... of 문이나 전개 연산자, 구조 분해 할당 등을 사용하여 이러한 객체를 반복하고 다룰 수 있습니다."
      },
      {
        "id": "10",
        "title": "JavaScript",
        "topic": "props drilling",
        "texture": "## 🎈주제 선정 이유?\n\n프로젝트에 필요한 redux toolkit에 대해 공부하다가, 상태관리가 등장한 배경에 대해서 궁금해져서 조사하게 되었다.\n\n## ⛳ 학습 목표\n\nprops drilling은 무엇이고 어떻게 피할 수 있는지에 대해 학습한다.\n\n## ⛏️ Props Drilling이란\n\n![이미지](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2Fec3d3141-98e0-4288-994c-a4b107e852de%2Fimage.png?table=block&id=c70b3d1b-cfa4-4727-adc8-0e31edd09ed2&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n`Props Drilling` 은 props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정이다.\n\n### 😀 Props Drilling의 장점\n\n- 컴포넌트 간에 데이터를 전달하는 가장 쉽고 빠르게 전달할 수 있다.\n- (작은 규모의 어플리케이션에서) 컴포넌트를 잘게 분할해서 Props drilling을 통해 전달하면, 코드를 실행하지 않고 정적으로 따라가는 것만으로도 어떤 데이터가 어디서 사용되는지 쉽게 파악할 수 있으며, 수정도 용이하다\n\n### 😱 그렇다면 Props Drilling이 문제인 이유는 무엇인가?\n\n어플리케이션의 규모가 커지고, 중간 컴포넌트의 수가 많아지게 되면서 불필요한 props 전달로 인해 유지보수도 어렵고 가독성도 떨어질 수 있다.\n\n- 필요보다 많은 props를 전달하다가, 컴포넌트를 분리하는 과정에서 필요하지 않은 props가 계속 남거나 전달되는 문제\n- props 전달이 누락되었는데 `defaultProps`가 과용되었을 때, props가 전달되지 않은 상황을 인지하기가 어려운 문제\n- 자세한 설명\n\n    (ChatGPT)>> 일반적으로, React에서 defaultProps는 props의 기본값을 정의하는 데 사용된다. 만약 상위 컴포넌트에서 하위 컴포넌트로 props를 전달하지 않았을 때, defaultProps에 정의된 기본값이 하위 컴포넌트에 자동으로 적용된다. 이는 기본적으로 컴포넌트가 동작하는 데는 문제가 없지만, 때로는 예상치 못한 동작이 발생할 수 있다.문제는, defaultProps를 과용하여 하위 컴포넌트에서 필요한 props를 전달하지 않아도 문제가 발생하지 않는다고 착각할 수 있다는 점이다. 실제로는 props가 전달되지 않은 상황에서도 defaultProps에 정의된 기본값이 사용되기 때문에, 버그를 파악하고 수정하는 데 어려움을 겪을 수 있다.따라서, Props Drilling을 사용할 때는 defaultProps를 신중하게 사용해야 합니다. 필요한 props가 명시적으로 전달되도록 하고, defaultProps는 최소한의 기본값 설정에 사용하는 것이 좋다. 이렇게 하면 props 전달이 누락되었을 때 실제로 문제가 발생하며, 이를 빠르게 인지하고 수정할 수 있게 된다.\n\n- props의 이름이 전달 중에 변경되어서 데이터를 추적하기 쉽지 않게되는 문제\n- 자세한 설명(ChatGPT)>> Props Drilling을 사용하면서 props의 이름이 중간 컴포넌트를 거치면서 변경되는 경우를 의미한다. 이는 props의 이름이 상위 컴포넌트에서 하위 컴포넌트로 전달되는 동안 수정되거나 재정의되어 데이터의 추적이 어려워지는 상황을 말한다.예를 들어, 상위 컴포넌트에서 하위 컴포넌트로 value라는 이름의 props를 전달한다고 가정해보자. 하지만 중간 컴포넌트에서 value를 받은 후 다른 이름으로 변경하거나 다른 컴포넌트에 전달할 수 있다. 이 경우 하위 컴포넌트에서는 원래 props 이름이 무엇이었는지 추적하기 어려워지고, 코드를 분석하거나 디버깅하기 어려워진다.이러한 상황에서는 코드의 가독성과 유지보수성이 저하될 수 있다. 특히 프로젝트가 커지고 여러 컴포넌트가 복잡하게 얽혀있을 때, props 이름의 변경이 제대로 추적되지 않으면 버그를 찾기 어려워진다.\n\n    (ChatGPT)>> Props Drilling을 사용하면서 props의 이름이 중간 컴포넌트를 거치면서 변경되는 경우를 의미한다. 이는 props의 이름이 상위 컴포넌트에서 하위 컴포넌트로 전달되는 동안 수정되거나 재정의되어 데이터의 추적이 어려워지는 상황을 말한다.예를 들어, 상위 컴포넌트에서 하위 컴포넌트로 value라는 이름의 props를 전달한다고 가정해보자. 하지만 중간 컴포넌트에서 value를 받은 후 다른 이름으로 변경하거나 다른 컴포넌트에 전달할 수 있다. 이 경우 하위 컴포넌트에서는 원래 props 이름이 무엇이었는지 추적하기 어려워지고, 코드를 분석하거나 디버깅하기 어려워진다.이러한 상황에서는 코드의 가독성과 유지보수성이 저하될 수 있다. 특히 프로젝트가 커지고 여러 컴포넌트가 복잡하게 얽혀있을 때, props 이름의 변경이 제대로 추적되지 않으면 버그를 찾기 어려워진다.\n\n### 🔧 그렇다면 이러한 Props Drilling으로 생기는 문제 피하는 방법은?\n\n1) 렌더링 될 컴포넌트를 불필요하게 여러 컴포넌트로 나누지 않는다.\n\nReact는 (권장되지는 않지만)단 하나의 컴포넌트에 어플리케이션 전체를 작성하더라도 기술적인 제약은 없다. 따라서 성급하게 불필요한 컴포넌트 쪼개기를 할 필요는 없다. 컴포넌트를 재사용해야할 상황을 기다렸다 분할해도 늦지 않으며, 불필요한 prop drilling도 하지 않을 수 있다.\n\n2) defaultProps를 필수 컴포넌트에 사용하지 않는다.\n\ndefaultProps를 사용하면 컴포넌트가 제대로 동작하기 위해 꼭 필요한 props가 전달되지 못한 상황에도 중요한 오류가 가려지게 된다. 따라서 defaultProps를 필수적이지 않은 컴포넌트에만 사용하면 prop drilling으로 인한 문제를 막을 수 있다.\n\n3) 가능한 관련성이 높은 곳에 state를 위치 시킨다.\n\n어떤 데이터가 어플리케이션의 특정 위치에서만 필요하다면 최상위 컴포넌트에 state를 위치시키는 것보다 해당 데이터를 필요로 하는 최소 공통 부모 컴포넌트에서 관리를 하는 것이 가장 효율적이다.\n\n4) 상태관리 도구를 사용한다.\n\n데이터를 필요로 하는 컴포넌트가 정말 깊숙히 위치하고 있다면, React에서 제공하는 Context API를 사용하거나 Redux 등의 외부 상태관리 라이브러리를 사용해서 문제를 해결할 수 있다. 물론 어플리케이션의 모든 곳에서 이와 같은 도구를 사용해야하는 것은 아니지만, 비교적 손쉽게 문제를 해결할 수 있다.\n\n### Context API\n\nReact에 내장되어 컴포넌트 트리 전체에 데이터를 제공할 수 있는 API이다.\n\n장점\n\n- Redux는 무겁고 복잡한 라이브러리이다. 따라서 상태관리가 아닌 단순히 props를 전달할 목적이라면 context API를 사용하는 것이 적절하다.\n\n단점\n\n- Context API에서 상태값이 변경되면, provider로 감싼 모든 자식 컴포넌트가 리렌더링이 된다. 리렌더링은 성능에 영향을 미칠 수 있기 때문에 때문에 자식 컴포넌트의 불필요한 리렌더링을 방지해야한다.\n\n### Redux\n\n오픈 소스 자바스크립트 라이브러리로 state를 사용해 애플리케이션의 전역 상태 관리를 위해 사용한다.\n\n장점\n\n- 단방향 데이터 통신이 발생하기 때문에 데이터 흐름을 예측할 수 있고 디버깅에 유리하다.자세한 설명(ChatGPT)>> Redux는 상태 관리 라이브러리로서, 애플리케이션의 데이터를 중앙 집중적으로 관리하고 상태 변화를 예측 가능한 방식으로 처리한다. 이는 단방향 데이터 흐름을 갖는 아키텍처를 채택하여 데이터의 변화를 추적하고 예측하기 쉽게 만든다.단방향 데이터 흐름은 데이터의 이동 경로가 일정하고 예측 가능하다는 의미이다. Redux에서는 데이터의 흐름이 '액션 → 리듀서 → 상태'의 단방향으로 이루어진다. 액션은 상태 변화에 대한 정보를 담은 객체이며, 리듀서는 액션을 기반으로 상태를 업데이트하는 순수 함수이다. 이러한 단방향 흐름으로 인해 데이터의 변화가 어떤 경로를 따라가는지 예측할 수 있고, 디버깅 시 데이터 변화를 추적하기 용이하다.\n\n단점\n\n- 무겁고 사용하기에 복잡하다.(이를 보완하기 위해 redux toolkit 등의 라이브러리가 등장하였다.)",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. Props drilling은 무엇이고 어떻게 피할 수 있는가?.\n\n # A.\n\n Props Drilling은 props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정입니다.\n\n이는 컴포넌트 간에 데이터를 전달하는 가장 쉽고 빠르게 전달할 수 있다는 장점이 있다. 하지만 어플리케이션의 규모가 커지고, 중간 컴포넌트의 수가 많아지게 되면서 불필요한 props 전달로 인해 유지보수도 어렵고 가독성도 떨어질 수 있다.\n\n이를 피하기 위해 컴포넌트를 리팩토링하고, 컴포넌트를 더 작은 컴포넌트들로 쪼개지 않고, state를 가장 가까운 부모 컨포넌트와만 공유함으로써 props drilling 회피할 수 있습니다. 위계상 멀리/깊게(deep/far)떨어진 컴포넌트와 state를 공유할 때, React의 \n\nContext API 혹은 Redux와 같은 state 관리 라이브러리를 사용할 수 있습니다."
      },
      {
        "id": "11",
        "title": "React",
        "topic": "React를 사용하는 이유",
        "texture": "## 🎈주제 선정 이유?\n\n리액트를 활용한 프로젝트를 하면서, 리액트의 장점이 어느정도 느껴졌다. 하지만 누군가 리액트를 왜 사용하나요? 라고 묻는다면 바로 대답하기가 어려울 것 같다는 생각이 들었다. 그래서 이번에 리액트를 왜 사용하는지에 대해 조사하기로 했다.\n\n## ⛳ 학습 목표\n\n리액트는 무엇인지, 그리고 왜 리액트를 사용하는 지에 대해서 학습한다.\n\n## 📖 React를 사용하는 이유\n\n### React란?\n\n![이미지](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2F9d658f0c-d7a8-4599-991b-015b71e5e644%2Fimage.png?table=block&id=e3459bba-2a1e-4eda-84f7-f147b050c18c&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n**라이브러리**: 라이브러리(영어: library)는 주로 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임이다.\n\n사용자 인터페이스: 사람(사용자)과 사물 또는 시스템, 기계, 컴퓨터 프로그램 등 사이에서 의사소통을 할 수 있도록 일시적 또는 영구적인 접근을 목적으로 만들어진 물리적, 가상적 매개체를 뜻한다.\n\n출처: 위키백과\n\n### React의 특징\n\n1. 가상 돔의 사용으로 DOM 업데이트 최적화\n \n 리액트 개발자들의 DOM 업데이트를 위해서 하는 최적화 행위를 가상 돔을 만들어 비교하고 DOM을 추상화하여 필요한 부분만 다시 그리는 방식으로 개발자들이 DOM 업데이트를 오용하는 일을 피했다.\n \n2. 컴포넌트 기반\n \n 컴포넌트 기반인 리액트는 특정 기능을 구현하거나 특정 화면을 구현할 때 그 화면을 구성하는 일에만 집중할 수 있게 해준다. 여러 명의 프론트엔드 개발자가 하나의 페이지를 만든다고 해도 서로 다른 파일을 작업하도록 구성할 수 있기 때문에 효율적인 코드 분리가 가능하다.\n \n3. 생태계 및 수 많은 커뮤니티와 지속적인 개발\n \n 리액트의 생태계는 여러 다른 라이브러리, 프레임워크 커뮤니티보다 활발하다. 단순 View만을 관리하는 리액트가 프레임워크처러 사람들이 사용할 수 있을 정도이다. 페이스북이 만들었고 주도하고 있으며, AiRbnb, Netflix같은 기업들이 리액트를 사용 중에 있다.\n \n4. React Native의 앱 개발 기능\n \n React Native는 모바일 앱을 만들기 위한 프레임워크로 React 기반으로 만들어졌습니다. 그래서 React로 기존에 개발을 하는 웹 개발자라면 React Native를 금방 배울 수 있고 쉽게 모바일 앱을 만들 수 있다.",
        "qna": "## 4. 요약 정리 및 면접형 QnA\n\n# Q. React은 무엇이고, 왜 사용하는가?\n\n # A.\n\n 리액트는 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리입니다.\n\n그리고 리액트는 아래와 같은 이점이 있어 많이 사용되고 있습니다.\n\n1. 컴포넌트 단위로 구성하여 조합, 분해하기가 쉽습니다.\n\n2. 로직과 뷰를 분리하여 구분하기 쉽습니다.(로직은 컴포넌트의 동작과 상태를 처리하고, 뷰는 컴포넌트의 외형과 사용자 인터페이스를 정의합니다. 이렇게 분리된 코드는 이해하기 쉽고 유지보수가 용이합니다.)\n\n3. 가상 DOM을 활용하기 때문에 화면이 자주 바뀌는 경우 렌더링 자원을 아낄 수 있습니다.\n\n4. 상태 관리와 이에 따른 뷰의 변화를 제어하기 쉽습니다.(상태의 변화를 감지하고, 이에 따른 뷰의 업데이트를 자동으로 처리할 수 있는 기능과 패턴을 제공한다.)"
      }
    ]
  },
  {
    "title": "JavaScript",
    "items": [
      {
        "id": "1",
        "title": "JavaScript",
        "topic": "객체",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "2",
        "title": "JavaScript",
        "topic": "상속",
        "texture": "# 1. 주제 선정 이유\n\n코딩을 하다보면, 종종 상속이라는 용어를 많이 들어봤을 것이다. 물론, 상속의 사전적인 개념인 '하위존재가 상위존재로부터 무언가를 물림받는다.' 는 것 정도는 유추할 수 있을 것이다. 하지만, 코딩이나 IT업계에서 언급하는 상속에 대해 제대로 알고 넘어가는 것이 실제로 프로젝트에 적용할 때, 보다 수월하고 익숙하게 사용할 수 있을 것이기에 선정했다.\n\n# 2. 상속\n\n## 2-1. 상속의 정의 및 종류\n\n- 자바스크립트에서 사용되는 상속은 프로토타입 상속과 클래스 상속 크게 두 가지로 나뉜다. \n- 프로토타입 상속 : 상속을 받든 객체가 상속을 해주는 객체의 프로퍼티나 메서드를 추가로 사용할 수 있게 해주는 체계를 의미한다. \n- 클래스 상속 : 기존의 클래스를 확장시키는 개념으로 이해하면 좋다. 상속받은 기존의 클래스를 토대로 새로운 기능을 추가하는 시스템을 의미한다.\n\n## 2-2. 프로토타입과 상속의 관계\n\n- 프로토타입 (객체) : 다른 객체에 대한 참조 하는 대상을 의미한다. 모든 객체는 [[prototype]]이라는 내부 프로퍼티를 갖는다. [[prototype]]를 저장창고라고 이해면 좋다.\n\n - 예를 들어, 아래의 경우, 전부 객체로 이루어져있기에 객체의 프로토타입은, [[prototype]] : Object 즉, Object.prototype이다. 그리고 상속받는 객체들이 [[prototype]]안으로 들어간다. \n- `__proto__` : 객체가 자신의 프로토타입에 접근하도록 해주는 접근자 프로퍼티이다. 일종의 **다리(bridge)**라고 이해하면 좋을 듯하다. 해당 프로퍼티를 사용하여 상속받을 객체가 자신의 프로토타입에 들어갈 수 있도록 연결해준다. \n - 즉, `__proto__` 를 사용하여 상위(부모) 객체가 하위(자식) 객체의 프로토타입에 추가되는 과정을 상속이라고 한다.\n\n![사진](https://velog.velcdn.com/images/dainel-q/post/0ba7368c-6a60-4f68-8da4-be69a0422c37/image.png) \n\n## Q. 그런데 왜 프로토타입 상속을 하는 것인가요??\n\n -우선은 한 사례를 통해 살펴보자\n\n![사진](https://velog.velcdn.com/images/dainel-q/post/7f14b541-0997-4b62-b31f-86a9e4328d7c/image.png)\n - 위 예시의 경우, food를 상속받은 pasta 객체가 cook이라는 메서드를 자유롭게 사용할 수 있는 사례이다. 즉, pasta 객체에서 cook메서드를 더 만들지 않고 상속받아 편하게 사용할 수 있다는 것을 의미한다. 이는 곧, 코드의 재사용성을 높이고 , 관리를 용이하게 해준다는 장점을 갖고 있다.\n\n## 2-3. 클래스와 상속의 관계\n\n- 클래스(class) : 하나의 생성자 함수를 여러개 찍어낼 수 있게 해주는 문법으로 흔히 붕어빵 틀에 비유한다. - 먼저 상속을 할 부모 클래스를 생성한다.\n\nclass Food {\n constructor (name) {\n this.name = name;\n this.won = 0;\n }\n\n price(won) {\n this.won = won;\n console.log(${this.name}의 가격은 ${this.won}원 입니다.)\n }\n\n pay(){\n console.log(${this.won}원을 지불하셨습니다.)\n }\n}\n\nconst food = new Food('음식');\n\nclass Pasta extends Food {\n tasty(){\n console.log(${this.name} 맛있네요!)\n }\n}\n\nconst pasta = new Pasta('아라비따 파스타');\n\n- 위 예시를 합치면\nclass Food {\n constructor (name) {\n this.name = name;\n this.won = 0;\n }\n\n price(won) {\n this.won = won;\n console.log(${this.name}의 가격은 ${this.won}원 입니다.)\n }\n\n pay(){\n console.log(${this.won}원을 지불하셨습니다.)\n }\n}\n\nconst food = new Food('음식');\n\nclass Pasta extends Food {\n tasty(){\n console.log(${this.name} 맛있네요!)\n }\n}\n\nconst pasta = new Pasta('아라비따 파스타');\n\n- pasta클래스는 food 클래스를 상속받고 있다는 것을 의미한다. 그렇기에 food클래스의 메서드를 사용할 수 있다.\npasta.price(12000; // 아라비따 파스타의 가격은 12000원 입니다.\npasta.pay(12000); // 12000원을 지불하셨습니다.\npasta.tasty(); // 아라비따 파스타 맛있네요!\n\n## Q. 그런데 왜 클래스 상속을 하는 것인가요??\n\n- 프로토타입의 상속을 하는 이유와 유사하게, 상속을 주고 받기에, 작성해야할 코드의 양이 줄어든다. 특히, 클래스의 경우, 생성자 메서드등 작성해야할 내용이 많기에, 상속의 장점이 더욱 부각된다. - 코드의 재사용성을 높이고 , 관리를 용이하게 해준다는 장점이 있기 때문에 사용한다.",
        "qna": "# 3. 요약 정리 및 면접형 QnA\n\nQnA: 자바스크립트에서 사용하는 상속은 무엇이고, 그 기능이 무엇인가요?\n\n상속은 상속받는 자식요소가 상속해주는 부모요소의 프로퍼티나 메서드를 **추가로** 사용할 수 있도록 **확장**해주는 기능입니다. 자바스크립트의 경우, **프로토타입 상속**과 **클래스 상속** 두 가지 유형의 상속이 있습니다.\n\n- 프로토타입의 상속은, 객체 안의 `[[prototype]]`라는 내부 프로퍼티 안에 `__proto__`라는 접근자 프로퍼티로 객체들을 상속받아 저장하여 사용합니다.\n- 클래스 상속은, 부모 클래스를 `extends`라는 키워드를 사용하여 자식 클래스가 상속받아 사용합니다.\n\n상속을 사용하는 이유는 코드의 재사용성을 높이고, 유지보수가 필요한 경우 특정 부분만 수정해도 되기에 관리를 용이하게 만든다는 장점이 있습니다."
      },
      {
        "id": "7",
        "title": "JavaScript",
        "topic": "이벤트 버블링",
        "texture": " ## 1.  정의 : \n\n🎯 이벤트 버블링(event bubbling)은 HTML에서 이벤트가 발생했을 때, 해당 요소에서 이벤트가 처리된 후, **상위 요소로 이벤트가 전파되는 현상**을 말합니다. *(Trigger clicks all the way up)* 이벤트 버블링은 이벤트가 전파되는 동안 부모 요소에서도 이벤트를 감지할 수 있다는 **장점**이 있습니다. 즉, 이벤트를 처리하는 핸들러 함수를 부모 요소에 등록해놓으면, 자식 요소에서 발생한 이벤트도 모두 처리할 수 있습니다. 이를 활용하면, 여러 개의 하위 요소에서 발생하는 이벤트를 하나의 이벤트 핸들러로 바인딩하는 **이벤트 위임 처리**를 할 수 있습니다.\n\n![이벤트 버블링](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F58daf214-1434-4922-8f83-d22f9ea4129c%2FUntitled.png?table=block&id=db53aae9-446e-4eda-9c51-6781a607031b&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1440&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이벤트 버블링\n\n\n![이벤트 흐름 3단계](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6ad187ed-1aaf-4bdf-8294-3dec2e6e6ead%2FUntitled.png?table=block&id=28e1fbd7-40fa-4f4e-94cb-6e26b17b0ff7&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1280&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이벤트 흐름 3단계\n\n```jsx\n//이벤트 버블링\n<style>\n    body * {\n      margin: 10px;\n      border: 1px solid rgb(255, 2, 74);\n    }\n</style>\n\n    <div class='DIV1'>\n      DIV1\n      <div class='DIV2'>\n        DIV2\n        <div class='DIV3'>DIV3</div>\n      </div>\n    </div>\n\n<script>\nconst divs = document.querySelectorAll('div');\n\nconst clickEvent = (e) => {\n  console.log(e.currentTarget.className);\n};\n\ndivs.forEach((div) => {\n  div.addEventListener('click', clickEvent);\n});\n\n</script>\n```\n\n```jsx\n//onclick\n<body>\n  <div class='DIV1'>\n    DIV1\n    <div class='DIV2'>\n      DIV2\n      <div class='DIV3'>DIV3</div>\n    </div>\n  </div>\n\n  <script>\n    const divs = document.querySelectorAll('div');\n\n    divs.forEach((div) => {\n      div.addEventListener('click',function(event){\n        console.log(event.currentTarget.className);\n      };\n    });\n\n  </script>\n</body>\n```\n\n\n## 2.  내용:\n- 이벤트 전파(흐름)가 있는 이유\n\n    *이벤트 전파란*: 브라우저는 사용자로부터 이벤트가 발생하면 가장 상단의 요소부터 하위의 요소까지 내려오고 다시 거슬러 올라가는 식으로 이벤트를 전달하여 발생하도록 한다.\n    \n    - 논리적 측면\n    \n    어쩌면 당연할지도 모르지만, 자식 요소가 부모 요소 영역 안에 위치하고 있기 때문에, 자식 요소만을 클릭했다고 그것은 부모 요소도 클릭한 셈이 되기 때문이다.\n    \n    - 성능적 측면\n    \n    이런 특징은 이벤트 등록 코드를 줄일 수 있는 장점이 있음. 여러개의 리스트가 있다고하고, 몇번째를 클릭하든 같은 종류의 이벤트를 발생시키고 싶다고하자. 그러면 일일히 이벤트를 등록해야하는데, 부모요소인 ul에만 이벤트 등록을하면, 전파에 의해 어떠한 li를 클릭해도 이벤트를 사용할 수 있음. 이를 이벤트 위임이라고 한다.\n    \n- **이벤트 버블링과 캡쳐링의 차이점에 대해서 구분해서 인지한다.**\n    \n    **이벤트 캡처링**\n    \n    이벤트가 하위 요소로 전파되는 단계. 캡처링은 버블링과는 반대로 최상위 태그에서 해당 태그를 찾아 내려간다.\n    \n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1baa6ba7-8fc6-41f1-883a-b79ea096ddca%2FUntitled.png?table=block&id=07802a68-ab20-4e72-8b71-8a07315494bd&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1840&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n    \n    위 그림처럼 특정 이벤트가 발생했을 때 최상위 요소인 body 태그에서 해당 태그를 찾아 내려갑니다. 캡처링 단계를 이용해야 하는 경우는 흔치 않기 때문에, 캡처링 단계에서 이벤트를 잡아내려면 `addEventListener` 의 옵션 객체에 `{ capture: true }` 또는 `true` 를 설정해주면 캡처링을 구현할 수 있다.\n    \n    ```jsx\n    target.addEventListener('이벤트', 콜백 함수, {capture:ture});\n    target.addEventListener('이벤트', 콜백 함수, true);\n    ```\n    \n    - `false`이면(default 값) 핸들러는 버블링 단계에서 동작합니다. (*default 값은 false이고 생략가능합니다.*)\n    - `true`이면 핸들러는 캡처링 단계에서 동작합니다.\n    \n    ```jsx\n    //이벤트 캡처링\n    <style>\n        body * {\n          margin: 10px;\n          border: 1px solid rgb(255, 2, 74);\n        }\n    </style>\n    \n    <body>\n        <div class='DIV1'>\n          DIV1\n          <div class='DIV2'>\n            DIV2\n            <div class='DIV3'>DIV3</div>\n          </div>\n        </div>\n      </body>\n    \n    <script>\n    const divs = document.querySelectorAll('div');\n    \n    const clickEvent = (event) => {\n      console.log(event.currentTarget.className); //DIV1 DIV2 DIV3\n    };\n    \n    divs.forEach((div) => {\n      div.addEventListener('click', clickEvent, { capture: true });\n    // {capture: true} 대신, true를 써줘도 됩니다.\n    });\n    </script>\n    ```\n    \n- **이벤트 위임 패턴을 이해한다.**\n    \n    이벤트 위임(Event Delegation)이란 ‘**하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식**’입니다. 캡처링과 버블링을 활용하면 강력한 이벤트 핸들링 패턴인 *이벤트 위임(event delegation)* 을 구현할 수 있습니다. \n    \n    ```html\n    <h1>오늘의 할 일</h1>\n      <ul class='itemList'>\n        <li>\n          <input type='checkbox' id='item1'>\n          <label for='item1'>이벤트 버블링 학습</label>\n        </li>\n        <li>\n          <input type='checkbox' id='item2'>\n          <label for='item2'>이벤트 캡쳐 학습</label>\n        </li>\n      </ul>\n      <script>\n        //이벤트 위임 전, 각 인풋 박스의 요소에 클릭 이벤트 리스너를 추가\n        var inputs = document.querySelectorAll('input');\n        inputs.forEach(function (input) {\n          input.addEventListener('click', function (event) {\n            alert('clicked');\n          });\n        });\n    \n        //이벤트 위임 후\n        // var itemList = document.querySelector('.itemList');\n        // itemList.addEventListener('click', function (event) {\n        //   alert('clicked');\n        // });\n    \n        // 새 리스트 아이템을 추가하는 코드,  새 리스트를 추가할 때에는, li가 2개가 있는 시점 다음이기 때문에, 새로 생기는 li들은 이벤트가 적용되지 않는다.\n        // var itemList = document.querySelector('.itemList');\n    \n        // var li = document.createElement('li');\n        // var input = document.createElement('input');\n        // var label = document.createElement('label');\n        // var labelText = document.createTextNode('이벤트 위임 학습');\n    \n        // input.setAttribute('type', 'checkbox');\n        // input.setAttribute('id', 'item3');\n        // label.setAttribute('for', 'item3');\n        // label.appendChild(labelText);\n        // li.appendChild(input);\n        // li.appendChild(label);\n        // itemList.appendChild(li);\n      </script>\n    ```\n    \n    **이벤트 위임의 목적?**\n    \n    ```html\n    <div id='div-content'>\n      <span id='span-content'>\n        <button id='btn'>버튼</button>\n      </span>\n    </div>\n    ```\n    \n    [이벤트 위임 사용 전]\n    \n    ```jsx\n    // 개별 요소를 접근해야함\n    const divNode = document.getElementById('div-content');\n    const spanNode = document.getElementById('span-content');\n    const btnNode = document.getElementById('btn');\n    \n    // 개별 요소마다 이벤트 리스너를 등록해야함\n    divNode.addEventListener('click', function () {\n      console.log('divNode Click');\n    });\n    \n    spanNode.addEventListener('click', function () {\n      console.log('spanNode Click');\n    });\n    \n    btnNode.addEventListener('click', function () {\n      console.log('btnNode Click');\n    });\n    ```\n    \n    여러 개의 이벤트 리스너를 등록하면 이벤트 버블링에 의해 상위 요소의 이벤트 리스너도 실행됩니다. 이벤트 버블링에 의해 <button> 태그에서 click 이벤트가 발생하면, 해당 이벤트는 최상위 객체인 Document까지 전파됩니다. 위 코드의 문제점은 **상위 요소의 이벤트도 실행**함으로써 t상위 요소 이벤트 리스너에 문제가 되는 코드가 존재한다면.. 개발자가 **원하지 않는 결과**를 발생시킬 수 있습니다.\n    \n    ![img.gif](https://file.notion.so/f/s/dca28498-1342-48a1-82a7-a0de390e9738/img.gif?id=46fee168-0dc5-48ad-b4a1-40e24cb2fbd3&table=block&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&expirationTimestamp=1693972800000&signature=I1B4tmgdogxyH1hH2MyUOkK_4o7GyueSUAB94zxKkx4)\n    \n    [이벤트 위임 적용 후]\n    \n    - JavaScript에서 함수는 객체입니다. 함수가 많을수록 메모리 사용량이 증가하고 함수가 적을수록 메모리 사용량이 감소합니다.\n    - 이벤트 위임을 적용하면 조건문에 의해 원하는 요소에 원하는 동작을 수행하도록 코드를 구현할 수 있습니다.\n    - 코드의 간결화, 메모리 사용량 감소, 성능향상,\n    \n    ```jsx\n    // 상위 요소인 id가 'div-content'인 div 노드만 접근함\n    const divNode = document.getElementById('div-content');\n    \n    // div 노드에만 이벤트 리스너를 설정\n    divNode.addEventListener('click', function (e) {\n      const tagName = e.target.tagName;\n    \n      if (tagName === 'DIV') {\n        console.log('div Click');\n      } else if (tagName === 'SPAN') {\n        console.log('span id Click');\n      } else if (tagName === 'BUTTON') {\n        console.log('button Click');\n      }\n    });\n    ```\n    \n- stopPropagation() 이란?\n    \n    *이렇게 복잡한 이벤트 전달 방식 알고 싶지 않고, 그냥 원하는 화면 요소의 이벤트만 신경 쓰고 싶어요. →* Event객체의  **`stopPropagation()` 메서드를 활용해서 현재 이벤트가 캡처링/버블링 단계에서 더 이상 전파되지 않도록 방지합니다.\n    \n    *이벤트 버블링의 경우*에는 **클릭한 요소의 이벤트만 발생시키고 상위 요소로 이벤트를 전달하는 것을 방해**합니다. *이벤트 캡쳐의 경우*에는 **클릭한 요소의 최상위 요소의 이벤트만 동작시키고** 하위 요소들로 이벤트를 전달하지 않습니다.\n    \n    ```html\n    <div class='DIV1'>\n        DIV1\n        <div class='DIV2'>\n          DIV2\n          <div class='DIV3'>DIV3</div>\n        </div>\n    ```\n    \n    ```jsx\n    //캡처링 stopPropagation()\n    <script>\n    const divs = document.querySelectorAll('div');\n\n    const clickEvent = (event) => {\n      event.stopPropagation();\n      console.log(event.currentTarget.className); //DIV1\n    };\n    \n    divs.forEach((div) => {\n      div.addEventListener('click', clickEvent, { capture: true });\n    });\n    </script>\n    ```\n    \n    ```jsx\n    //버블링 stopPropagation()\n    <script>\n    const divs = document.querySelectorAll('div');\n    \n    const clickEvent = (event) => {\nevent.stopPropagation();\n      console.log(event.currentTarget.className); //DIV3\n};\n\ndivs.forEach((div) => {\ndiv.addEventListener('click', clickEvent);\n});\n</script>\n    ```",
        "qna": "추가해야함"
      },
      {
        "id": "8",
        "title": "JavaScript",
        "topic": "this",
        "texture": "## this\n\nthis는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. \n\nthis는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다. 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. \n\n단, 자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.\n\n🧐 **arguments 객체는 무엇인가..?** \n\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F928ac1fc-a7a3-487f-9694-5f63e231cfb8%2FUntitled.png?table=block&id=f0e6eeef-d205-4c31-9d05-6c0d9845c5ff&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1340&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n🧐 **this 바인딩**\n\n바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어, 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다. this 바인딩은 this와 this가 가리킬 객체를 바인딩하는 것이다. \n\n```jsx\n// this는 어디서든지 참조 가능하다.\n// 전역에서 this는 전역 객체 window를 가리킨다.\nconsole.log(this); // window\n\nfunction square(number) {\n\t// 일반 함수 내부에서 this는 전역 객체 window를 가리킨다.\n  console.log(this); // window\n\treturn number * number;\n}\nsquare(2);\n\nconst person = {\n\tname: 'Lee',\n\tgetName() {\n\t\t// 메서드 내부에서 this는 메서드를 호출한 객체를 가리킨다. \n    console.log(this); {name: 'Lee', getName: f}\n\t\treturn this.hame;\n  }\n};\nconsole.log(person.getName()); // Lee\n\nfunction Person(name) {\n\tthis.name = name;\n  // 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.\n  console.log(this); // Person {name: 'Lee}\n}\n\nconst me = new Person('Lee');\n```\n\n하지만 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반적으로 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다. 따라서 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다. 일반 함수 내부에서 this를 사용할 필요가 없기 때문이다. \n\n## 함수 호출 방식과 this 바인딩\n\n**this바인딩(this에 바인딩될 값)은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.** \n\n🧐**렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.**\n\n함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. 하지만 this 바인딩은 함수 호출 시점에 결정된다.\n\n함수를 호출하는 방식 \n\n1. 일반 함수 호출\n2. 메서드 호출\n3. 생성자 함수 호출\n4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출\n\n### 1. 일반 함수 호출\n\n기본적으로 this에는 전역 객체(global object)가 바인딩된다.\n\n```jsx\nfunction foo() {\n\tconsole.log(\"foo's this: \", this); // window\n  function bar() {\n\t  console.log(\"bar's this: \", this); // window\n  }\n  bar();\n}\nfoo();\n```\n\n전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.                                           \n\n다만 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 객체를 생성하지 않는 일반 함수에서 this는 의미가 없다. 따라서 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다.                                                                         \n\n일반 함수로 호출된 모든 함수(중첩함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.\n\n하지만 메서드 내에서 정의한 중첩 함수나 메서드에게 전달한 콜백 함수(보조 함수)가 일반 함수로 호출될 때 메서드 내의 중첩 함수 또는 콜백 함수의 this가 전역 객체를 바인딩하는 것은 문제가 있다. 중첩 함수 또는 콜백 함수는 외부 함수를 돕는 헬퍼 함수의 역할을 하므로 외부 함수의 일부 로직을 대신하는 경우가 대부분이다. 하지만 외부 함수인 메서드와 중첩 함수 또는 콜백 함수의 this가 일치하지 않는다는 것은 중첩 함수 또는 콜백 함수를 헬퍼 함수로 동작하기 어렵게 만든다. \n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n\tconsole.log(\"foo's this: \", this); // {value: 100, foo: f}\n    // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.\n    setTimeout(function () {\n\t\tconsole.log(\"callback's this: \", this); // window\n      console.log(\"callback's this.value: \", this.value); // 1\n    }, 100);\n  }\n};\n\nobj.foo()\n```\n\n메서드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메서드의 this 바인딩과 일치시키기 위한 방법은 다음과 같다. \n\n방법①\n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n  // this 바인딩(obj)을 변수 that에 할당한다.\n  const that = this;\n  \n  // 콜백 함수 내부에서 this 대신 that을 참조한다.\n  setTimeout(function () {\n\t\tconsole.log(that.value); // 100\n\t}, 100);\n }\n};\n\nobj.foo();\n```\n\n방법② \n\n- this를 명시적으로 바인딩할 수 있는 Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메서드 사용하기 \n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n\tfoo() {\n\t\t// 콜백 함수에 명시적으로 this를 바인딩한다.\n    setTimeout(function () {\n\t\t\tconsole.log(this.value); // 100\n    }.bind(this), 100);\n  }\n};\n\nobj.foo();\n```\n\n방법③ \n\n- 화살표 함수를 사용해서 this 바인딩을 일치시키기\n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n\t\t// 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.\n  setTimeout(() => console.log(this.value), 100); // 100\n  }\n};\n\nobj.foo(); \n```\n\n### 2. 메서드 호출\n\n메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다. 주의할 것은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다. \n\n```jsx\nconst person = {\n\tname: 'Lee',\n  getName() {\n\t\t// 메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다. \n    console.log(this); {name: 'Lee', getName: f}\n\t\treturn this.name;\n  }\n};\n\n// 메서드 getName을 호출한 객체는 person이다.\nconsole.log(person.getName()); // Lee  \n```\n\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbbcb928d-8ddf-465c-909d-7af0fbd7215a%2FUntitled.png?table=block&id=68a5ce2d-c73a-4b2d-8220-561ff980a838&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1770&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n### 3. 생성자 함수 호출\n\n생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.\n\n```jsx\nfunction Circle(radius) {\n\t// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.\n  this.radius = radius;\n  this.getDiameter = function () {\n\t\treturn 2 * this.radius;\n  };\n}\n\n// 반지름이 5인 Circle 객체를 생성\nconst circle1 = new Circle(5);\n// 반지름이 10인 Circle 객체를 생성\nconst circle2 = new Circle(10);\n\nconsole.log(circle1.getDiameter()); // 10\nconsole.log(circle2.getDiameter()); // 20 \n```\n\n### 4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출\n\napply, call, bind 메서드는 Function.prototype의 메서드다. 즉 이들 메서드는 모든 함수가 상속받아 사용할 수 있다. \n\nFunction.prototype.apply,  Function.prototype.call 메서드는 this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 호출한다.\n\n```jsx\nfunction getThisBinding() {\n\treturn this;\n}\n\n// this로 사용할 객체\nconst thisArg = {a: 1};\n\nconsole.log(getThisBinding()); // window\n\n// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.\nconsole.log(getThisBinding.apply(this.Arg)); // {a: 1}\nconsole.log(getThisBinding.call(this.Arg)); // {a: 1} \n```\n\napply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다. \n\napply와 call 메서드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작한다. apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다. call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다. \n\n 그렇다면 apply와 call 메서드의 용도는 무엇일까? \n\napply와 call 메서드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice 같은 배열의 메서드를 사용할 수 없으나 apply와 call 메서드를 이용하면 가능하다. \n\n```jsx\nfunction convertArgsToArray() {\n\tconsole.log(arguments);\n\t\n\t// arguments 객체를 배열로 변환\n  // Array.prototype.slice를 인수 없이 호출하면 배열의 복사본을 생성한다. \n  const arr = Array.prototype.slice.call(arguments);\n  // const arr = Array.prototype.apply(arguments);\n  console.log(arr);\n \n  return arr;\n}\n\nconvertArgsToArray(1, 2, 3); // [1, 2, 3]\n\n```\n\nFunction.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않는다. 다만 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 새롭게 생성해 반환한다. \n\n```jsx\nfunction getThisBinding() {\n\treturn this;\n}\n\n// this로 사용할 객체\nconst thisArg - {a : 1};\n\n// bind 메서드는 첫 번째 인수로 전달한 thisArg로 this 바인딩이 교체된\n// getThisBinding 함수를 새롭게 생성해 반환한다.\nconsole.log(getThisBinding.bind(thisArg)); // getThisBinding\n// bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.\nconsole.log(getThisBinding.bind(thisArg())); // {a : 1}\n```\n\n그렇다면 bind메서드는 언제 사용할까? \n\n```jsx\nconst person = {\n\tname: 'Lee',\n  foo(callback) {\n   // ①\n  setTimeout(callback, 100);\n  }\n};\n\nperson.foo(function () {\n\tconsole.log(`Hi! my name is ${this.name}.`); // ② Hi my name is .\n  // 일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.\n  // 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 '' 이다.\n  // Node.js 환경에서 this.name은 undefined다.\n}); \n```\n\nperson.foo의 콜백 함수가 호출되기 이전인 ①의 시점에서 this는 foo 메서드를 호출한 객체, 즉 person 객체를 가리킨다. \n\n그러나 person.foo의 콜백 함수가 일반 함수로서 호출된 ②의 시점에서 this는 전역 객체 window를 가리킨다. 따라서 person.foo의 콜백 함수 내부에서 this.name은 window.name과 같다.\n\n이때 위 예제에서 person.foo의 콜백 함수는 외부 함수 person.foo를 돕는 헬퍼 함수(보조 함수) 역할을 하기 때문에 외부 함수 person.foo 내부의 this와 콜백 함수 내부의 this가 상이하면 문맥상 문제가 발생한다.\n\n따라서 콜백 함수 내부의 this를 외부 함수 내부의 this와 일치시켜야 한다. 이때 bind 메서드를 사용하여 this를 일치시킬 수 있다.",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. this에 대해서 설명해주세요.\n\n # A.\n\n this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. \n\n그리고 this가 가리키는 값, 즉 this 바인딩(this와 this가 가리킬 객체를 바인딩하는 것)은 함수 호출 방식에 의해 동적으로 결정된다."
      },
      {
        "id": "9",
        "title": "JavaScript",
        "topic": "이터러블",
        "texture": "### 🎈주제 선정 이유?\n\n호이스팅, 브라우저 렌더링 등과 같이 프론트엔드 기술면접 단골질문까진 아니지만, 부트캠프 수업에서 이터러블에 대해 자세히 다룬적이 없어서 이터러블에 대한 이해가 부족했다. 스터디원분들도 마찬가지가 아닐까 싶어서 공부도 할겸 이터러블로 주제를 선정하게 되었다.\n\n### ⛳ 이번 목표\n\n이터러블과 이터레이션에 대해 알아보자\n\n---\n\n### 1. 이터러블\n\n네이버 영어사전에 iterate를 찾아보면 반복하다라는 의미가 있다.\n\n![image](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2F3a892a75-8c16-4b62-9212-55d3a7bb89f8%2Fimage.png?table=block&id=281d1b41-c4b4-4463-baea-99cb8df016ab&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이터러블 프로토콜을 준수한 객체를 이터러블이라한다. 즉, 이터러블은 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다.\n\n```javascript\n// Symbol.iterator를 프로퍼티 키로 사용한 메서드\n [Symbol.iterator]() {\n// 이터레이터 객체 반환\n}\n```\n\n예를 들어, 배열은 Array.prototype의 Symbol.iterator 메서드를 상속받는 이터러블이다. 이터러블은 for ... of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.\n\n Symbol.iterator 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다. 따라서 일반 객체는 for ... of 문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭쳐링 할당의 대상으로 사용할 수 없다.\n\n```javascript\n const obj = {a: 1, b: 2};\n\n// 일반 객체는 Symbol.iterator 메서드를 구현하거나 상속받지 않는다.\n// 따라서 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.\n console.log(Symbol.iterator in obj); // false\n\n// 이터러블이 아닌 일반 객체는 for ... of 문으로 순회할 수 없다.\n for (const item of obj) { // → TypeError: obj is not iterable\n console.log(item);\n}\n\n// 이터러블이 아닌 일반 객체는 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.\n const [a, b] = obj; // → TypeError: obj is not iterable\n```\n\n🤔 그렇다면 이터러블이 아닌 일반 객체는 스프레드 문법도 사용하지 못하겠다라는 생각이 들 수 있다. 하지만 스프레드 프로퍼티 제안(stage 4)은 일반 객체에 스프레드 문법의 사용을 허용한다고 한다.\n\n```javascript\nconst obj = {a: 1, b: 2};\n\n console.log({...obj})l // {a: 1, b: 2};\n```\n\n그리고 일반 객체도 이터러블 프로토콜을 준수하도록 구현하면 이터러블이 된다고 한다.\n\n### 2. 이터레이터\n\n이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 next 메서드를 소유하며 next 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. 이러한 규약을 이터레이터 프로토콜이라 하며, 이터레이터 프로토콜을 준수한 객체를 이터레이터라 한다.\n\n```javascript\n// 배열은 이터러블 프로토콜을 준수한 이터러블이다.\n const array = [1, 2, 3]; \n\n // Symbol.iterator 메서드는 이터레이터를 반환한다.\n const iterator = array[Symbol.iterator]();\n\n// Symbol.iterator 메서드가 반환한 이터레이터는next 메서드를 갖는다.\n console.log('next' in iterator); // true\n\n// next 메서드를 호출하면 이터러블을 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다.\n// 이터레이터 리절트 객체는 value와 done 프로퍼티를 갖는 객체다.\n console.log(iterator.next());  // { value: 1, done: false }\n console.log(iterator.next());  // { value: 2, done: false }\n console.log(iterator.next());  // { value: 3, done: false }\n console.log(iterator.next());  // { value: undefined, done: true }\n```\n\n### 3. 이터러블과 유사 배열 객체\n\n유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.\n\n유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있고, 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로 가지므로 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.\n\n```javascript\n// 유사 배열 객체\n const arrayLike = {\n0: 1,\n 1: 2,\n 2: 3,\nlength: 3\n};\n\n// 유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있다.\nfor (let i = 0; i < arrayLike.length; i++) {\n  // 유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.\n  console.log(arrayLike[i]); // 1 2 3\n}\n```\n\n🤔 그렇다면 유사 배열 객체는 배열처럼 for ... of 문으로 순회할 수 있을까..?\n\n이에 대한 답은 'NO' 이다. 유사 배열 객체는 이터러블이 아닌 일반 객체다. 따라서 유사 배열 객체에는 Symbol.iterator 메서드가 없기 때문에 for ... of 문으로 순회할 수 없다.\n\n```javascript\n// 유사 배열 객체는 이터러블이 아니기 때문에 for ... of 문으로 순회할 수 없다.\nfor (const item of arrayLike) {\n console.log(item);\n}\n// → TypeError: arrayLike is not iterable\n```\n\n유사 배열 객체이면서 이터러블인 것: arguments, NodeList, HTMLCollection\n\n정확히 말하면 ES6에서 이터러블이 도입되면서 유사 배열 객체인 arguments, NodeList, HTMLCollection 객체에 Symbol.iterator 메서드를 구현하여 이터러블이 되었다. 하지만 이터러블이 된 이후에도 length 프로퍼티를 가지며 인덱스로 접근할 수 있는 것에는 변함이 없으므로 유사 배열 객체이면서 이터러블인 것이다.\n\n→ 모든 유사 배열 객체가 이터러블인 것은 아니다. 유사 배열 객체 중에 이터러블인 것이 있고 아닌 것이 있다.\n\n배열도 마찬가지로 ES6에서 이터러블이 도입되면서 Symbil.iterator 메서드를 구현하여 이터러블이 되었다.\n\n위의 예제에서의 arrayLike 객체는 ES6에서 도입된 Array.from 메서드를 사용하여 배열로 간단히 변환할 수 있다.\n\nArray.from 메서드는 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환하여 반환한다.\n\n```javascript\n// 유사 배열 객체\nconst arraLike = {\n 0: 1,\n 1: 2,\n 2: 3,\n length: 3\n};\n\n// Array.from은 유사 배열 객체 또는 이터러블을 배열로 변환한다.\nconst arr = Array.from(arrayLike);\nconsole.log(arr); // [1, 2, 3]\n```\n\n### 4. 이터레이션 프로토콜의 필요성\n\n💡 그렇다면 왜 이터레이션 프로토콜의 필요한가에 대해 알아보자.\n\nES6 이전의 순회 가능한 데이터 컬렉션(배열, 문자열, 유사 배열 객체, DOM 컬렉션 등)등은 통일한 규약 없이 각자 나름의 구조를 가지고 for 문, for ... in 문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다. ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for ... of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화했다.\n\n이터러블은 for ... of 문, 스프레드 문법, 배열 디스트럭처링 할당과 같은 데이터 소비자에 의해 사용되므로 데이터 공급자의 역할을 한다고 할 수 있다.\n\n만약 다양한 데이터 공급자가 각자의 순회 방식을 갖는다면 데이터 소비자는 다양한 데이터 공급자의 순회 방식을 모두 지원해야 한다. 이는 효율적이지 않다. 하지만 다양한 데이터 공급자가 이터레이션 프로토콜을 준수하도록 규정하면 데이터 소비자는 이터레이션 프로토콜만 지원하도록 구현하면 된다.\n\n즉, 이터러블을 지원하는 데이터 소비자는 내부에서 Symbol.iterator 메서드를 호출해 이터레이터를 생성하고 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 이터레이터 리절트 객체를 반환한다. 그리고 이터레이터 리절트 객체의 value/done 프로퍼티 값을 취득한다.\n\n이처럼 이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 한다.\n\n![image](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2Fa6742119-741e-4d11-bed2-be5624695fdf%2Fimage.png?table=block&id=be23645f-ed39-49ff-aaea-0c029d41be29&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. 이터러블에 대해서 설명해주세요.\n\n # A.\n\n \n이터러블이란 반복이 가능한 객체를 말합니다.\n이터러블은 `Symbol.iterator` 메서드를 가지고 있는데, 이 메서드는 이터레이터를 반환하여, 이터러블 객체의 각 요소를 반복할 수 있도록 해줍니다.\n\n이터레이터는 이터러블 객체에서 값을 순차적으로 가져오는 법을 정의합니다.\n\n이터레이터는`next()`메서드를 호출할 때마다 이터러블 객체에서 다음 값을 가져오고, 가져올 값이 없을 경우 done 프로퍼티가 true인 객체를 반환합니다.\n\n 이터러블과 이터레이터 프로토콜을 사용하여, 다양한 자료구조를 반복할 수 있습니다. \n\n 예를 들어 배열, 문자열, Map, Set, NodeList 등의 객체는 모두 이터러블입니다. 따라서 for ... of 문이나 전개 연산자, 구조 분해 할당 등을 사용하여 이러한 객체를 반복하고 다룰 수 있습니다."
      },
      {
        "id": "10",
        "title": "JavaScript",
        "topic": "props drilling",
        "texture": "## 🎈주제 선정 이유?\n\n프로젝트에 필요한 redux toolkit에 대해 공부하다가, 상태관리가 등장한 배경에 대해서 궁금해져서 조사하게 되었다.\n\n## ⛳ 학습 목표\n\nprops drilling은 무엇이고 어떻게 피할 수 있는지에 대해 학습한다.\n\n## ⛏️ Props Drilling이란\n\n![이미지](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2Fec3d3141-98e0-4288-994c-a4b107e852de%2Fimage.png?table=block&id=c70b3d1b-cfa4-4727-adc8-0e31edd09ed2&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n`Props Drilling` 은 props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정이다.\n\n### 😀 Props Drilling의 장점\n\n- 컴포넌트 간에 데이터를 전달하는 가장 쉽고 빠르게 전달할 수 있다.\n- (작은 규모의 어플리케이션에서) 컴포넌트를 잘게 분할해서 Props drilling을 통해 전달하면, 코드를 실행하지 않고 정적으로 따라가는 것만으로도 어떤 데이터가 어디서 사용되는지 쉽게 파악할 수 있으며, 수정도 용이하다\n\n### 😱 그렇다면 Props Drilling이 문제인 이유는 무엇인가?\n\n어플리케이션의 규모가 커지고, 중간 컴포넌트의 수가 많아지게 되면서 불필요한 props 전달로 인해 유지보수도 어렵고 가독성도 떨어질 수 있다.\n\n- 필요보다 많은 props를 전달하다가, 컴포넌트를 분리하는 과정에서 필요하지 않은 props가 계속 남거나 전달되는 문제\n- props 전달이 누락되었는데 `defaultProps`가 과용되었을 때, props가 전달되지 않은 상황을 인지하기가 어려운 문제\n- 자세한 설명\n\n    (ChatGPT)>> 일반적으로, React에서 defaultProps는 props의 기본값을 정의하는 데 사용된다. 만약 상위 컴포넌트에서 하위 컴포넌트로 props를 전달하지 않았을 때, defaultProps에 정의된 기본값이 하위 컴포넌트에 자동으로 적용된다. 이는 기본적으로 컴포넌트가 동작하는 데는 문제가 없지만, 때로는 예상치 못한 동작이 발생할 수 있다.문제는, defaultProps를 과용하여 하위 컴포넌트에서 필요한 props를 전달하지 않아도 문제가 발생하지 않는다고 착각할 수 있다는 점이다. 실제로는 props가 전달되지 않은 상황에서도 defaultProps에 정의된 기본값이 사용되기 때문에, 버그를 파악하고 수정하는 데 어려움을 겪을 수 있다.따라서, Props Drilling을 사용할 때는 defaultProps를 신중하게 사용해야 합니다. 필요한 props가 명시적으로 전달되도록 하고, defaultProps는 최소한의 기본값 설정에 사용하는 것이 좋다. 이렇게 하면 props 전달이 누락되었을 때 실제로 문제가 발생하며, 이를 빠르게 인지하고 수정할 수 있게 된다.\n\n- props의 이름이 전달 중에 변경되어서 데이터를 추적하기 쉽지 않게되는 문제\n- 자세한 설명(ChatGPT)>> Props Drilling을 사용하면서 props의 이름이 중간 컴포넌트를 거치면서 변경되는 경우를 의미한다. 이는 props의 이름이 상위 컴포넌트에서 하위 컴포넌트로 전달되는 동안 수정되거나 재정의되어 데이터의 추적이 어려워지는 상황을 말한다.예를 들어, 상위 컴포넌트에서 하위 컴포넌트로 value라는 이름의 props를 전달한다고 가정해보자. 하지만 중간 컴포넌트에서 value를 받은 후 다른 이름으로 변경하거나 다른 컴포넌트에 전달할 수 있다. 이 경우 하위 컴포넌트에서는 원래 props 이름이 무엇이었는지 추적하기 어려워지고, 코드를 분석하거나 디버깅하기 어려워진다.이러한 상황에서는 코드의 가독성과 유지보수성이 저하될 수 있다. 특히 프로젝트가 커지고 여러 컴포넌트가 복잡하게 얽혀있을 때, props 이름의 변경이 제대로 추적되지 않으면 버그를 찾기 어려워진다.\n\n    (ChatGPT)>> Props Drilling을 사용하면서 props의 이름이 중간 컴포넌트를 거치면서 변경되는 경우를 의미한다. 이는 props의 이름이 상위 컴포넌트에서 하위 컴포넌트로 전달되는 동안 수정되거나 재정의되어 데이터의 추적이 어려워지는 상황을 말한다.예를 들어, 상위 컴포넌트에서 하위 컴포넌트로 value라는 이름의 props를 전달한다고 가정해보자. 하지만 중간 컴포넌트에서 value를 받은 후 다른 이름으로 변경하거나 다른 컴포넌트에 전달할 수 있다. 이 경우 하위 컴포넌트에서는 원래 props 이름이 무엇이었는지 추적하기 어려워지고, 코드를 분석하거나 디버깅하기 어려워진다.이러한 상황에서는 코드의 가독성과 유지보수성이 저하될 수 있다. 특히 프로젝트가 커지고 여러 컴포넌트가 복잡하게 얽혀있을 때, props 이름의 변경이 제대로 추적되지 않으면 버그를 찾기 어려워진다.\n\n### 🔧 그렇다면 이러한 Props Drilling으로 생기는 문제 피하는 방법은?\n\n1) 렌더링 될 컴포넌트를 불필요하게 여러 컴포넌트로 나누지 않는다.\n\nReact는 (권장되지는 않지만)단 하나의 컴포넌트에 어플리케이션 전체를 작성하더라도 기술적인 제약은 없다. 따라서 성급하게 불필요한 컴포넌트 쪼개기를 할 필요는 없다. 컴포넌트를 재사용해야할 상황을 기다렸다 분할해도 늦지 않으며, 불필요한 prop drilling도 하지 않을 수 있다.\n\n2) defaultProps를 필수 컴포넌트에 사용하지 않는다.\n\ndefaultProps를 사용하면 컴포넌트가 제대로 동작하기 위해 꼭 필요한 props가 전달되지 못한 상황에도 중요한 오류가 가려지게 된다. 따라서 defaultProps를 필수적이지 않은 컴포넌트에만 사용하면 prop drilling으로 인한 문제를 막을 수 있다.\n\n3) 가능한 관련성이 높은 곳에 state를 위치 시킨다.\n\n어떤 데이터가 어플리케이션의 특정 위치에서만 필요하다면 최상위 컴포넌트에 state를 위치시키는 것보다 해당 데이터를 필요로 하는 최소 공통 부모 컴포넌트에서 관리를 하는 것이 가장 효율적이다.\n\n4) 상태관리 도구를 사용한다.\n\n데이터를 필요로 하는 컴포넌트가 정말 깊숙히 위치하고 있다면, React에서 제공하는 Context API를 사용하거나 Redux 등의 외부 상태관리 라이브러리를 사용해서 문제를 해결할 수 있다. 물론 어플리케이션의 모든 곳에서 이와 같은 도구를 사용해야하는 것은 아니지만, 비교적 손쉽게 문제를 해결할 수 있다.\n\n### Context API\n\nReact에 내장되어 컴포넌트 트리 전체에 데이터를 제공할 수 있는 API이다.\n\n장점\n\n- Redux는 무겁고 복잡한 라이브러리이다. 따라서 상태관리가 아닌 단순히 props를 전달할 목적이라면 context API를 사용하는 것이 적절하다.\n\n단점\n\n- Context API에서 상태값이 변경되면, provider로 감싼 모든 자식 컴포넌트가 리렌더링이 된다. 리렌더링은 성능에 영향을 미칠 수 있기 때문에 때문에 자식 컴포넌트의 불필요한 리렌더링을 방지해야한다.\n\n### Redux\n\n오픈 소스 자바스크립트 라이브러리로 state를 사용해 애플리케이션의 전역 상태 관리를 위해 사용한다.\n\n장점\n\n- 단방향 데이터 통신이 발생하기 때문에 데이터 흐름을 예측할 수 있고 디버깅에 유리하다.자세한 설명(ChatGPT)>> Redux는 상태 관리 라이브러리로서, 애플리케이션의 데이터를 중앙 집중적으로 관리하고 상태 변화를 예측 가능한 방식으로 처리한다. 이는 단방향 데이터 흐름을 갖는 아키텍처를 채택하여 데이터의 변화를 추적하고 예측하기 쉽게 만든다.단방향 데이터 흐름은 데이터의 이동 경로가 일정하고 예측 가능하다는 의미이다. Redux에서는 데이터의 흐름이 '액션 → 리듀서 → 상태'의 단방향으로 이루어진다. 액션은 상태 변화에 대한 정보를 담은 객체이며, 리듀서는 액션을 기반으로 상태를 업데이트하는 순수 함수이다. 이러한 단방향 흐름으로 인해 데이터의 변화가 어떤 경로를 따라가는지 예측할 수 있고, 디버깅 시 데이터 변화를 추적하기 용이하다.\n\n단점\n\n- 무겁고 사용하기에 복잡하다.(이를 보완하기 위해 redux toolkit 등의 라이브러리가 등장하였다.)",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. Props drilling은 무엇이고 어떻게 피할 수 있는가?.\n\n # A.\n\n Props Drilling은 props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정입니다.\n\n이는 컴포넌트 간에 데이터를 전달하는 가장 쉽고 빠르게 전달할 수 있다는 장점이 있다. 하지만 어플리케이션의 규모가 커지고, 중간 컴포넌트의 수가 많아지게 되면서 불필요한 props 전달로 인해 유지보수도 어렵고 가독성도 떨어질 수 있다.\n\n이를 피하기 위해 컴포넌트를 리팩토링하고, 컴포넌트를 더 작은 컴포넌트들로 쪼개지 않고, state를 가장 가까운 부모 컨포넌트와만 공유함으로써 props drilling 회피할 수 있습니다. 위계상 멀리/깊게(deep/far)떨어진 컴포넌트와 state를 공유할 때, React의 \n\nContext API 혹은 Redux와 같은 state 관리 라이브러리를 사용할 수 있습니다."
      }
    ]
  },
  {
    "title": "React",
    "items": [
      {
        "id": "5",
        "title": "React",
        "topic": "라이브러리란 무엇인가",
        "texture": "## 1. 주제 선정 이유 \n각종 프로젝트를 준비하는 과정에서 라이브러리의 중요성을 많이 언급되며, 실제 기업에서도 특정 라이브러리를 사용하여 프로젝트를 진행한 경험을 요구하는 경우가 많다고 느꼈을 것이다. 라이브러리가 정확하게 무엇이며 어떤 종류가 있으며, 왜 사용하는지에 대해 자세히 알아보고자 준비함\n\n## 2. 라이브러리란\n\n# 2-1. 라이브러리의 정의\n- 소프트웨어를 개발할 때, 컴퓨터 프로그램이 사용하는 '비휘발성 자원(리소스)'의 집합이다.\n- 사전적 용어인 도서관(library)와 비슷하게, 특정한 코드들(책들)을 모아둔 집합이라 생각하면 된다.\n- 이는 소프트웨어 개발시에 사용되는 프로그램의 구성요소로, 공통으로 사용될 수 있는 특정한 기능들을 모듈(module)화 한 것이다.\n- API와의 차이점 : API는 프로그래밍 언어에서 라이브러리를 사용할 수 있도록 소스코드 수준에서 인터페이스를 노출 시킨 것이지만, 라이브러리는 실제 실행되어 기능을 수행하는 **단편화된 프로그램** 이다.\n- 즉, 라이브러리는 완전한 프로램이 아니라 특정한 기능만을 수행하도록 제작된 프로그램이다.\n\n# 2-2. 라이브러리를 사용하는 이유\n- 모든 기능을 직접 코딩하지 못하며, 시간을 절약하기 위해서이다.동일한 기능을 간단한 코드로 방법화시키는 라이브러리 코드를 본인이 직접짜기엔 너무 많은 시간을 소요되며, 실제로 정해진 기간내에 처리하기도 어렵기 때문이다.\n- 즉, 라이브러리를 사용할수 있으면, 보다 복잡한 코드를 짜는데 **더 빠르고, 더 편리하게** 할 수 있기에, 사용이 권장된다.\n\n# 2-3. 라이브러리의 종류\n- 표준 라이브러리: 특정한 언어의 개발 환경에 기본적으로 포함된 것들로, 언어의 기본 기능을 확장시키는 역할을 담당한다.Python의 표준 라이브러리에는 문자열 처리, 파일 조작, 네트워크 통신 등 다양한 모듈들이 포함되어 있다.참고문헌 : https://docs.python.org/ko/3/library/index.html\n- 웹 개발 라이브러리 : 웹 개발의 편의성을 제공하는 역할을 한다.대표적인 예로 JavaScript의 경우, jQuery, React, Angular 등이 있다.\n- 데이터베이스 라이브러리 : 데이터베이스와 상호 작용하는 역할을 수행한다.\n- 그래픽스 및 시각화 라이브러리 : 데이터 시각화나 그래픽스 작업을 위해 사용하는 라이브러리대표적인 예로 JavaScript의 D3.js가 있다.\n- 상태관리 라이브러리: 애플리케이션의 상태를 보다 효과적으로 관리(상태 업데이트나 추적...)하기 위한 라이브러리대표적인 예로 Redux와 Recoil이 있다.\n\n## 3. 라이브러리와 프레임 워크의 차이점\n- 주도권의 차이라고 설명할 수 있다.\n- 라이브러리의 경우, 개발자가 필요에 따라 선택적으로 사용할 수 있다.\n- 프레임 워크의 경우, 애플리케이션의 개발을 위한 일종의 뼈대 역할을 하기에, 개발자 프레임 워크에 맞춰서 개발을 해야한다.\n\n# 3-1. React는 라이브러리인가 프레임 워크인가?\n- React는 '프레임 워크같은' 라이브러리라 정의할 수 있다.\n- React 개발당시, UI개발을 위한 라이브러리로 개발되었으나, React Router를 통한 라우팅 기능이나, Redux와 같은 다양한 상태관리 라이브러리와의 조합으로 점차 '프레임 워크화'되어간 것이다.\n- 즉, React는 **프레임워크처럼 동작하는 라이브러리**라고 소개하면 된다.",
        "qna": "## 4. 요약 정리 및 면접형 QnA\n\n# Q1. 라이브러리에 대해 설명해주세요\n- 라이브러리는 재사용 가능한 코드의 집합을 의미합니다.\n- 해당 코드에는 특정 기능을 수행하는 함수, 클래스, 모듈 등으로 구성되어 있습니다.\n- 개발자가 필요에 따라 선택적으로 사용할 수 있다는 특징이 있습니다.\n- 프런트엔드 개발자인 저희에게 가장 익숙한 라이브러리에는 웹개발 라이브러리인 React와 상태관리 라이브러리인 Recoil과 Redux가 있습니다.\n\n# Q2. 혹시 Redux와 Recoil의 차이에 대해 설명가능하실까요?\n- Redux와 Recoil은 둘 다 상태 관리를 위한 라이브러리이지만, 사용 범위나 상태 업데이트 방식, 성능면에서 차이를 보입니다.\n- Redux의 경우, JavaScript 기반의 라이브러리(React, Angular, Vue)에서 모두 사용가능합니다. 반면 Recoil의 경우, Meta에서 React만을 위해 개발한 라이브러리여서 오로지 React에서만 작동가능합니다.\n- Redux는 Reducer를 활용한 일방적인 데이터 흐름으로 상태를 업로드 하지만, Recoil은 React의 useState와 유사하게 Atom이라는 상태 단위를 활용하여 상태를 업로드 합니다.\n- Recoil은 Redux보다 간단한 API를 제공하고 성능 최적화면에서도 React의 컴포넌트 라이프사이클과 잘 맞기에 우수합니다.\n\n# Q3. React는 라이브러리일까요, 아니면 프레임워크일까요?\n- React의 개념적으로 라이브러리가 맞습니다. 개발 초창기에 웹개발을 용이하게 하기 위해 개발된 웹개발 라이브러리 였으나, 다양한 상태관리 라이브러리를 함께 사용하고, 라우터를 활용한 라우팅이 가능해져서 컴포넌트간 보다 편리한 매핑이 가능해져 더이상 라이브러리가 아닌 프레임워크로 인식되는 경우가 있습니다.\n- 즉, React는 **프레임워크처럼 동작하는 라이브러리**라고 정의할 수 있습니다."
      },
      {
        "id": "6",
        "title": "React",
        "topic": "React의 상태관리란 무엇인가",
        "texture": "## 1. 주제 선정 이유\n React라이브러리를 사용하다보면 상태관리가 필수이며 그에 따른 각종 기능들을 숙지하고 있어야한다. 이에 대해 알지 못하면 React를 사용하지 않는 수준이며, 협업을 하는데 있어 큰 지장이 되기에 이번 기회에 상태관리에 대한 정확한 정의를 학습하고, React의 상태관리 방법에는 어떤 것들이 있는지 살펴보도록 하자.\n\n## 2. 상태관리란\n\n# 2-1. 상태관리의 정의\n- 상태(State) : 컴퍼넌트 내부에서 관리되며 어플리케이션의 렌더에 영향을 미치는 자바스크립트 객체를 의미. 즉, **변화하는 데이터**라고 이해하면 된다. (ex, 쇼핑몰 사이트에서 구매할 물건의 수량을 늘리고 줄이는 행위를 상태가 변화한다고 한다.)\n- 상태관리 : 상태는 어는 컴퍼넌트에서나 일관되어야 한다. 이를 데이터의 무결성이라 한다. 왜냐하면, 상태가 컴퍼넌트마다 다르다면, 유저나 관리자가 받아들이는 데이터에 차이가 생겨 소통에 차질이 생기기 때문이다.\n따라서 상태를 일관되게 관리해야하며, React의 경우, **신뢰할 수 있는 단일 출처(동일한 데이터는 항상 같은 곳에서 가져온다)**라는 방법론으로 상태를 관리하고 있다.\n\n# 2-2. 상태의 종류\n- 지역상태(localState) : 특정 컴퍼넌트 안에서만 관리되는 상태를 의미한다. 이는 주로 작은 프로젝트처럼 좁은 영역에서만 관리되는 데이터들이다.\n- 컴퍼넌트 간 상태: 다수의 컴퍼넌트에서 사용되고 영향을 주는 데이터들을 의미한다. 대표적인 예시로 여러 컴퍼넌트가 동시에 사용하는 모달창 등이 있다\n2개 이상의 컴퍼넌트간에 상태를 주고 받을 경우, 상위 컴퍼넌트에서 하위 컴퍼넌트로만 상태를 전달하며, 이를 Props Driling이라 한다.\n- 전역 상태(globalState) : 프로젝트 전체에 영향을 끼치는 데이터를 의미한다. 대표적인 예로, 모든 컴퍼넌트에서 사용되는 페이지의 헤더 컴퍼넌트 등이 있다.\n- 상태관리가 필요한 이유: 걱 컴퍼넌트가 부모자식 관계로 되어있지 않은 이상 각 컴퍼넌트간의 직접적인 데이터 전달은 어렵우며, 구조가 복잡하여 Props Driling이 많아지면 Props의 출처를 찾기 어려워기 때문에 이를 관리해줘야 한다.\n\n## 3. React의 상태관리\n\n# 3-1. Context API\n- Context API : React 컴포넌트 트리 안에서 전역 상태를 공유할 수 있도록 만들어진 방법이다.명칭은 API이기는 하지만, 실질적인 관리는 API가 아니라 useState를 통해 이루어진다.\n- useState() :\n`cosnt [state, setState] = useState()`의 형태로 구성되어 있다.\n앞에서서부터 state라는 상태변수와 상태에 변화를 주는 setState라는 함수가 있다. useState()의 파라미터에는 초기 state값이 들어가며, 이후 setState를 통해 state의 값에 변화를 주는 방식으로 상태를 관리한다.\nuseState()는 상태를 새로 추가하거나 삭제하는 것이 아니라 단순 비교를 통해 상태를 업데이트 시키는 원리로 작동한다.\n즉, **동일한 데이터의 key값이면 키의 value값의 차이를 비교하여 최신의 value값으로 갱신하며 상태를 관리한다.**\n이는 중간에 있는 요소들에게 props를 넘기지 않고도 데이터를 가져다 사용할 수 있기에 props Drilling을 피할 수 있으며, 주로 전역적으로 쓰이는 데이터들을 사용할 때 자주 사용된다.\n- context API의 구조 : context, provider, comsumer 로 구성\n context : 전역상태를 저장하는 곳으로 , 내부에는 provider와 consumer로 구성되어있다.\n provider : 전역상태를 제공하는 역할을 한다. 주로 Root Component(index.js / app.js)에서 정의된다.\n consumer 제공받은 전역상태를 받아서 사용하는 역할을 한다.\n\n# 3-2. Redux\n- Redux : 공식 문서에 따르면 자바스크립트 앱을 위한 예측 가능한 상태 컨테이너라고 정의한다.\n 이를 풀어 설명하면, 전역 상태를 관리하는 도구, 즉, 어플리케이션 전체에 대한 중앙 저장소 역할을 한다고 생각하면 된다.\n- 'Store','Action', 'Reducer'로 구성되어 있다.\n Store는 전역상태를 저장하는 저장소 역할을 하며, 오직 Reducer를 통해서만 접근이 가능하다. 주로 index.js에 정의되며 Store는 오직 1개만 존재할 수 있다.\n Action은 Store에 저장된 상태의 변화를 Reducer에 명령하는 자바스크립트 객체이다. 변화를 주기 위해 dispatch라는 메서드를 사용하여 Reducer에게 전달된다.\n Reducer는 변화를 감지하여 상태를 변화시키는 역할을 하는 순수함수로서, 전역 상태를 변경하고 업데이트시킨다. 바닐라 자바스크립트의 '이벤트리스너'와 동일한 역할을 한다고 파악해도 좋다.\n 다만, Redux의 경우, 상태관리를 할 때, 이전상태를 변경시키는 것이 아닌 **새로운 상태의 객체를 생성하여 반환한다**는 점을 명시해야한다.\n *순수함수 : 다른 외부의 상태를 변경하지 않으면서도, 어떤 동일한 인자에 대해 항상 동일한 값을 리턴하는 함수이다.\n\n# 3-3. Recoil 라이브러리\n- 앞서 언급한 Redux는 단방향의 흐름에서 상태관리가 용이하지만, 이를 위한 action, reducer와 같은 초기 세팅이 상당히 번거롭고 React와 잘 맞지 않는다는 여론이 주를 이루었다.\n- React의 상태관리를 보다 React스럽게(hook을 전역으로 확장시킴) 하기 위해, 메타(전 페이스북)사에서 제작한 React 상태관리 라이브러리이다.\n- Recoil은 atom과 selector라는 객체를 사용하여 상태를 관리한다.\n- atom은 구독, 옵저버와 같은 개념을 생각할 필요없이 hook을 사용하듯이 사용하면 된다.\n hook를 사용했던 개발자라면 쉽게 사용할 수 있다.\n- selector를 이용하면 리듀서 없이 복잡한 연산도 간단하게 할 수 있다.",
        "qna": "추가해야함"
      },
      {
        "id": "11",
        "title": "React",
        "topic": "React를 사용하는 이유",
        "texture": "## 🎈주제 선정 이유?\n\n리액트를 활용한 프로젝트를 하면서, 리액트의 장점이 어느정도 느껴졌다. 하지만 누군가 리액트를 왜 사용하나요? 라고 묻는다면 바로 대답하기가 어려울 것 같다는 생각이 들었다. 그래서 이번에 리액트를 왜 사용하는지에 대해 조사하기로 했다.\n\n## ⛳ 학습 목표\n\n리액트는 무엇인지, 그리고 왜 리액트를 사용하는 지에 대해서 학습한다.\n\n## 📖 React를 사용하는 이유\n\n### React란?\n\n![이미지](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2F9d658f0c-d7a8-4599-991b-015b71e5e644%2Fimage.png?table=block&id=e3459bba-2a1e-4eda-84f7-f147b050c18c&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n**라이브러리**: 라이브러리(영어: library)는 주로 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임이다.\n\n사용자 인터페이스: 사람(사용자)과 사물 또는 시스템, 기계, 컴퓨터 프로그램 등 사이에서 의사소통을 할 수 있도록 일시적 또는 영구적인 접근을 목적으로 만들어진 물리적, 가상적 매개체를 뜻한다.\n\n출처: 위키백과\n\n### React의 특징\n\n1. 가상 돔의 사용으로 DOM 업데이트 최적화\n \n 리액트 개발자들의 DOM 업데이트를 위해서 하는 최적화 행위를 가상 돔을 만들어 비교하고 DOM을 추상화하여 필요한 부분만 다시 그리는 방식으로 개발자들이 DOM 업데이트를 오용하는 일을 피했다.\n \n2. 컴포넌트 기반\n \n 컴포넌트 기반인 리액트는 특정 기능을 구현하거나 특정 화면을 구현할 때 그 화면을 구성하는 일에만 집중할 수 있게 해준다. 여러 명의 프론트엔드 개발자가 하나의 페이지를 만든다고 해도 서로 다른 파일을 작업하도록 구성할 수 있기 때문에 효율적인 코드 분리가 가능하다.\n \n3. 생태계 및 수 많은 커뮤니티와 지속적인 개발\n \n 리액트의 생태계는 여러 다른 라이브러리, 프레임워크 커뮤니티보다 활발하다. 단순 View만을 관리하는 리액트가 프레임워크처러 사람들이 사용할 수 있을 정도이다. 페이스북이 만들었고 주도하고 있으며, AiRbnb, Netflix같은 기업들이 리액트를 사용 중에 있다.\n \n4. React Native의 앱 개발 기능\n \n React Native는 모바일 앱을 만들기 위한 프레임워크로 React 기반으로 만들어졌습니다. 그래서 React로 기존에 개발을 하는 웹 개발자라면 React Native를 금방 배울 수 있고 쉽게 모바일 앱을 만들 수 있다.",
        "qna": "## 4. 요약 정리 및 면접형 QnA\n\n# Q. React은 무엇이고, 왜 사용하는가?\n\n # A.\n\n 리액트는 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리입니다.\n\n그리고 리액트는 아래와 같은 이점이 있어 많이 사용되고 있습니다.\n\n1. 컴포넌트 단위로 구성하여 조합, 분해하기가 쉽습니다.\n\n2. 로직과 뷰를 분리하여 구분하기 쉽습니다.(로직은 컴포넌트의 동작과 상태를 처리하고, 뷰는 컴포넌트의 외형과 사용자 인터페이스를 정의합니다. 이렇게 분리된 코드는 이해하기 쉽고 유지보수가 용이합니다.)\n\n3. 가상 DOM을 활용하기 때문에 화면이 자주 바뀌는 경우 렌더링 자원을 아낄 수 있습니다.\n\n4. 상태 관리와 이에 따른 뷰의 변화를 제어하기 쉽습니다.(상태의 변화를 감지하고, 이에 따른 뷰의 업데이트를 자동으로 처리할 수 있는 기능과 패턴을 제공한다.)"
      }
    ]
  },
  {
    "title": "CS",
    "items": [
      {
        "id": "3",
        "title": "CS",
        "topic": "API란 무엇인가",
        "texture": " ## 1. 주제 선정 이유\n\n💡 IT업계에서 API라는 용어를 상당히 많이 사용하는 것을 목격할 수 있다. 물론 이러한 문화에 친화적인 개발자라면 당연히 이해하고 넘어갔을 것이지만, 업계에 처음 진입한 사람에게는 너무나도 낯설은 용어라고 생각한다. 특히, 필자인 내가 그랬다. 그래서 이번 기회에 API에 대한 기초적인 개념을 쉬운 비유에 빗대어 설명하고자 한다.\n\n ## 2. API\n\n## 2-1. API의 개념\n\n- API는 Application Programming Interface의 앞자리를 조합하여 만든 용어이다.\n- Application은 기능이나 응용 프로그램을 의미하며, Interface는 상호작용을 의미한다.\n- 즉, API는 **응용 프로그램을 프로그래밍하기 위해 서로 데이터를 주고 받는 상호작용의 방법**이라고 정의할 수 있다.\n\n## 2-2. API의 기능\n\n- API를 실상의 예로 설명한다면, 식당의 메뉴가 적힌 **메뉴판**이라고 빗대어 표현할 수 있다.\n- 여기서 메뉴는 API가 제공하는 데이터 형식의 정보라고 생각하면 된다.\n- 식당에 들어온 손님은 메뉴판을 보고 주방장에게 메뉴를 요청하고, 주방장은 그 메뉴에 맞는 음식을 손님에게 제공한다.\n- 데이터를 요청하는 클라이언트(프론트엔드)에게 서버(백엔드)가 데이터를 제공해주며, 이러한 상호작용을 가능하게 해주는 것이 API이다.\n\n## 2-3. API의 형태\n\n- 웹에서 사용하는 API를 '웹 API'라고 부르며, 모바일에서 사용하는 API를 '모바일 API'라고 부르며, 프론트엔드 개발자가 주로 접하는 API는 HTTP API이다.\n- HTTP는 HyperText Transfer Protocol의 약자로, 인터넷에서 웹페이지를 전송하기 위해 사용하는 프로토콜(규칙)을 의미한다. HTTP는 클라이언트와 서버 간에 데이터를 주고받는 방식을 정의하고 있으며, 웹 브라우저와 웹 서버 간의 통신에 주로 사용한다 ex).네이버 URL : https://www.naver.com/\n- API는 요청방식, 요청자료내용, 자료요청에 필요한 추가정보 순으로 구성되어있다.\nex). 클라이언트가 서버에 영화정보를 요청하는 HTTP API: GET /movies/123456789\n서버가 갖고있는 영화정보:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  'id': 123456789,\n  'title': 'The Shawshank Redemption',\n  'year': 1994,\n  'director': 'Frank Darabont',\n  'genres': ['Drama', 'Crime'],\n  'rating': 9.3\n}\n\n``` \n\n- GET /movies/123456789 : 요청방식 / 요청자료내용 / 추가정보\n\n## 2-4. REST API\n\n- Representational State Transfer의 약자로, 웹 서비스를 위한 아키텍처 스타일, 일종의 **방법론**이라 이해하면 편하다.\n- REST API는 HTTP 프로토콜을 기반으로 동작하며, 클라이언트와 서버 간의 통신을 위해 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용한다.\n- REST API의 특징:\n1. 자원(Resource) 중심적: 리소스(데이터)를 중심으로 API를 설계한다. 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하다.\n2. 상태를 전달(Stateless): 서버는 클라이언트의 상태를 관리하지 않는다. 요청은 필요한 모든 정보를 포함하고, 서버는 각 요청을 독립적으로 처리한다. 클라이언트의 세션 상태는 서버에 저장되지 않으며, 클라이언트는 필요한 경우 인증 토큰 등을 요청에 포함시켜 식별할 수 있다.\n3. 표준화된 인터페이스: REST API는 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)와 HTTP 상태 코드(200 OK, 404 Not Found 등)를 사용하여 일관된 인터페이스를 제공한다. 이는 개발자가 API를 이해하고 사용하기 쉽도록 도와준다.\n4. 계층 구조(Layered System): RESTful 서비스는 다중 계층으로 구성될 수 있다. 중간 서버, 로드 밸런서, 캐싱 서버 등을 통해 보안, 로드 분산, 성능 향상 등을 달성할 수 있다.\n- 정리하면, **REST API는 HTTP API기반으로 개발자들이 보다 쉽게 서버와 상호작용할 수 있도록 하는 표준화된 방법으로, 단순하고 가독성이 좋다는 장점이 있다.**\n\nREST API에 대한 자세한 설명자료영상 :\n\n [![이미지 텍스트](https://img.youtube.com/embed/lsMQRaeKNDk?si=m76TFUVBL0iQENFr/0.jpg)](https://www.youtube.com/watch?v=lsMQRaeKNDk&si=m76TFUVBL0iQENFr)\n\n## 2-5. API의 종류\n\n- API의 종류에는 크게 3가지가 있다.\n1. public API(open API) : 누구나 사용가능한 공개 API (ex. 기상청 : https://www.data.go.kr/data/15095109/openapi.do#tab_layer_detail_function)\n2. private API : 사내에서만 사용하는 API\n3. partner API : 미리 정해준 사용자끼리 사용하는 API",
        "qna": " ## 3. 요약 정리 및 면접형 QnA\n\n # QnA : API는 무엇인가요?\n\n- API는 Application Programming Interface의 약자로, 응용 프로그램을 프로그래밍하기 위해 클라이언트와 서버가 서로 데이터를 주고 받는 상호작용의 방법입니다.\n\n# QnA : 혹시 REST API가 무엇인지 알고 계신가요?\n\n- REST API는 Representational State Transfer의 약자로, HTTP API기반하여 개발자들이 보다 쉽게 서버와 상호작용할 수 있도록 하는 표준화된 API 스타일입니다. 특히 자원중심적인 스타일이기에, 각 리소스가 고유한 URI를 가져 가독성이 좋으며, 표준화된 HTTP 메서드를 사용하기에 단순하다는 장점이 있기 때문에, 현업에서 거의 REST 방식을 사용합니다."
      },
      {
        "id": "4",
        "title": "CS",
        "topic": "REST API란 무엇인가",
        "texture": "## 1. 주제 선정 이유 \n\n지난 IT용어 정리에서 API에 대한 설명을 했으나, 가장 중요한 REST API에 대한 설명을 간략하게 했다고 생각해서 해당 주제에 대해 자세히 설명하고자 선정했다. 프론트 엔드뿐만 아니라 IT업계에서 가장 많이 사용하는 API 방식이기에 이에 대한 정확한 개념은 반드시 숙지해야 할 것이다.\n\n## 2. API란 무엇인가? === 메뉴판 \n\n- Application Programming Interface의 앞자리를 조합하여 만든 용어로, **응용 프로그램을 프로그래밍하기 위해 서로 데이터를 주고 받는 상호작용의 방법**이라고 정의할 수 있다.\n\n- 데이터를 요청하는 클라이언트(프론트엔드)에게 서버(백엔드)가 데이터를 제공해주며, 이러한 상호작용을 가능하게 해주는 것이 API이다.\n\n## 3. REST API란 무엇인가?\n\n# 3-1. REST API의 개념\n- REpresentational State Transfer의 약자로, 웹 서비스를 위한 아키텍처 스타일이다.\n- 어원적으로 분석하면 '대표적인 상태 전달자'로 API 방식 중 가장 많이 그리고 표준적으로 사용되는 **방법론**이다.\n- 아키텍처는 시스템을 구성하는 구성요소들의 조합과 그들 간의 상호작용 방식을 **설계하는 것**을 의미하며, REST API에서 언급하는 웹 서비스를 위한 아키텍처는 **클라이언트-서버 아키텍처**를 의미한다.\n- 클라이언트-서버 아키텍츠는 클라이언트와 서버가 각자의 역할을 분배하여 시스템을 구성한다. 클라이언트는 사용자 인터페이스나 요청을 처리하고, 서버는 그에 필요한 데이터를 전달 및 처리를 하는 역할을 수행한다.\n- 즉, REST API는 웹 서비스를 위한 클라이언트와 서버의 시스템(아키텍처)적 스타일이라 정리 할 수 있다.\n- **REST API는 HTTP 프로토콜을 기반으로 동작한다.**\n\n# 3-2. REST API를 사용하는 이유\n- 자원(Resource) 중심적: 리소스(데이터)를 중심으로 API를 설계한다. 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하다.\n- 표준화된 인터페이스: REST API는 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)와 HTTP 상태 코드(200 OK, 404 Not Found 등)를 사용하여 일관된 인터페이스를 제공한다. 이는 개발자가 API를 이해하고 사용하기 쉽도록 도와준다.\n\n# 3-3. HTTP는 무엇인가?\n- HyperText Transfer Protocol의 약자로, 인터넷에서 웹페이지를 전송하기 위해 사용하는 프로토콜(규칙)을 의미한다.\n- HTTP는 클라이언트가 데이터를 '요청'하고 서버가 이에 '응답'하여 데이터를 주고받는 형태로 이루어져 있다.\n- REST API는 HTTP 프로토콜을 기반으로 동작하기에, 각종 HTTP 메서드를 활용하여 사용자에게 표준화된 인터페이스를 제공한다.\n\n## 4. HTTP 메서드 정리\n- **GET** : 요청받은 URI의 정보를 검색하여 응답한다. 주로 사용자가 클릭하는 대부분의 버튼들이 GET 메서드를 사용한다고 생각해도 무방하다.\n- **POST** : 요청된 자원을 생성(create)한다. 즉, 서버에 새로운 리소스를 생성하거나, 서버에 데이터를 제출하여 처리하고자 할 때 사용한다. 주로 게시물을 작성하거나, 주문 정보를 생성하거나, 새로운 파일을 업로드 하는 등, **새로운 자원을 생성**할 때 사용한다.\n- **PUT** : 요청된 자원 전체를 수정(update)한다. 기존의 URI에 내용을 수정하는 것이기에 새로운 URI를 생성하는 POST와는 차이를 두어야 한다. 주로 리소스를 업데이트할때 PUT 메서드를 사용한다고 이해하면 된다.\n- **PATCH** : 요청된 자원을 수정(update)한다. 다만, 자원 전체를 수정하는 PUT메서드와는 달리, PATCH메서드의 경우 해당자원의 일부만을 교체한다는 차이점이 있다.\n- **DELETE** : 요청된 자원을 삭제할 것을 요청한다. 하지만 안정성의 문제로 대부분의 서버에서는 비활성화 되어있으며, 주로 PATCH를 통해 수정한다고 한다.\n\n# 4-1. POST와 PUT의 차이는 무엇인가?\n- POST 메서드는 INSERT이며 PUT 메서드는 UPDATE이다.\n- POST메서드의 경우, 멱등하지 않아 동일한 자원을 여러 번 POST하면 서버자원에 변화가 생긴다.\n- PUT메서드의 경우, 생성이 아닌 수정을 하며, 여러번 요청해도 서버 리소스에 변화가 없다.\n\n# 4-2. PUT과 PATCH의 차이는 무엇인가?\n- PUT은 해당 자원의 전체를 교체하지만, PATCH는 일부만 변경한다.\n- PUT은 멱등하지만, PATCH는 멱등하지 못하다.\n\n# 4-3. 멱등(Idempotent)은 무엇인가?\n- 동일한 작업을 여러 번 실행하더라도 결과가 동일하게 유지되는 성질을 의미한다.\n- 즉, 동일한 요청을 여러 번 실행하더라도 처음 요청과 같은 상태와 결과를 얻을 수 있다는 것을 의미한다.\n- 이는 요청의 반복 실행이나 중복 전송이 발생해도 시스템의 상태가 변하지 않는 것을 의미한다.",
        "qna": "## 5. 요약 정리 및 면접형 QnA\n\n# 5-1. Q. REST API가 무엇인가요?\n- REST API는 HTTP 프로토콜을 기반으로 동작하는, 웹 서비스를 위한 클라이언트와 서버의 시스템(아키텍처)적 스타일입니다.\n- REST API가 각광받는 이유는 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하고, 일관된 HTTP 프로토콜을 따르기에 개발자로 하여금 친숙하고 편리하기에 자주 사용됩니다.\n\n# 5-2. Q. POST와 PUT의 차이는 무엇인가?\n- POST 메서드는 INSERT이며 PUT 메서드는 UPDATE이다.\n- POST메서드의 경우, 멱등하지 않아 동일한 자원을 여러번 POST하면 서버자원에 변화가 생긴다.\n- PUT메서드의 경우, 멱등하여 동일한 자원을 여러번 PUT하면 서버자원이 변화하지 않고 동일한 리소스로 응답한다.\n- 즉, POST메서드는 새로운 자원을 생성하기에 여러번 요청하면 서버 리소스에 변화가 생기지만, PUT의 경우, 생성이 아닌 수정을 하며, 여러번 요청해도 서버 리소스에 변화가 없다.\n\n# 5-3. Q. PUT과 PATCH의 차이는 무엇인가?\n- PUT은 해당 자원의 전체를 교체하지만, PATCH는 일부만 변경한다.\n- PUT은 멱등하지만, PATCH는 멱등하지 못하다.\n\n# 5-4. Q. 멱등(Idempotent)은 무엇인가?\n- 동일한 작업을 여러 번 실행하더라도 결과가 동일하게 유지되는 성질을 의미한다.\n- 즉, 동일한 요청을 여러 번 실행하더라도 처음 요청과 같은 상태와 결과를 얻을 수 있다는 것을 의미한다.\n- 이는 요청의 반복 실행이나 중복 전송이 발생해도 시스템의 상태가 변하지 않는 것을 의미한다."
      }
    ]
  }
]
