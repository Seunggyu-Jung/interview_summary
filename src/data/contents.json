[
  {
    "title": "목차",
    "items": [
      {
        "id": "1",
        "title": "JavaScript",
        "topic": "객체",
        "texture": "# 1. 주제 선정 이유:\n\n자바스크립트가 객체 지향 언어라는 것은 다들 알고 있을 것이다. 그럼 여기서 말하는 객체란 과연 무엇인가?\n우리가 알고 있는 객체는 키와 값으로 이루어진 중괄호 라고 알고있는데, 이에 대해 자세히 파악하여 **수업을 하거나 협업을 할 때, 보다 더 원활하게 소통할 수 있도록 돕고자** 조사해봤다.\n\n# Ⅱ. 객체\n\n## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```\n\n### 4). 추상화\n\n- 객체의 핵심적인 특징을 강조하고, 불필요한 부분을 생략하는 것\n- 객체를 단순화시키고, 객체가 내부적으로 어떻게 구현되었는지 숨기기 때문에 코드의 가독성과 안정성이 향상\n\n## 3-2). 객체 지향 프로그래밍 언어의 장점\n\n### 1). 재사용성\n\n- 객체간에 계층이 부여되면 상속을 할 수 있고, 그 과정에서 공통된 코드는 다시 작성할 필요가 없어 **구동 시간이나 로딩 시간이 상당히 절약됨**\n\n### 2). 가독성\n\n- 객체지향 프로그래밍에서는 객체의 속성과 메서드를 **명확하게 정의**하고, 객체 간의 상호작용을 **명확하게 표현 가능**\n- 이를 통해 코드의 가독성이 높아지며, 코드의 이해 및 유지보수가 용이해짐\n\n### 3). 유지보수성\n\n- 객체지향 프로그래밍에서는 코드를 **객체 단위로 모듈화**하여 작성하기 때문에, **수정이나 추가를 할 때 해당 객체만 수정**하면 되기에 관리에 용이\n\n※ 모듈화 : 코드를 하나의 파일에 작성하는 것이 아니라, **나누어** 마치 조립하듯이 구조화시키는 것을 의미\n\n- 자바스크립트의 경우, ES6(ES2015)의 모듈 방식을 주로 사용하는데, 이는 import와 export를 사용하는 방식이며, 이를 위해 **Babel**과 같은 도구를 사용하여 코드를 컴파일해야 함\n\n```jsx\n// myModule.js // 보내는 모듈\nexport const foo = function() {\n  console.log('Hello, World!');\n};\nexport const bar = function() {\n  console.log('Bye, World!');\n};\n\n// app.js  // 받는 모듈\nimport { foo, bar } from './myModule';\nfoo(); // 'Hello, World!' 출력\nbar(); // 'Bye, World!' 출력\n\n```\n\n# **번외)**. 함께 알아두면 좋은 용어\n\n### 1. Babel\n\n- 자바스크립트 코드를 컴파일러로 변환해주는 오픈소스 도구\n- 주로 최신 버전의 자바스크립트 코드를 예전 버전으로 변환하여, 구형 브라우저에서도 실행 가능한 코드로 변환하는데 사용\n\n### 2. 컴파일러(Compiler)\n\n- 프로그래밍 언어로 작성된 소스 코드를 기계어로 변환해주는 소프트웨어\n- 자바스크립트의 경우, 인터프리터 언어라서 별도의 컴파일러가 필요\n\n### 3. 인터프리터 언어\n\n- 프로그램의 소스 코드를 직접 실행하는 언어로, 컴파일러와는 달리 컴파일 과정 없이 소스 코드를 바로 실행\n- 대표적인 인터프리터 언어 : JavaScript, Ruby, PHP...\n- 코드를 한 줄 한 줄씩 읽어 들이며 실행하기에 명령 자체의 속도는 컴파일러 언어에 비해 느리다는 단점이 있음\n- 오류 발견 즉시 해결할 수 있다는 장점이 있음",
        "qna": "아직 없음"
      },
      {
        "id": "2",
        "title": "JavaScript",
        "topic": "상속",
        "texture": "# 1. 주제 선정 이유\n\n코딩을 하다보면, 종종 상속이라는 용어를 많이 들어봤을 것이다. 물론, 상속의 사전적인 개념인 '하위존재가 상위존재로부터 무언가를 물림받는다.' 는 것 정도는 유추할 수 있을 것이다. 하지만, 코딩이나 IT업계에서 언급하는 상속에 대해 제대로 알고 넘어가는 것이 실제로 프로젝트에 적용할 때, 보다 수월하고 익숙하게 사용할 수 있을 것이기에 선정했다.\n\n# 2. 상속\n\n## 2-1. 상속의 정의 및 종류\n\n- 자바스크립트에서 사용되는 상속은 프로토타입 상속과 클래스 상속 크게 두 가지로 나뉜다. \n- 프로토타입 상속 : 상속을 받든 객체가 상속을 해주는 객체의 프로퍼티나 메서드를 추가로 사용할 수 있게 해주는 체계를 의미한다. \n- 클래스 상속 : 기존의 클래스를 확장시키는 개념으로 이해하면 좋다. 상속받은 기존의 클래스를 토대로 새로운 기능을 추가하는 시스템을 의미한다.\n\n## 2-2. 프로토타입과 상속의 관계\n\n- 프로토타입 (객체) : 다른 객체에 대한 참조 하는 대상을 의미한다. 모든 객체는 [[prototype]]이라는 내부 프로퍼티를 갖는다. [[prototype]]를 저장창고라고 이해면 좋다.\n\n - 예를 들어, 아래의 경우, 전부 객체로 이루어져있기에 객체의 프로토타입은, [[prototype]] : Object 즉, Object.prototype이다. 그리고 상속받는 객체들이 [[prototype]]안으로 들어간다. \n- `__proto__` : 객체가 자신의 프로토타입에 접근하도록 해주는 접근자 프로퍼티이다. 일종의 **다리(bridge)**라고 이해하면 좋을 듯하다. 해당 프로퍼티를 사용하여 상속받을 객체가 자신의 프로토타입에 들어갈 수 있도록 연결해준다. \n - 즉, `__proto__` 를 사용하여 상위(부모) 객체가 하위(자식) 객체의 프로토타입에 추가되는 과정을 상속이라고 한다.\n\n![사진](https://velog.velcdn.com/images/dainel-q/post/0ba7368c-6a60-4f68-8da4-be69a0422c37/image.png) \n\n## Q. 그런데 왜 프로토타입 상속을 하는 것인가요??\n\n -우선은 한 사례를 통해 살펴보자\n\n![사진](https://velog.velcdn.com/images/dainel-q/post/7f14b541-0997-4b62-b31f-86a9e4328d7c/image.png)\n - 위 예시의 경우, food를 상속받은 pasta 객체가 cook이라는 메서드를 자유롭게 사용할 수 있는 사례이다. 즉, pasta 객체에서 cook메서드를 더 만들지 않고 상속받아 편하게 사용할 수 있다는 것을 의미한다. 이는 곧, 코드의 재사용성을 높이고 , 관리를 용이하게 해준다는 장점을 갖고 있다.\n\n## 2-3. 클래스와 상속의 관계\n\n- 클래스(class) : 하나의 생성자 함수를 여러개 찍어낼 수 있게 해주는 문법으로 흔히 붕어빵 틀에 비유한다. - 먼저 상속을 할 부모 클래스를 생성한다.\n\nclass Food {\n constructor (name) {\n this.name = name;\n this.won = 0;\n }\n\n price(won) {\n this.won = won;\n console.log(${this.name}의 가격은 ${this.won}원 입니다.)\n }\n\n pay(){\n console.log(${this.won}원을 지불하셨습니다.)\n }\n}\n\nconst food = new Food('음식');\n\nclass Pasta extends Food {\n tasty(){\n console.log(${this.name} 맛있네요!)\n }\n}\n\nconst pasta = new Pasta('아라비따 파스타');\n\n- 위 예시를 합치면\nclass Food {\n constructor (name) {\n this.name = name;\n this.won = 0;\n }\n\n price(won) {\n this.won = won;\n console.log(${this.name}의 가격은 ${this.won}원 입니다.)\n }\n\n pay(){\n console.log(${this.won}원을 지불하셨습니다.)\n }\n}\n\nconst food = new Food('음식');\n\nclass Pasta extends Food {\n tasty(){\n console.log(${this.name} 맛있네요!)\n }\n}\n\nconst pasta = new Pasta('아라비따 파스타');\n\n- pasta클래스는 food 클래스를 상속받고 있다는 것을 의미한다. 그렇기에 food클래스의 메서드를 사용할 수 있다.\npasta.price(12000; // 아라비따 파스타의 가격은 12000원 입니다.\npasta.pay(12000); // 12000원을 지불하셨습니다.\npasta.tasty(); // 아라비따 파스타 맛있네요!\n\n## Q. 그런데 왜 클래스 상속을 하는 것인가요??\n\n- 프로토타입의 상속을 하는 이유와 유사하게, 상속을 주고 받기에, 작성해야할 코드의 양이 줄어든다. 특히, 클래스의 경우, 생성자 메서드등 작성해야할 내용이 많기에, 상속의 장점이 더욱 부각된다. - 코드의 재사용성을 높이고 , 관리를 용이하게 해준다는 장점이 있기 때문에 사용한다.",
        "qna": "# 3. 요약 정리 및 면접형 QnA\n\nQnA: 자바스크립트에서 사용하는 상속은 무엇이고, 그 기능이 무엇인가요?\n\n상속은 상속받는 자식요소가 상속해주는 부모요소의 프로퍼티나 메서드를 **추가로** 사용할 수 있도록 **확장**해주는 기능입니다. 자바스크립트의 경우, **프로토타입 상속**과 **클래스 상속** 두 가지 유형의 상속이 있습니다.\n\n- 프로토타입의 상속은, 객체 안의 `[[prototype]]`라는 내부 프로퍼티 안에 `__proto__`라는 접근자 프로퍼티로 객체들을 상속받아 저장하여 사용합니다.\n- 클래스 상속은, 부모 클래스를 `extends`라는 키워드를 사용하여 자식 클래스가 상속받아 사용합니다.\n\n상속을 사용하는 이유는 코드의 재사용성을 높이고, 유지보수가 필요한 경우 특정 부분만 수정해도 되기에 관리를 용이하게 만든다는 장점이 있습니다."
      },
      {
        "id": "3",
        "title": "CS",
        "topic": "API란 무엇인가",
        "texture": " ## 1. 주제 선정 이유\n\n💡 IT업계에서 API라는 용어를 상당히 많이 사용하는 것을 목격할 수 있다. 물론 이러한 문화에 친화적인 개발자라면 당연히 이해하고 넘어갔을 것이지만, 업계에 처음 진입한 사람에게는 너무나도 낯설은 용어라고 생각한다. 특히, 필자인 내가 그랬다. 그래서 이번 기회에 API에 대한 기초적인 개념을 쉬운 비유에 빗대어 설명하고자 한다.\n\n ## 2. API\n\n## 2-1. API의 개념\n\n- API는 Application Programming Interface의 앞자리를 조합하여 만든 용어이다.\n- Application은 기능이나 응용 프로그램을 의미하며, Interface는 상호작용을 의미한다.\n- 즉, API는 **응용 프로그램을 프로그래밍하기 위해 서로 데이터를 주고 받는 상호작용의 방법**이라고 정의할 수 있다.\n\n## 2-2. API의 기능\n\n- API를 실상의 예로 설명한다면, 식당의 메뉴가 적힌 **메뉴판**이라고 빗대어 표현할 수 있다.\n- 여기서 메뉴는 API가 제공하는 데이터 형식의 정보라고 생각하면 된다.\n- 식당에 들어온 손님은 메뉴판을 보고 주방장에게 메뉴를 요청하고, 주방장은 그 메뉴에 맞는 음식을 손님에게 제공한다.\n- 데이터를 요청하는 클라이언트(프론트엔드)에게 서버(백엔드)가 데이터를 제공해주며, 이러한 상호작용을 가능하게 해주는 것이 API이다.\n\n## 2-3. API의 형태\n\n- 웹에서 사용하는 API를 '웹 API'라고 부르며, 모바일에서 사용하는 API를 '모바일 API'라고 부르며, 프론트엔드 개발자가 주로 접하는 API는 HTTP API이다.\n- HTTP는 HyperText Transfer Protocol의 약자로, 인터넷에서 웹페이지를 전송하기 위해 사용하는 프로토콜(규칙)을 의미한다. HTTP는 클라이언트와 서버 간에 데이터를 주고받는 방식을 정의하고 있으며, 웹 브라우저와 웹 서버 간의 통신에 주로 사용한다 ex).네이버 URL : https://www.naver.com/\n- API는 요청방식, 요청자료내용, 자료요청에 필요한 추가정보 순으로 구성되어있다.\nex). 클라이언트가 서버에 영화정보를 요청하는 HTTP API: GET /movies/123456789\n서버가 갖고있는 영화정보:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  'id': 123456789,\n  'title': 'The Shawshank Redemption',\n  'year': 1994,\n  'director': 'Frank Darabont',\n  'genres': ['Drama', 'Crime'],\n  'rating': 9.3\n}\n\n``` \n\n- GET /movies/123456789 : 요청방식 / 요청자료내용 / 추가정보\n\n## 2-4. REST API\n\n- Representational State Transfer의 약자로, 웹 서비스를 위한 아키텍처 스타일, 일종의 **방법론**이라 이해하면 편하다.\n- REST API는 HTTP 프로토콜을 기반으로 동작하며, 클라이언트와 서버 간의 통신을 위해 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용한다.\n- REST API의 특징:\n1. 자원(Resource) 중심적: 리소스(데이터)를 중심으로 API를 설계한다. 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하다.\n2. 상태를 전달(Stateless): 서버는 클라이언트의 상태를 관리하지 않는다. 요청은 필요한 모든 정보를 포함하고, 서버는 각 요청을 독립적으로 처리한다. 클라이언트의 세션 상태는 서버에 저장되지 않으며, 클라이언트는 필요한 경우 인증 토큰 등을 요청에 포함시켜 식별할 수 있다.\n3. 표준화된 인터페이스: REST API는 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)와 HTTP 상태 코드(200 OK, 404 Not Found 등)를 사용하여 일관된 인터페이스를 제공한다. 이는 개발자가 API를 이해하고 사용하기 쉽도록 도와준다.\n4. 계층 구조(Layered System): RESTful 서비스는 다중 계층으로 구성될 수 있다. 중간 서버, 로드 밸런서, 캐싱 서버 등을 통해 보안, 로드 분산, 성능 향상 등을 달성할 수 있다.\n- 정리하면, **REST API는 HTTP API기반으로 개발자들이 보다 쉽게 서버와 상호작용할 수 있도록 하는 표준화된 방법으로, 단순하고 가독성이 좋다는 장점이 있다.**\n\nREST API에 대한 자세한 설명자료영상 :\n\n [![이미지 텍스트](https://img.youtube.com/vi/lsMQRaeKNDk/0.jpg)](https://www.youtube.com/watch?v=lsMQRaeKNDk) \n\n## 2-5. API의 종류\n\n- API의 종류에는 크게 3가지가 있다.\n1. public API(open API) : 누구나 사용가능한 공개 API (ex. 기상청 : https://www.data.go.kr/data/15095109/openapi.do#tab_layer_detail_function)\n2. private API : 사내에서만 사용하는 API\n3. partner API : 미리 정해준 사용자끼리 사용하는 API",
        "qna": " ## 3. 요약 정리 및 면접형 QnA\n\n # QnA : API는 무엇인가요?\n\n- API는 Application Programming Interface의 약자로, 응용 프로그램을 프로그래밍하기 위해 클라이언트와 서버가 서로 데이터를 주고 받는 상호작용의 방법입니다.\n\n# QnA : 혹시 REST API가 무엇인지 알고 계신가요?\n\n- REST API는 Representational State Transfer의 약자로, HTTP API기반하여 개발자들이 보다 쉽게 서버와 상호작용할 수 있도록 하는 표준화된 API 스타일입니다. 특히 자원중심적인 스타일이기에, 각 리소스가 고유한 URI를 가져 가독성이 좋으며, 표준화된 HTTP 메서드를 사용하기에 단순하다는 장점이 있기 때문에, 현업에서 거의 REST 방식을 사용합니다."
      },
      {
        "id": "4",
        "title": "CS",
        "topic": "REST API란 무엇인가",
        "texture": "## 1. 주제 선정 이유 \n\n지난 IT용어 정리에서 API에 대한 설명을 했으나, 가장 중요한 REST API에 대한 설명을 간략하게 했다고 생각해서 해당 주제에 대해 자세히 설명하고자 선정했다. 프론트 엔드뿐만 아니라 IT업계에서 가장 많이 사용하는 API 방식이기에 이에 대한 정확한 개념은 반드시 숙지해야 할 것이다.\n\n## 2. API란 무엇인가? === 메뉴판 \n\n- Application Programming Interface의 앞자리를 조합하여 만든 용어로, **응용 프로그램을 프로그래밍하기 위해 서로 데이터를 주고 받는 상호작용의 방법**이라고 정의할 수 있다.\n\n- 데이터를 요청하는 클라이언트(프론트엔드)에게 서버(백엔드)가 데이터를 제공해주며, 이러한 상호작용을 가능하게 해주는 것이 API이다.\n\n## 3. REST API란 무엇인가?\n\n# 3-1. REST API의 개념\n- REpresentational State Transfer의 약자로, 웹 서비스를 위한 아키텍처 스타일이다.\n- 어원적으로 분석하면 '대표적인 상태 전달자'로 API 방식 중 가장 많이 그리고 표준적으로 사용되는 **방법론**이다.\n- 아키텍처는 시스템을 구성하는 구성요소들의 조합과 그들 간의 상호작용 방식을 **설계하는 것**을 의미하며, REST API에서 언급하는 웹 서비스를 위한 아키텍처는 **클라이언트-서버 아키텍처**를 의미한다.\n- 클라이언트-서버 아키텍츠는 클라이언트와 서버가 각자의 역할을 분배하여 시스템을 구성한다. 클라이언트는 사용자 인터페이스나 요청을 처리하고, 서버는 그에 필요한 데이터를 전달 및 처리를 하는 역할을 수행한다.\n- 즉, REST API는 웹 서비스를 위한 클라이언트와 서버의 시스템(아키텍처)적 스타일이라 정리 할 수 있다.\n- **REST API는 HTTP 프로토콜을 기반으로 동작한다.**\n\n# 3-2. REST API를 사용하는 이유\n- 자원(Resource) 중심적: 리소스(데이터)를 중심으로 API를 설계한다. 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하다.\n- 표준화된 인터페이스: REST API는 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)와 HTTP 상태 코드(200 OK, 404 Not Found 등)를 사용하여 일관된 인터페이스를 제공한다. 이는 개발자가 API를 이해하고 사용하기 쉽도록 도와준다.\n\n# 3-3. HTTP는 무엇인가?\n- HyperText Transfer Protocol의 약자로, 인터넷에서 웹페이지를 전송하기 위해 사용하는 프로토콜(규칙)을 의미한다.\n- HTTP는 클라이언트가 데이터를 '요청'하고 서버가 이에 '응답'하여 데이터를 주고받는 형태로 이루어져 있다.\n- REST API는 HTTP 프로토콜을 기반으로 동작하기에, 각종 HTTP 메서드를 활용하여 사용자에게 표준화된 인터페이스를 제공한다.\n\n## 4. HTTP 메서드 정리\n- **GET** : 요청받은 URI의 정보를 검색하여 응답한다. 주로 사용자가 클릭하는 대부분의 버튼들이 GET 메서드를 사용한다고 생각해도 무방하다.\n- **POST** : 요청된 자원을 생성(create)한다. 즉, 서버에 새로운 리소스를 생성하거나, 서버에 데이터를 제출하여 처리하고자 할 때 사용한다. 주로 게시물을 작성하거나, 주문 정보를 생성하거나, 새로운 파일을 업로드 하는 등, **새로운 자원을 생성**할 때 사용한다.\n- **PUT** : 요청된 자원 전체를 수정(update)한다. 기존의 URI에 내용을 수정하는 것이기에 새로운 URI를 생성하는 POST와는 차이를 두어야 한다. 주로 리소스를 업데이트할때 PUT 메서드를 사용한다고 이해하면 된다.\n- **PATCH** : 요청된 자원을 수정(update)한다. 다만, 자원 전체를 수정하는 PUT메서드와는 달리, PATCH메서드의 경우 해당자원의 일부만을 교체한다는 차이점이 있다.\n- **DELETE** : 요청된 자원을 삭제할 것을 요청한다. 하지만 안정성의 문제로 대부분의 서버에서는 비활성화 되어있으며, 주로 PATCH를 통해 수정한다고 한다.\n\n# 4-1. POST와 PUT의 차이는 무엇인가?\n- POST 메서드는 INSERT이며 PUT 메서드는 UPDATE이다.\n- POST메서드의 경우, 멱등하지 않아 동일한 자원을 여러 번 POST하면 서버자원에 변화가 생긴다.\n- PUT메서드의 경우, 생성이 아닌 수정을 하며, 여러번 요청해도 서버 리소스에 변화가 없다.\n\n# 4-2. PUT과 PATCH의 차이는 무엇인가?\n- PUT은 해당 자원의 전체를 교체하지만, PATCH는 일부만 변경한다.\n- PUT은 멱등하지만, PATCH는 멱등하지 못하다.\n\n# 4-3. 멱등(Idempotent)은 무엇인가?\n- 동일한 작업을 여러 번 실행하더라도 결과가 동일하게 유지되는 성질을 의미한다.\n- 즉, 동일한 요청을 여러 번 실행하더라도 처음 요청과 같은 상태와 결과를 얻을 수 있다는 것을 의미한다.\n- 이는 요청의 반복 실행이나 중복 전송이 발생해도 시스템의 상태가 변하지 않는 것을 의미한다.",
        "qna": "## 5. 요약 정리 및 면접형 QnA\n\n# 5-1. Q. REST API가 무엇인가요?\n- REST API는 HTTP 프로토콜을 기반으로 동작하는, 웹 서비스를 위한 클라이언트와 서버의 시스템(아키텍처)적 스타일입니다.\n- REST API가 각광받는 이유는 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하고, 일관된 HTTP 프로토콜을 따르기에 개발자로 하여금 친숙하고 편리하기에 자주 사용됩니다.\n\n# 5-2. Q. POST와 PUT의 차이는 무엇인가?\n- POST 메서드는 INSERT이며 PUT 메서드는 UPDATE이다.\n- POST메서드의 경우, 멱등하지 않아 동일한 자원을 여러번 POST하면 서버자원에 변화가 생긴다.\n- PUT메서드의 경우, 멱등하여 동일한 자원을 여러번 PUT하면 서버자원이 변화하지 않고 동일한 리소스로 응답한다.\n- 즉, POST메서드는 새로운 자원을 생성하기에 여러번 요청하면 서버 리소스에 변화가 생기지만, PUT의 경우, 생성이 아닌 수정을 하며, 여러번 요청해도 서버 리소스에 변화가 없다.\n\n# 5-3. Q. PUT과 PATCH의 차이는 무엇인가?\n- PUT은 해당 자원의 전체를 교체하지만, PATCH는 일부만 변경한다.\n- PUT은 멱등하지만, PATCH는 멱등하지 못하다.\n\n# 5-4. Q. 멱등(Idempotent)은 무엇인가?\n- 동일한 작업을 여러 번 실행하더라도 결과가 동일하게 유지되는 성질을 의미한다.\n- 즉, 동일한 요청을 여러 번 실행하더라도 처음 요청과 같은 상태와 결과를 얻을 수 있다는 것을 의미한다.\n- 이는 요청의 반복 실행이나 중복 전송이 발생해도 시스템의 상태가 변하지 않는 것을 의미한다."
      },
      {
        "id": "5",
        "title": "React",
        "topic": "라이브러리란 무엇인가",
        "texture": "## 1. 주제 선정 이유 \n각종 프로젝트를 준비하는 과정에서 라이브러리의 중요성을 많이 언급되며, 실제 기업에서도 특정 라이브러리를 사용하여 프로젝트를 진행한 경험을 요구하는 경우가 많다고 느꼈을 것이다. 라이브러리가 정확하게 무엇이며 어떤 종류가 있으며, 왜 사용하는지에 대해 자세히 알아보고자 준비함\n\n## 2. 라이브러리란\n\n# 2-1. 라이브러리의 정의\n- 소프트웨어를 개발할 때, 컴퓨터 프로그램이 사용하는 '비휘발성 자원(리소스)'의 집합이다.\n- 사전적 용어인 도서관(library)와 비슷하게, 특정한 코드들(책들)을 모아둔 집합이라 생각하면 된다.\n- 이는 소프트웨어 개발시에 사용되는 프로그램의 구성요소로, 공통으로 사용될 수 있는 특정한 기능들을 모듈(module)화 한 것이다.\n- API와의 차이점 : API는 프로그래밍 언어에서 라이브러리를 사용할 수 있도록 소스코드 수준에서 인터페이스를 노출 시킨 것이지만, 라이브러리는 실제 실행되어 기능을 수행하는 **단편화된 프로그램** 이다.\n- 즉, 라이브러리는 완전한 프로램이 아니라 특정한 기능만을 수행하도록 제작된 프로그램이다.\n\n# 2-2. 라이브러리를 사용하는 이유\n- 모든 기능을 직접 코딩하지 못하며, 시간을 절약하기 위해서이다.동일한 기능을 간단한 코드로 방법화시키는 라이브러리 코드를 본인이 직접짜기엔 너무 많은 시간을 소요되며, 실제로 정해진 기간내에 처리하기도 어렵기 때문이다.\n- 즉, 라이브러리를 사용할수 있으면, 보다 복잡한 코드를 짜는데 **더 빠르고, 더 편리하게** 할 수 있기에, 사용이 권장된다.\n\n# 2-3. 라이브러리의 종류\n- 표준 라이브러리: 특정한 언어의 개발 환경에 기본적으로 포함된 것들로, 언어의 기본 기능을 확장시키는 역할을 담당한다.Python의 표준 라이브러리에는 문자열 처리, 파일 조작, 네트워크 통신 등 다양한 모듈들이 포함되어 있다.참고문헌 : https://docs.python.org/ko/3/library/index.html\n- 웹 개발 라이브러리 : 웹 개발의 편의성을 제공하는 역할을 한다.대표적인 예로 JavaScript의 경우, jQuery, React, Angular 등이 있다.\n- 데이터베이스 라이브러리 : 데이터베이스와 상호 작용하는 역할을 수행한다.\n- 그래픽스 및 시각화 라이브러리 : 데이터 시각화나 그래픽스 작업을 위해 사용하는 라이브러리대표적인 예로 JavaScript의 D3.js가 있다.\n- 상태관리 라이브러리: 애플리케이션의 상태를 보다 효과적으로 관리(상태 업데이트나 추적...)하기 위한 라이브러리대표적인 예로 Redux와 Recoil이 있다.\n\n## 3. 라이브러리와 프레임 워크의 차이점\n- 주도권의 차이라고 설명할 수 있다.\n- 라이브러리의 경우, 개발자가 필요에 따라 선택적으로 사용할 수 있다.\n- 프레임 워크의 경우, 애플리케이션의 개발을 위한 일종의 뼈대 역할을 하기에, 개발자 프레임 워크에 맞춰서 개발을 해야한다.\n\n# 3-1. React는 라이브러리인가 프레임 워크인가?\n- React는 '프레임 워크같은' 라이브러리라 정의할 수 있다.\n- React 개발당시, UI개발을 위한 라이브러리로 개발되었으나, React Router를 통한 라우팅 기능이나, Redux와 같은 다양한 상태관리 라이브러리와의 조합으로 점차 '프레임 워크화'되어간 것이다.\n- 즉, React는 **프레임워크처럼 동작하는 라이브러리**라고 소개하면 된다.",
        "qna": "## 4. 요약 정리 및 면접형 QnA\n\n# Q1. 라이브러리에 대해 설명해주세요\n- 라이브러리는 재사용 가능한 코드의 집합을 의미합니다.\n- 해당 코드에는 특정 기능을 수행하는 함수, 클래스, 모듈 등으로 구성되어 있습니다.\n- 개발자가 필요에 따라 선택적으로 사용할 수 있다는 특징이 있습니다.\n- 프런트엔드 개발자인 저희에게 가장 익숙한 라이브러리에는 웹개발 라이브러리인 React와 상태관리 라이브러리인 Recoil과 Redux가 있습니다.\n\n# Q2. 혹시 Redux와 Recoil의 차이에 대해 설명가능하실까요?\n- Redux와 Recoil은 둘 다 상태 관리를 위한 라이브러리이지만, 사용 범위나 상태 업데이트 방식, 성능면에서 차이를 보입니다.\n- Redux의 경우, JavaScript 기반의 라이브러리(React, Angular, Vue)에서 모두 사용가능합니다. 반면 Recoil의 경우, Meta에서 React만을 위해 개발한 라이브러리여서 오로지 React에서만 작동가능합니다.\n- Redux는 Reducer를 활용한 일방적인 데이터 흐름으로 상태를 업로드 하지만, Recoil은 React의 useState와 유사하게 Atom이라는 상태 단위를 활용하여 상태를 업로드 합니다.\n- Recoil은 Redux보다 간단한 API를 제공하고 성능 최적화면에서도 React의 컴포넌트 라이프사이클과 잘 맞기에 우수합니다.\n\n# Q3. React는 라이브러리일까요, 아니면 프레임워크일까요?\n- React의 개념적으로 라이브러리가 맞습니다. 개발 초창기에 웹개발을 용이하게 하기 위해 개발된 웹개발 라이브러리 였으나, 다양한 상태관리 라이브러리를 함께 사용하고, 라우터를 활용한 라우팅이 가능해져서 컴포넌트간 보다 편리한 매핑이 가능해져 더이상 라이브러리가 아닌 프레임워크로 인식되는 경우가 있습니다.\n- 즉, React는 **프레임워크처럼 동작하는 라이브러리**라고 정의할 수 있습니다."
      },
      {
        "id": "6",
        "title": "React",
        "topic": "React의 상태관리란 무엇인가",
        "texture": "## 1. 주제 선정 이유\n React라이브러리를 사용하다보면 상태관리가 필수이며 그에 따른 각종 기능들을 숙지하고 있어야한다. 이에 대해 알지 못하면 React를 사용하지 않는 수준이며, 협업을 하는데 있어 큰 지장이 되기에 이번 기회에 상태관리에 대한 정확한 정의를 학습하고, React의 상태관리 방법에는 어떤 것들이 있는지 살펴보도록 하자.\n\n## 2. 상태관리란\n\n# 2-1. 상태관리의 정의\n- 상태(State) : 컴퍼넌트 내부에서 관리되며 어플리케이션의 렌더에 영향을 미치는 자바스크립트 객체를 의미. 즉, **변화하는 데이터**라고 이해하면 된다. (ex, 쇼핑몰 사이트에서 구매할 물건의 수량을 늘리고 줄이는 행위를 상태가 변화한다고 한다.)\n- 상태관리 : 상태는 어는 컴퍼넌트에서나 일관되어야 한다. 이를 데이터의 무결성이라 한다. 왜냐하면, 상태가 컴퍼넌트마다 다르다면, 유저나 관리자가 받아들이는 데이터에 차이가 생겨 소통에 차질이 생기기 때문이다.\n따라서 상태를 일관되게 관리해야하며, React의 경우, **신뢰할 수 있는 단일 출처(동일한 데이터는 항상 같은 곳에서 가져온다)**라는 방법론으로 상태를 관리하고 있다.\n\n# 2-2. 상태의 종류\n- 지역상태(localState) : 특정 컴퍼넌트 안에서만 관리되는 상태를 의미한다. 이는 주로 작은 프로젝트처럼 좁은 영역에서만 관리되는 데이터들이다.\n- 컴퍼넌트 간 상태: 다수의 컴퍼넌트에서 사용되고 영향을 주는 데이터들을 의미한다. 대표적인 예시로 여러 컴퍼넌트가 동시에 사용하는 모달창 등이 있다\n2개 이상의 컴퍼넌트간에 상태를 주고 받을 경우, 상위 컴퍼넌트에서 하위 컴퍼넌트로만 상태를 전달하며, 이를 Props Driling이라 한다.\n- 전역 상태(globalState) : 프로젝트 전체에 영향을 끼치는 데이터를 의미한다. 대표적인 예로, 모든 컴퍼넌트에서 사용되는 페이지의 헤더 컴퍼넌트 등이 있다.\n- 상태관리가 필요한 이유: 걱 컴퍼넌트가 부모자식 관계로 되어있지 않은 이상 각 컴퍼넌트간의 직접적인 데이터 전달은 어렵우며, 구조가 복잡하여 Props Driling이 많아지면 Props의 출처를 찾기 어려워기 때문에 이를 관리해줘야 한다.\n\n## 3. React의 상태관리\n\n# 3-1. Context API\n- Context API : React 컴포넌트 트리 안에서 전역 상태를 공유할 수 있도록 만들어진 방법이다.명칭은 API이기는 하지만, 실질적인 관리는 API가 아니라 useState를 통해 이루어진다.\n- useState() :\n`cosnt [state, setState] = useState()`의 형태로 구성되어 있다.\n앞에서서부터 state라는 상태변수와 상태에 변화를 주는 setState라는 함수가 있다. useState()의 파라미터에는 초기 state값이 들어가며, 이후 setState를 통해 state의 값에 변화를 주는 방식으로 상태를 관리한다.\nuseState()는 상태를 새로 추가하거나 삭제하는 것이 아니라 단순 비교를 통해 상태를 업데이트 시키는 원리로 작동한다.\n즉, **동일한 데이터의 key값이면 키의 value값의 차이를 비교하여 최신의 value값으로 갱신하며 상태를 관리한다.**\n이는 중간에 있는 요소들에게 props를 넘기지 않고도 데이터를 가져다 사용할 수 있기에 props Drilling을 피할 수 있으며, 주로 전역적으로 쓰이는 데이터들을 사용할 때 자주 사용된다.\n- context API의 구조 : context, provider, comsumer 로 구성\n context : 전역상태를 저장하는 곳으로 , 내부에는 provider와 consumer로 구성되어있다.\n provider : 전역상태를 제공하는 역할을 한다. 주로 Root Component(index.js / app.js)에서 정의된다.\n consumer 제공받은 전역상태를 받아서 사용하는 역할을 한다.\n\n# 3-2. Redux\n- Redux : 공식 문서에 따르면 자바스크립트 앱을 위한 예측 가능한 상태 컨테이너라고 정의한다.\n 이를 풀어 설명하면, 전역 상태를 관리하는 도구, 즉, 어플리케이션 전체에 대한 중앙 저장소 역할을 한다고 생각하면 된다.\n- 'Store','Action', 'Reducer'로 구성되어 있다.\n Store는 전역상태를 저장하는 저장소 역할을 하며, 오직 Reducer를 통해서만 접근이 가능하다. 주로 index.js에 정의되며 Store는 오직 1개만 존재할 수 있다.\n Action은 Store에 저장된 상태의 변화를 Reducer에 명령하는 자바스크립트 객체이다. 변화를 주기 위해 dispatch라는 메서드를 사용하여 Reducer에게 전달된다.\n Reducer는 변화를 감지하여 상태를 변화시키는 역할을 하는 순수함수로서, 전역 상태를 변경하고 업데이트시킨다. 바닐라 자바스크립트의 '이벤트리스너'와 동일한 역할을 한다고 파악해도 좋다.\n 다만, Redux의 경우, 상태관리를 할 때, 이전상태를 변경시키는 것이 아닌 **새로운 상태의 객체를 생성하여 반환한다**는 점을 명시해야한다.\n *순수함수 : 다른 외부의 상태를 변경하지 않으면서도, 어떤 동일한 인자에 대해 항상 동일한 값을 리턴하는 함수이다.\n\n# 3-3. Recoil 라이브러리\n- 앞서 언급한 Redux는 단방향의 흐름에서 상태관리가 용이하지만, 이를 위한 action, reducer와 같은 초기 세팅이 상당히 번거롭고 React와 잘 맞지 않는다는 여론이 주를 이루었다.\n- React의 상태관리를 보다 React스럽게(hook을 전역으로 확장시킴) 하기 위해, 메타(전 페이스북)사에서 제작한 React 상태관리 라이브러리이다.\n- Recoil은 atom과 selector라는 객체를 사용하여 상태를 관리한다.\n- atom은 구독, 옵저버와 같은 개념을 생각할 필요없이 hook을 사용하듯이 사용하면 된다.\n hook를 사용했던 개발자라면 쉽게 사용할 수 있다.\n- selector를 이용하면 리듀서 없이 복잡한 연산도 간단하게 할 수 있다.",
        "qna": "추가해야함"
      },
      {
        "id": "7",
        "title": "JavaScript",
        "topic": "이벤트 버블링",
        "texture": " ## 1.  정의 : \n\n🎯 이벤트 버블링(event bubbling)은 HTML에서 이벤트가 발생했을 때, 해당 요소에서 이벤트가 처리된 후, **상위 요소로 이벤트가 전파되는 현상**을 말합니다. *(Trigger clicks all the way up)* 이벤트 버블링은 이벤트가 전파되는 동안 부모 요소에서도 이벤트를 감지할 수 있다는 **장점**이 있습니다. 즉, 이벤트를 처리하는 핸들러 함수를 부모 요소에 등록해놓으면, 자식 요소에서 발생한 이벤트도 모두 처리할 수 있습니다. 이를 활용하면, 여러 개의 하위 요소에서 발생하는 이벤트를 하나의 이벤트 핸들러로 바인딩하는 **이벤트 위임 처리**를 할 수 있습니다.\n\n![이벤트 버블링](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F58daf214-1434-4922-8f83-d22f9ea4129c%2FUntitled.png?table=block&id=db53aae9-446e-4eda-9c51-6781a607031b&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1440&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이벤트 버블링\n\n\n![이벤트 흐름 3단계](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6ad187ed-1aaf-4bdf-8294-3dec2e6e6ead%2FUntitled.png?table=block&id=28e1fbd7-40fa-4f4e-94cb-6e26b17b0ff7&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1280&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이벤트 흐름 3단계\n\n```jsx\n//이벤트 버블링\n<style>\n    body * {\n      margin: 10px;\n      border: 1px solid rgb(255, 2, 74);\n    }\n</style>\n\n    <div class='DIV1'>\n      DIV1\n      <div class='DIV2'>\n        DIV2\n        <div class='DIV3'>DIV3</div>\n      </div>\n    </div>\n\n<script>\nconst divs = document.querySelectorAll('div');\n\nconst clickEvent = (e) => {\n  console.log(e.currentTarget.className);\n};\n\ndivs.forEach((div) => {\n  div.addEventListener('click', clickEvent);\n});\n\n</script>\n```\n\n```jsx\n//onclick\n<body>\n  <div class='DIV1'>\n    DIV1\n    <div class='DIV2'>\n      DIV2\n      <div class='DIV3'>DIV3</div>\n    </div>\n  </div>\n\n  <script>\n    const divs = document.querySelectorAll('div');\n\n    divs.forEach((div) => {\n      div.addEventListener('click',function(event){\n        console.log(event.currentTarget.className);\n      };\n    });\n\n  </script>\n</body>\n```\n\n\n## 2.  내용:\n- 이벤트 전파(흐름)가 있는 이유\n\n    *이벤트 전파란*: 브라우저는 사용자로부터 이벤트가 발생하면 가장 상단의 요소부터 하위의 요소까지 내려오고 다시 거슬러 올라가는 식으로 이벤트를 전달하여 발생하도록 한다.\n    \n    - 논리적 측면\n    \n    어쩌면 당연할지도 모르지만, 자식 요소가 부모 요소 영역 안에 위치하고 있기 때문에, 자식 요소만을 클릭했다고 그것은 부모 요소도 클릭한 셈이 되기 때문이다.\n    \n    - 성능적 측면\n    \n    이런 특징은 이벤트 등록 코드를 줄일 수 있는 장점이 있음. 여러개의 리스트가 있다고하고, 몇번째를 클릭하든 같은 종류의 이벤트를 발생시키고 싶다고하자. 그러면 일일히 이벤트를 등록해야하는데, 부모요소인 ul에만 이벤트 등록을하면, 전파에 의해 어떠한 li를 클릭해도 이벤트를 사용할 수 있음. 이를 이벤트 위임이라고 한다.\n    \n- **이벤트 버블링과 캡쳐링의 차이점에 대해서 구분해서 인지한다.**\n    \n    **이벤트 캡처링**\n    \n    이벤트가 하위 요소로 전파되는 단계. 캡처링은 버블링과는 반대로 최상위 태그에서 해당 태그를 찾아 내려간다.\n    \n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1baa6ba7-8fc6-41f1-883a-b79ea096ddca%2FUntitled.png?table=block&id=07802a68-ab20-4e72-8b71-8a07315494bd&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1840&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n    \n    위 그림처럼 특정 이벤트가 발생했을 때 최상위 요소인 body 태그에서 해당 태그를 찾아 내려갑니다. 캡처링 단계를 이용해야 하는 경우는 흔치 않기 때문에, 캡처링 단계에서 이벤트를 잡아내려면 `addEventListener` 의 옵션 객체에 `{ capture: true }` 또는 `true` 를 설정해주면 캡처링을 구현할 수 있다.\n    \n    ```jsx\n    target.addEventListener('이벤트', 콜백 함수, {capture:ture});\n    target.addEventListener('이벤트', 콜백 함수, true);\n    ```\n    \n    - `false`이면(default 값) 핸들러는 버블링 단계에서 동작합니다. (*default 값은 false이고 생략가능합니다.*)\n    - `true`이면 핸들러는 캡처링 단계에서 동작합니다.\n    \n    ```jsx\n    //이벤트 캡처링\n    <style>\n        body * {\n          margin: 10px;\n          border: 1px solid rgb(255, 2, 74);\n        }\n    </style>\n    \n    <body>\n        <div class='DIV1'>\n          DIV1\n          <div class='DIV2'>\n            DIV2\n            <div class='DIV3'>DIV3</div>\n          </div>\n        </div>\n      </body>\n    \n    <script>\n    const divs = document.querySelectorAll('div');\n    \n    const clickEvent = (event) => {\n      console.log(event.currentTarget.className); //DIV1 DIV2 DIV3\n    };\n    \n    divs.forEach((div) => {\n      div.addEventListener('click', clickEvent, { capture: true });\n    // {capture: true} 대신, true를 써줘도 됩니다.\n    });\n    </script>\n    ```\n    \n- **이벤트 위임 패턴을 이해한다.**\n    \n    이벤트 위임(Event Delegation)이란 ‘**하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식**’입니다. 캡처링과 버블링을 활용하면 강력한 이벤트 핸들링 패턴인 *이벤트 위임(event delegation)* 을 구현할 수 있습니다. \n    \n    ```html\n    <h1>오늘의 할 일</h1>\n      <ul class='itemList'>\n        <li>\n          <input type='checkbox' id='item1'>\n          <label for='item1'>이벤트 버블링 학습</label>\n        </li>\n        <li>\n          <input type='checkbox' id='item2'>\n          <label for='item2'>이벤트 캡쳐 학습</label>\n        </li>\n      </ul>\n      <script>\n        //이벤트 위임 전, 각 인풋 박스의 요소에 클릭 이벤트 리스너를 추가\n        var inputs = document.querySelectorAll('input');\n        inputs.forEach(function (input) {\n          input.addEventListener('click', function (event) {\n            alert('clicked');\n          });\n        });\n    \n        //이벤트 위임 후\n        // var itemList = document.querySelector('.itemList');\n        // itemList.addEventListener('click', function (event) {\n        //   alert('clicked');\n        // });\n    \n        // 새 리스트 아이템을 추가하는 코드,  새 리스트를 추가할 때에는, li가 2개가 있는 시점 다음이기 때문에, 새로 생기는 li들은 이벤트가 적용되지 않는다.\n        // var itemList = document.querySelector('.itemList');\n    \n        // var li = document.createElement('li');\n        // var input = document.createElement('input');\n        // var label = document.createElement('label');\n        // var labelText = document.createTextNode('이벤트 위임 학습');\n    \n        // input.setAttribute('type', 'checkbox');\n        // input.setAttribute('id', 'item3');\n        // label.setAttribute('for', 'item3');\n        // label.appendChild(labelText);\n        // li.appendChild(input);\n        // li.appendChild(label);\n        // itemList.appendChild(li);\n      </script>\n    ```\n    \n    **이벤트 위임의 목적?**\n    \n    ```html\n    <div id='div-content'>\n      <span id='span-content'>\n        <button id='btn'>버튼</button>\n      </span>\n    </div>\n    ```\n    \n    [이벤트 위임 사용 전]\n    \n    ```jsx\n    // 개별 요소를 접근해야함\n    const divNode = document.getElementById('div-content');\n    const spanNode = document.getElementById('span-content');\n    const btnNode = document.getElementById('btn');\n    \n    // 개별 요소마다 이벤트 리스너를 등록해야함\n    divNode.addEventListener('click', function () {\n      console.log('divNode Click');\n    });\n    \n    spanNode.addEventListener('click', function () {\n      console.log('spanNode Click');\n    });\n    \n    btnNode.addEventListener('click', function () {\n      console.log('btnNode Click');\n    });\n    ```\n    \n    여러 개의 이벤트 리스너를 등록하면 이벤트 버블링에 의해 상위 요소의 이벤트 리스너도 실행됩니다. 이벤트 버블링에 의해 <button> 태그에서 click 이벤트가 발생하면, 해당 이벤트는 최상위 객체인 Document까지 전파됩니다. 위 코드의 문제점은 **상위 요소의 이벤트도 실행**함으로써 t상위 요소 이벤트 리스너에 문제가 되는 코드가 존재한다면.. 개발자가 **원하지 않는 결과**를 발생시킬 수 있습니다.\n    \n    ![img.gif](https://file.notion.so/f/s/dca28498-1342-48a1-82a7-a0de390e9738/img.gif?id=46fee168-0dc5-48ad-b4a1-40e24cb2fbd3&table=block&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&expirationTimestamp=1693972800000&signature=I1B4tmgdogxyH1hH2MyUOkK_4o7GyueSUAB94zxKkx4)\n    \n    [이벤트 위임 적용 후]\n    \n    - JavaScript에서 함수는 객체입니다. 함수가 많을수록 메모리 사용량이 증가하고 함수가 적을수록 메모리 사용량이 감소합니다.\n    - 이벤트 위임을 적용하면 조건문에 의해 원하는 요소에 원하는 동작을 수행하도록 코드를 구현할 수 있습니다.\n    - 코드의 간결화, 메모리 사용량 감소, 성능향상,\n    \n    ```jsx\n    // 상위 요소인 id가 'div-content'인 div 노드만 접근함\n    const divNode = document.getElementById('div-content');\n    \n    // div 노드에만 이벤트 리스너를 설정\n    divNode.addEventListener('click', function (e) {\n      const tagName = e.target.tagName;\n    \n      if (tagName === 'DIV') {\n        console.log('div Click');\n      } else if (tagName === 'SPAN') {\n        console.log('span id Click');\n      } else if (tagName === 'BUTTON') {\n        console.log('button Click');\n      }\n    });\n    ```\n    \n- stopPropagation() 이란?\n    \n    *이렇게 복잡한 이벤트 전달 방식 알고 싶지 않고, 그냥 원하는 화면 요소의 이벤트만 신경 쓰고 싶어요. →* Event객체의  **`stopPropagation()` 메서드를 활용해서 현재 이벤트가 캡처링/버블링 단계에서 더 이상 전파되지 않도록 방지합니다.\n    \n    *이벤트 버블링의 경우*에는 **클릭한 요소의 이벤트만 발생시키고 상위 요소로 이벤트를 전달하는 것을 방해**합니다. *이벤트 캡쳐의 경우*에는 **클릭한 요소의 최상위 요소의 이벤트만 동작시키고** 하위 요소들로 이벤트를 전달하지 않습니다.\n    \n    ```html\n    <div class='DIV1'>\n        DIV1\n        <div class='DIV2'>\n          DIV2\n          <div class='DIV3'>DIV3</div>\n        </div>\n    ```\n    \n    ```jsx\n    //캡처링 stopPropagation()\n    <script>\n    const divs = document.querySelectorAll('div');\n\n    const clickEvent = (event) => {\n      event.stopPropagation();\n      console.log(event.currentTarget.className); //DIV1\n    };\n    \n    divs.forEach((div) => {\n      div.addEventListener('click', clickEvent, { capture: true });\n    });\n    </script>\n    ```\n    \n    ```jsx\n    //버블링 stopPropagation()\n    <script>\n    const divs = document.querySelectorAll('div');\n    \n    const clickEvent = (event) => {\nevent.stopPropagation();\n      console.log(event.currentTarget.className); //DIV3\n};\n\ndivs.forEach((div) => {\ndiv.addEventListener('click', clickEvent);\n});\n</script>\n    ```",
        "qna": "추가해야함"
      },
      {
        "id": "8",
        "title": "JavaScript",
        "topic": "this",
        "texture": "## this\n\nthis는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. \n\nthis는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다. 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. \n\n단, 자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.\n\n🧐 **arguments 객체는 무엇인가..?** \n\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F928ac1fc-a7a3-487f-9694-5f63e231cfb8%2FUntitled.png?table=block&id=f0e6eeef-d205-4c31-9d05-6c0d9845c5ff&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1340&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n🧐 **this 바인딩**\n\n바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어, 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다. this 바인딩은 this와 this가 가리킬 객체를 바인딩하는 것이다. \n\n```jsx\n// this는 어디서든지 참조 가능하다.\n// 전역에서 this는 전역 객체 window를 가리킨다.\nconsole.log(this); // window\n\nfunction square(number) {\n\t// 일반 함수 내부에서 this는 전역 객체 window를 가리킨다.\n  console.log(this); // window\n\treturn number * number;\n}\nsquare(2);\n\nconst person = {\n\tname: 'Lee',\n\tgetName() {\n\t\t// 메서드 내부에서 this는 메서드를 호출한 객체를 가리킨다. \n    console.log(this); {name: 'Lee', getName: f}\n\t\treturn this.hame;\n  }\n};\nconsole.log(person.getName()); // Lee\n\nfunction Person(name) {\n\tthis.name = name;\n  // 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.\n  console.log(this); // Person {name: 'Lee}\n}\n\nconst me = new Person('Lee');\n```\n\n하지만 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반적으로 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다. 따라서 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다. 일반 함수 내부에서 this를 사용할 필요가 없기 때문이다. \n\n## 함수 호출 방식과 this 바인딩\n\n**this바인딩(this에 바인딩될 값)은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.** \n\n🧐**렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.**\n\n함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. 하지만 this 바인딩은 함수 호출 시점에 결정된다.\n\n함수를 호출하는 방식 \n\n1. 일반 함수 호출\n2. 메서드 호출\n3. 생성자 함수 호출\n4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출\n\n### 1. 일반 함수 호출\n\n기본적으로 this에는 전역 객체(global object)가 바인딩된다.\n\n```jsx\nfunction foo() {\n\tconsole.log(\"foo's this: \", this); // window\n  function bar() {\n\t  console.log(\"bar's this: \", this); // window\n  }\n  bar();\n}\nfoo();\n```\n\n전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.                                           \n\n다만 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 객체를 생성하지 않는 일반 함수에서 this는 의미가 없다. 따라서 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다.                                                                         \n\n일반 함수로 호출된 모든 함수(중첩함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.\n\n하지만 메서드 내에서 정의한 중첩 함수나 메서드에게 전달한 콜백 함수(보조 함수)가 일반 함수로 호출될 때 메서드 내의 중첩 함수 또는 콜백 함수의 this가 전역 객체를 바인딩하는 것은 문제가 있다. 중첩 함수 또는 콜백 함수는 외부 함수를 돕는 헬퍼 함수의 역할을 하므로 외부 함수의 일부 로직을 대신하는 경우가 대부분이다. 하지만 외부 함수인 메서드와 중첩 함수 또는 콜백 함수의 this가 일치하지 않는다는 것은 중첩 함수 또는 콜백 함수를 헬퍼 함수로 동작하기 어렵게 만든다. \n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n\tconsole.log(\"foo's this: \", this); // {value: 100, foo: f}\n    // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.\n    setTimeout(function () {\n\t\tconsole.log(\"callback's this: \", this); // window\n      console.log(\"callback's this.value: \", this.value); // 1\n    }, 100);\n  }\n};\n\nobj.foo()\n```\n\n메서드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메서드의 this 바인딩과 일치시키기 위한 방법은 다음과 같다. \n\n방법①\n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n  // this 바인딩(obj)을 변수 that에 할당한다.\n  const that = this;\n  \n  // 콜백 함수 내부에서 this 대신 that을 참조한다.\n  setTimeout(function () {\n\t\tconsole.log(that.value); // 100\n\t}, 100);\n }\n};\n\nobj.foo();\n```\n\n방법② \n\n- this를 명시적으로 바인딩할 수 있는 Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메서드 사용하기 \n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n\tfoo() {\n\t\t// 콜백 함수에 명시적으로 this를 바인딩한다.\n    setTimeout(function () {\n\t\t\tconsole.log(this.value); // 100\n    }.bind(this), 100);\n  }\n};\n\nobj.foo();\n```\n\n방법③ \n\n- 화살표 함수를 사용해서 this 바인딩을 일치시키기\n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n\t\t// 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.\n  setTimeout(() => console.log(this.value), 100); // 100\n  }\n};\n\nobj.foo(); \n```\n\n### 2. 메서드 호출\n\n메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다. 주의할 것은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다. \n\n```jsx\nconst person = {\n\tname: 'Lee',\n  getName() {\n\t\t// 메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다. \n    console.log(this); {name: 'Lee', getName: f}\n\t\treturn this.name;\n  }\n};\n\n// 메서드 getName을 호출한 객체는 person이다.\nconsole.log(person.getName()); // Lee  \n```\n\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbbcb928d-8ddf-465c-909d-7af0fbd7215a%2FUntitled.png?table=block&id=68a5ce2d-c73a-4b2d-8220-561ff980a838&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1770&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n### 3. 생성자 함수 호출\n\n생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.\n\n```jsx\nfunction Circle(radius) {\n\t// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.\n  this.radius = radius;\n  this.getDiameter = function () {\n\t\treturn 2 * this.radius;\n  };\n}\n\n// 반지름이 5인 Circle 객체를 생성\nconst circle1 = new Circle(5);\n// 반지름이 10인 Circle 객체를 생성\nconst circle2 = new Circle(10);\n\nconsole.log(circle1.getDiameter()); // 10\nconsole.log(circle2.getDiameter()); // 20 \n```\n\n### 4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출\n\napply, call, bind 메서드는 Function.prototype의 메서드다. 즉 이들 메서드는 모든 함수가 상속받아 사용할 수 있다. \n\nFunction.prototype.apply,  Function.prototype.call 메서드는 this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 호출한다.\n\n```jsx\nfunction getThisBinding() {\n\treturn this;\n}\n\n// this로 사용할 객체\nconst thisArg = {a: 1};\n\nconsole.log(getThisBinding()); // window\n\n// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.\nconsole.log(getThisBinding.apply(this.Arg)); // {a: 1}\nconsole.log(getThisBinding.call(this.Arg)); // {a: 1} \n```\n\napply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다. \n\napply와 call 메서드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작한다. apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다. call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다. \n\n 그렇다면 apply와 call 메서드의 용도는 무엇일까? \n\napply와 call 메서드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice 같은 배열의 메서드를 사용할 수 없으나 apply와 call 메서드를 이용하면 가능하다. \n\n```jsx\nfunction convertArgsToArray() {\n\tconsole.log(arguments);\n\t\n\t// arguments 객체를 배열로 변환\n  // Array.prototype.slice를 인수 없이 호출하면 배열의 복사본을 생성한다. \n  const arr = Array.prototype.slice.call(arguments);\n  // const arr = Array.prototype.apply(arguments);\n  console.log(arr);\n \n  return arr;\n}\n\nconvertArgsToArray(1, 2, 3); // [1, 2, 3]\n\n```\n\nFunction.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않는다. 다만 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 새롭게 생성해 반환한다. \n\n```jsx\nfunction getThisBinding() {\n\treturn this;\n}\n\n// this로 사용할 객체\nconst thisArg - {a : 1};\n\n// bind 메서드는 첫 번째 인수로 전달한 thisArg로 this 바인딩이 교체된\n// getThisBinding 함수를 새롭게 생성해 반환한다.\nconsole.log(getThisBinding.bind(thisArg)); // getThisBinding\n// bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.\nconsole.log(getThisBinding.bind(thisArg())); // {a : 1}\n```\n\n그렇다면 bind메서드는 언제 사용할까? \n\n```jsx\nconst person = {\n\tname: 'Lee',\n  foo(callback) {\n   // ①\n  setTimeout(callback, 100);\n  }\n};\n\nperson.foo(function () {\n\tconsole.log(`Hi! my name is ${this.name}.`); // ② Hi my name is .\n  // 일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.\n  // 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 '' 이다.\n  // Node.js 환경에서 this.name은 undefined다.\n}); \n```\n\nperson.foo의 콜백 함수가 호출되기 이전인 ①의 시점에서 this는 foo 메서드를 호출한 객체, 즉 person 객체를 가리킨다. \n\n그러나 person.foo의 콜백 함수가 일반 함수로서 호출된 ②의 시점에서 this는 전역 객체 window를 가리킨다. 따라서 person.foo의 콜백 함수 내부에서 this.name은 window.name과 같다.\n\n이때 위 예제에서 person.foo의 콜백 함수는 외부 함수 person.foo를 돕는 헬퍼 함수(보조 함수) 역할을 하기 때문에 외부 함수 person.foo 내부의 this와 콜백 함수 내부의 this가 상이하면 문맥상 문제가 발생한다.\n\n따라서 콜백 함수 내부의 this를 외부 함수 내부의 this와 일치시켜야 한다. 이때 bind 메서드를 사용하여 this를 일치시킬 수 있다.",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. this에 대해서 설명해주세요.\n\n # A.\n\n this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. \n\n그리고 this가 가리키는 값, 즉 this 바인딩(this와 this가 가리킬 객체를 바인딩하는 것)은 함수 호출 방식에 의해 동적으로 결정된다."
      },
      {
        "id": "9",
        "title": "JavaScript",
        "topic": "이터러블",
        "texture": "### 🎈주제 선정 이유?\n\n호이스팅, 브라우저 렌더링 등과 같이 프론트엔드 기술면접 단골질문까진 아니지만, 부트캠프 수업에서 이터러블에 대해 자세히 다룬적이 없어서 이터러블에 대한 이해가 부족했다. 스터디원분들도 마찬가지가 아닐까 싶어서 공부도 할겸 이터러블로 주제를 선정하게 되었다.\n\n### ⛳ 이번 목표\n\n이터러블과 이터레이션에 대해 알아보자\n\n---\n\n### 1. 이터러블\n\n네이버 영어사전에 iterate를 찾아보면 반복하다라는 의미가 있다.\n\n![image](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2F3a892a75-8c16-4b62-9212-55d3a7bb89f8%2Fimage.png?table=block&id=281d1b41-c4b4-4463-baea-99cb8df016ab&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이터러블 프로토콜을 준수한 객체를 이터러블이라한다. 즉, 이터러블은 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다.\n\n```javascript\n// Symbol.iterator를 프로퍼티 키로 사용한 메서드\n [Symbol.iterator]() {\n// 이터레이터 객체 반환\n}\n```\n\n예를 들어, 배열은 Array.prototype의 Symbol.iterator 메서드를 상속받는 이터러블이다. 이터러블은 for ... of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.\n\n Symbol.iterator 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다. 따라서 일반 객체는 for ... of 문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭쳐링 할당의 대상으로 사용할 수 없다.\n\n```javascript\n const obj = {a: 1, b: 2};\n\n// 일반 객체는 Symbol.iterator 메서드를 구현하거나 상속받지 않는다.\n// 따라서 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.\n console.log(Symbol.iterator in obj); // false\n\n// 이터러블이 아닌 일반 객체는 for ... of 문으로 순회할 수 없다.\n for (const item of obj) { // → TypeError: obj is not iterable\n console.log(item);\n}\n\n// 이터러블이 아닌 일반 객체는 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.\n const [a, b] = obj; // → TypeError: obj is not iterable\n```\n\n🤔 그렇다면 이터러블이 아닌 일반 객체는 스프레드 문법도 사용하지 못하겠다라는 생각이 들 수 있다. 하지만 스프레드 프로퍼티 제안(stage 4)은 일반 객체에 스프레드 문법의 사용을 허용한다고 한다.\n\n```javascript\nconst obj = {a: 1, b: 2};\n\n console.log({...obj})l // {a: 1, b: 2};\n```\n\n그리고 일반 객체도 이터러블 프로토콜을 준수하도록 구현하면 이터러블이 된다고 한다.\n\n### 2. 이터레이터\n\n이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 next 메서드를 소유하며 next 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. 이러한 규약을 이터레이터 프로토콜이라 하며, 이터레이터 프로토콜을 준수한 객체를 이터레이터라 한다.\n\n```javascript\n// 배열은 이터러블 프로토콜을 준수한 이터러블이다.\n const array = [1, 2, 3]; \n\n // Symbol.iterator 메서드는 이터레이터를 반환한다.\n const iterator = array[Symbol.iterator]();\n\n// Symbol.iterator 메서드가 반환한 이터레이터는next 메서드를 갖는다.\n console.log('next' in iterator); // true\n\n// next 메서드를 호출하면 이터러블을 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다.\n// 이터레이터 리절트 객체는 value와 done 프로퍼티를 갖는 객체다.\n console.log(iterator.next());  // { value: 1, done: false }\n console.log(iterator.next());  // { value: 2, done: false }\n console.log(iterator.next());  // { value: 3, done: false }\n console.log(iterator.next());  // { value: undefined, done: true }\n```\n\n### 3. 이터러블과 유사 배열 객체\n\n유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.\n\n유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있고, 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로 가지므로 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.\n\n```javascript\n// 유사 배열 객체\n const arrayLike = {\n0: 1,\n 1: 2,\n 2: 3,\nlength: 3\n};\n\n// 유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있다.\nfor (let i = 0; i < arrayLike.length; i++) {\n  // 유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.\n  console.log(arrayLike[i]); // 1 2 3\n}\n```\n\n🤔 그렇다면 유사 배열 객체는 배열처럼 for ... of 문으로 순회할 수 있을까..?\n\n이에 대한 답은 'NO' 이다. 유사 배열 객체는 이터러블이 아닌 일반 객체다. 따라서 유사 배열 객체에는 Symbol.iterator 메서드가 없기 때문에 for ... of 문으로 순회할 수 없다.\n\n```javascript\n// 유사 배열 객체는 이터러블이 아니기 때문에 for ... of 문으로 순회할 수 없다.\nfor (const item of arrayLike) {\n console.log(item);\n}\n// → TypeError: arrayLike is not iterable\n```\n\n유사 배열 객체이면서 이터러블인 것: arguments, NodeList, HTMLCollection\n\n정확히 말하면 ES6에서 이터러블이 도입되면서 유사 배열 객체인 arguments, NodeList, HTMLCollection 객체에 Symbol.iterator 메서드를 구현하여 이터러블이 되었다. 하지만 이터러블이 된 이후에도 length 프로퍼티를 가지며 인덱스로 접근할 수 있는 것에는 변함이 없으므로 유사 배열 객체이면서 이터러블인 것이다.\n\n→ 모든 유사 배열 객체가 이터러블인 것은 아니다. 유사 배열 객체 중에 이터러블인 것이 있고 아닌 것이 있다.\n\n배열도 마찬가지로 ES6에서 이터러블이 도입되면서 Symbil.iterator 메서드를 구현하여 이터러블이 되었다.\n\n위의 예제에서의 arrayLike 객체는 ES6에서 도입된 Array.from 메서드를 사용하여 배열로 간단히 변환할 수 있다.\n\nArray.from 메서드는 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환하여 반환한다.\n\n```javascript\n// 유사 배열 객체\nconst arraLike = {\n 0: 1,\n 1: 2,\n 2: 3,\n length: 3\n};\n\n// Array.from은 유사 배열 객체 또는 이터러블을 배열로 변환한다.\nconst arr = Array.from(arrayLike);\nconsole.log(arr); // [1, 2, 3]\n```\n\n### 4. 이터레이션 프로토콜의 필요성\n\n💡 그렇다면 왜 이터레이션 프로토콜의 필요한가에 대해 알아보자.\n\nES6 이전의 순회 가능한 데이터 컬렉션(배열, 문자열, 유사 배열 객체, DOM 컬렉션 등)등은 통일한 규약 없이 각자 나름의 구조를 가지고 for 문, for ... in 문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다. ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for ... of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화했다.\n\n이터러블은 for ... of 문, 스프레드 문법, 배열 디스트럭처링 할당과 같은 데이터 소비자에 의해 사용되므로 데이터 공급자의 역할을 한다고 할 수 있다.\n\n만약 다양한 데이터 공급자가 각자의 순회 방식을 갖는다면 데이터 소비자는 다양한 데이터 공급자의 순회 방식을 모두 지원해야 한다. 이는 효율적이지 않다. 하지만 다양한 데이터 공급자가 이터레이션 프로토콜을 준수하도록 규정하면 데이터 소비자는 이터레이션 프로토콜만 지원하도록 구현하면 된다.\n\n즉, 이터러블을 지원하는 데이터 소비자는 내부에서 Symbol.iterator 메서드를 호출해 이터레이터를 생성하고 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 이터레이터 리절트 객체를 반환한다. 그리고 이터레이터 리절트 객체의 value/done 프로퍼티 값을 취득한다.\n\n이처럼 이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 한다.\n\n![image](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2Fa6742119-741e-4d11-bed2-be5624695fdf%2Fimage.png?table=block&id=be23645f-ed39-49ff-aaea-0c029d41be29&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. 이터러블에 대해서 설명해주세요.\n\n # A.\n\n \n이터러블이란 반복이 가능한 객체를 말합니다.\n이터러블은 `Symbol.iterator` 메서드를 가지고 있는데, 이 메서드는 이터레이터를 반환하여, 이터러블 객체의 각 요소를 반복할 수 있도록 해줍니다.\n\n이터레이터는 이터러블 객체에서 값을 순차적으로 가져오는 법을 정의합니다.\n\n이터레이터는`next()`메서드를 호출할 때마다 이터러블 객체에서 다음 값을 가져오고, 가져올 값이 없을 경우 done 프로퍼티가 true인 객체를 반환합니다.\n\n 이터러블과 이터레이터 프로토콜을 사용하여, 다양한 자료구조를 반복할 수 있습니다. \n\n 예를 들어 배열, 문자열, Map, Set, NodeList 등의 객체는 모두 이터러블입니다. 따라서 for ... of 문이나 전개 연산자, 구조 분해 할당 등을 사용하여 이러한 객체를 반복하고 다룰 수 있습니다."
      },
      {
        "id": "10",
        "title": "JavaScript",
        "topic": "props drilling",
        "texture": "## 🎈주제 선정 이유?\n\n프로젝트에 필요한 redux toolkit에 대해 공부하다가, 상태관리가 등장한 배경에 대해서 궁금해져서 조사하게 되었다.\n\n## ⛳ 학습 목표\n\nprops drilling은 무엇이고 어떻게 피할 수 있는지에 대해 학습한다.\n\n## ⛏️ Props Drilling이란\n\n![이미지](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2Fec3d3141-98e0-4288-994c-a4b107e852de%2Fimage.png?table=block&id=c70b3d1b-cfa4-4727-adc8-0e31edd09ed2&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n`Props Drilling` 은 props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정이다.\n\n### 😀 Props Drilling의 장점\n\n- 컴포넌트 간에 데이터를 전달하는 가장 쉽고 빠르게 전달할 수 있다.\n- (작은 규모의 어플리케이션에서) 컴포넌트를 잘게 분할해서 Props drilling을 통해 전달하면, 코드를 실행하지 않고 정적으로 따라가는 것만으로도 어떤 데이터가 어디서 사용되는지 쉽게 파악할 수 있으며, 수정도 용이하다\n\n### 😱 그렇다면 Props Drilling이 문제인 이유는 무엇인가?\n\n어플리케이션의 규모가 커지고, 중간 컴포넌트의 수가 많아지게 되면서 불필요한 props 전달로 인해 유지보수도 어렵고 가독성도 떨어질 수 있다.\n\n- 필요보다 많은 props를 전달하다가, 컴포넌트를 분리하는 과정에서 필요하지 않은 props가 계속 남거나 전달되는 문제\n- props 전달이 누락되었는데 `defaultProps`가 과용되었을 때, props가 전달되지 않은 상황을 인지하기가 어려운 문제\n- 자세한 설명\n\n    (ChatGPT)>> 일반적으로, React에서 defaultProps는 props의 기본값을 정의하는 데 사용된다. 만약 상위 컴포넌트에서 하위 컴포넌트로 props를 전달하지 않았을 때, defaultProps에 정의된 기본값이 하위 컴포넌트에 자동으로 적용된다. 이는 기본적으로 컴포넌트가 동작하는 데는 문제가 없지만, 때로는 예상치 못한 동작이 발생할 수 있다.문제는, defaultProps를 과용하여 하위 컴포넌트에서 필요한 props를 전달하지 않아도 문제가 발생하지 않는다고 착각할 수 있다는 점이다. 실제로는 props가 전달되지 않은 상황에서도 defaultProps에 정의된 기본값이 사용되기 때문에, 버그를 파악하고 수정하는 데 어려움을 겪을 수 있다.따라서, Props Drilling을 사용할 때는 defaultProps를 신중하게 사용해야 합니다. 필요한 props가 명시적으로 전달되도록 하고, defaultProps는 최소한의 기본값 설정에 사용하는 것이 좋다. 이렇게 하면 props 전달이 누락되었을 때 실제로 문제가 발생하며, 이를 빠르게 인지하고 수정할 수 있게 된다.\n\n- props의 이름이 전달 중에 변경되어서 데이터를 추적하기 쉽지 않게되는 문제\n- 자세한 설명(ChatGPT)>> Props Drilling을 사용하면서 props의 이름이 중간 컴포넌트를 거치면서 변경되는 경우를 의미한다. 이는 props의 이름이 상위 컴포넌트에서 하위 컴포넌트로 전달되는 동안 수정되거나 재정의되어 데이터의 추적이 어려워지는 상황을 말한다.예를 들어, 상위 컴포넌트에서 하위 컴포넌트로 value라는 이름의 props를 전달한다고 가정해보자. 하지만 중간 컴포넌트에서 value를 받은 후 다른 이름으로 변경하거나 다른 컴포넌트에 전달할 수 있다. 이 경우 하위 컴포넌트에서는 원래 props 이름이 무엇이었는지 추적하기 어려워지고, 코드를 분석하거나 디버깅하기 어려워진다.이러한 상황에서는 코드의 가독성과 유지보수성이 저하될 수 있다. 특히 프로젝트가 커지고 여러 컴포넌트가 복잡하게 얽혀있을 때, props 이름의 변경이 제대로 추적되지 않으면 버그를 찾기 어려워진다.\n\n    (ChatGPT)>> Props Drilling을 사용하면서 props의 이름이 중간 컴포넌트를 거치면서 변경되는 경우를 의미한다. 이는 props의 이름이 상위 컴포넌트에서 하위 컴포넌트로 전달되는 동안 수정되거나 재정의되어 데이터의 추적이 어려워지는 상황을 말한다.예를 들어, 상위 컴포넌트에서 하위 컴포넌트로 value라는 이름의 props를 전달한다고 가정해보자. 하지만 중간 컴포넌트에서 value를 받은 후 다른 이름으로 변경하거나 다른 컴포넌트에 전달할 수 있다. 이 경우 하위 컴포넌트에서는 원래 props 이름이 무엇이었는지 추적하기 어려워지고, 코드를 분석하거나 디버깅하기 어려워진다.이러한 상황에서는 코드의 가독성과 유지보수성이 저하될 수 있다. 특히 프로젝트가 커지고 여러 컴포넌트가 복잡하게 얽혀있을 때, props 이름의 변경이 제대로 추적되지 않으면 버그를 찾기 어려워진다.\n\n### 🔧 그렇다면 이러한 Props Drilling으로 생기는 문제 피하는 방법은?\n\n1) 렌더링 될 컴포넌트를 불필요하게 여러 컴포넌트로 나누지 않는다.\n\nReact는 (권장되지는 않지만)단 하나의 컴포넌트에 어플리케이션 전체를 작성하더라도 기술적인 제약은 없다. 따라서 성급하게 불필요한 컴포넌트 쪼개기를 할 필요는 없다. 컴포넌트를 재사용해야할 상황을 기다렸다 분할해도 늦지 않으며, 불필요한 prop drilling도 하지 않을 수 있다.\n\n2) defaultProps를 필수 컴포넌트에 사용하지 않는다.\n\ndefaultProps를 사용하면 컴포넌트가 제대로 동작하기 위해 꼭 필요한 props가 전달되지 못한 상황에도 중요한 오류가 가려지게 된다. 따라서 defaultProps를 필수적이지 않은 컴포넌트에만 사용하면 prop drilling으로 인한 문제를 막을 수 있다.\n\n3) 가능한 관련성이 높은 곳에 state를 위치 시킨다.\n\n어떤 데이터가 어플리케이션의 특정 위치에서만 필요하다면 최상위 컴포넌트에 state를 위치시키는 것보다 해당 데이터를 필요로 하는 최소 공통 부모 컴포넌트에서 관리를 하는 것이 가장 효율적이다.\n\n4) 상태관리 도구를 사용한다.\n\n데이터를 필요로 하는 컴포넌트가 정말 깊숙히 위치하고 있다면, React에서 제공하는 Context API를 사용하거나 Redux 등의 외부 상태관리 라이브러리를 사용해서 문제를 해결할 수 있다. 물론 어플리케이션의 모든 곳에서 이와 같은 도구를 사용해야하는 것은 아니지만, 비교적 손쉽게 문제를 해결할 수 있다.\n\n### Context API\n\nReact에 내장되어 컴포넌트 트리 전체에 데이터를 제공할 수 있는 API이다.\n\n장점\n\n- Redux는 무겁고 복잡한 라이브러리이다. 따라서 상태관리가 아닌 단순히 props를 전달할 목적이라면 context API를 사용하는 것이 적절하다.\n\n단점\n\n- Context API에서 상태값이 변경되면, provider로 감싼 모든 자식 컴포넌트가 리렌더링이 된다. 리렌더링은 성능에 영향을 미칠 수 있기 때문에 때문에 자식 컴포넌트의 불필요한 리렌더링을 방지해야한다.\n\n### Redux\n\n오픈 소스 자바스크립트 라이브러리로 state를 사용해 애플리케이션의 전역 상태 관리를 위해 사용한다.\n\n장점\n\n- 단방향 데이터 통신이 발생하기 때문에 데이터 흐름을 예측할 수 있고 디버깅에 유리하다.자세한 설명(ChatGPT)>> Redux는 상태 관리 라이브러리로서, 애플리케이션의 데이터를 중앙 집중적으로 관리하고 상태 변화를 예측 가능한 방식으로 처리한다. 이는 단방향 데이터 흐름을 갖는 아키텍처를 채택하여 데이터의 변화를 추적하고 예측하기 쉽게 만든다.단방향 데이터 흐름은 데이터의 이동 경로가 일정하고 예측 가능하다는 의미이다. Redux에서는 데이터의 흐름이 '액션 → 리듀서 → 상태'의 단방향으로 이루어진다. 액션은 상태 변화에 대한 정보를 담은 객체이며, 리듀서는 액션을 기반으로 상태를 업데이트하는 순수 함수이다. 이러한 단방향 흐름으로 인해 데이터의 변화가 어떤 경로를 따라가는지 예측할 수 있고, 디버깅 시 데이터 변화를 추적하기 용이하다.\n\n단점\n\n- 무겁고 사용하기에 복잡하다.(이를 보완하기 위해 redux toolkit 등의 라이브러리가 등장하였다.)",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. Props drilling은 무엇이고 어떻게 피할 수 있는가?.\n\n # A.\n\n Props Drilling은 props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정입니다.\n\n이는 컴포넌트 간에 데이터를 전달하는 가장 쉽고 빠르게 전달할 수 있다는 장점이 있다. 하지만 어플리케이션의 규모가 커지고, 중간 컴포넌트의 수가 많아지게 되면서 불필요한 props 전달로 인해 유지보수도 어렵고 가독성도 떨어질 수 있다.\n\n이를 피하기 위해 컴포넌트를 리팩토링하고, 컴포넌트를 더 작은 컴포넌트들로 쪼개지 않고, state를 가장 가까운 부모 컨포넌트와만 공유함으로써 props drilling 회피할 수 있습니다. 위계상 멀리/깊게(deep/far)떨어진 컴포넌트와 state를 공유할 때, React의 \n\nContext API 혹은 Redux와 같은 state 관리 라이브러리를 사용할 수 있습니다."
      },
      {
        "id": "11",
        "title": "React",
        "topic": "React를 사용하는 이유",
        "texture": "## 🎈주제 선정 이유?\n\n리액트를 활용한 프로젝트를 하면서, 리액트의 장점이 어느정도 느껴졌다. 하지만 누군가 리액트를 왜 사용하나요? 라고 묻는다면 바로 대답하기가 어려울 것 같다는 생각이 들었다. 그래서 이번에 리액트를 왜 사용하는지에 대해 조사하기로 했다.\n\n## ⛳ 학습 목표\n\n리액트는 무엇인지, 그리고 왜 리액트를 사용하는 지에 대해서 학습한다.\n\n## 📖 React를 사용하는 이유\n\n### React란?\n\n![이미지](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2F9d658f0c-d7a8-4599-991b-015b71e5e644%2Fimage.png?table=block&id=e3459bba-2a1e-4eda-84f7-f147b050c18c&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n**라이브러리**: 라이브러리(영어: library)는 주로 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임이다.\n\n사용자 인터페이스: 사람(사용자)과 사물 또는 시스템, 기계, 컴퓨터 프로그램 등 사이에서 의사소통을 할 수 있도록 일시적 또는 영구적인 접근을 목적으로 만들어진 물리적, 가상적 매개체를 뜻한다.\n\n출처: 위키백과\n\n### React의 특징\n\n1. 가상 돔의 사용으로 DOM 업데이트 최적화\n \n 리액트 개발자들의 DOM 업데이트를 위해서 하는 최적화 행위를 가상 돔을 만들어 비교하고 DOM을 추상화하여 필요한 부분만 다시 그리는 방식으로 개발자들이 DOM 업데이트를 오용하는 일을 피했다.\n \n2. 컴포넌트 기반\n \n 컴포넌트 기반인 리액트는 특정 기능을 구현하거나 특정 화면을 구현할 때 그 화면을 구성하는 일에만 집중할 수 있게 해준다. 여러 명의 프론트엔드 개발자가 하나의 페이지를 만든다고 해도 서로 다른 파일을 작업하도록 구성할 수 있기 때문에 효율적인 코드 분리가 가능하다.\n \n3. 생태계 및 수 많은 커뮤니티와 지속적인 개발\n \n 리액트의 생태계는 여러 다른 라이브러리, 프레임워크 커뮤니티보다 활발하다. 단순 View만을 관리하는 리액트가 프레임워크처러 사람들이 사용할 수 있을 정도이다. 페이스북이 만들었고 주도하고 있으며, AiRbnb, Netflix같은 기업들이 리액트를 사용 중에 있다.\n \n4. React Native의 앱 개발 기능\n \n React Native는 모바일 앱을 만들기 위한 프레임워크로 React 기반으로 만들어졌습니다. 그래서 React로 기존에 개발을 하는 웹 개발자라면 React Native를 금방 배울 수 있고 쉽게 모바일 앱을 만들 수 있다.",
        "qna": "## 4. 요약 정리 및 면접형 QnA\n\n# Q. React은 무엇이고, 왜 사용하는가?\n\n # A.\n\n 리액트는 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리입니다.\n\n그리고 리액트는 아래와 같은 이점이 있어 많이 사용되고 있습니다.\n\n1. 컴포넌트 단위로 구성하여 조합, 분해하기가 쉽습니다.\n\n2. 로직과 뷰를 분리하여 구분하기 쉽습니다.(로직은 컴포넌트의 동작과 상태를 처리하고, 뷰는 컴포넌트의 외형과 사용자 인터페이스를 정의합니다. 이렇게 분리된 코드는 이해하기 쉽고 유지보수가 용이합니다.)\n\n3. 가상 DOM을 활용하기 때문에 화면이 자주 바뀌는 경우 렌더링 자원을 아낄 수 있습니다.\n\n4. 상태 관리와 이에 따른 뷰의 변화를 제어하기 쉽습니다.(상태의 변화를 감지하고, 이에 따른 뷰의 업데이트를 자동으로 처리할 수 있는 기능과 패턴을 제공한다.)"
      },
      {
        "id": "20",
        "title": "CS",
        "topic": "동기와 비동기, 블로킹과 논블로킹",
        "texture": "## 블로킹/논블로킹\r\n\r\n호출자와 피호출자의 제어권과 관련\r\n\r\n제어권: 코드의 실행 순서를 제어하는 권리로 제어권을 가진 함수는 코드 실행 후 자신을 호출한 함수로 이동한다.\r\n\r\n![블로킹 함수](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F63c27193-518b-4f49-9b5e-5e600e624602%2Fimages_nittre_post_8cdc0a02-d469-47d5-96c8-f6aeef204eb7_image.png?table=block&id=96d24daf-5ab1-4e18-b791-eb7b61700488&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=770&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n블로킹 함수\r\n\r\n![논블로킹 함수](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/44b1e7dd-aed5-4720-80c5-14065f71c4cc/images_nittre_post_c839fc04-1788-4063-ab38-b0d4a312dbf4_image.png)\r\n\r\n논블로킹 함수\r\n\r\n**블로킹**\r\n\r\n1. A함수가 B함수를 호출 (제어권 A → B)\r\n\r\n2. 제어권이 넘어갔기 때문에 A함수는 실행을 중단하고 B함수 실행\r\n\r\n3. B함수 실행이 끝나면 다시 A함수로 제어권 이동\r\n\r\n**논블로킹**\r\n\r\n1. A함수가 B함수 호출(제어권 이동X)\r\n\r\n2. 제어권이 A함수에 있기 때문에 중단하지 않고 코드를 실행\r\n\r\n**제어권이 없는 함수가 어떻게 실행될 수 있을까?**\r\n\r\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6c1adbc7-41e1-42cb-9f53-53c153bae6f0/Untitled.png)\r\n\r\n이벤트 루프, 태스크 큐를 사용!\r\n\r\n비동기 함수의 콜백함수는 태스크 큐에 푸시되어 기다리다가 콜 스택이 비어있으면 이벤트 루프에 의해 다시 콜 스택에 푸시되어 실행한다.\r\n\r\n## 동기/비동기\r\n\r\n작업을 수행하는 시점과 관련\r\n\r\n![동기, 비동기](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5505c0de-1737-4ed5-891a-665bcf50b058/img1.daumcdn.png)\r\n\r\n동기, 비동기\r\n\r\n**동기**\r\n\r\n함수 1을 호출하고 처리 결과를 받아서 확인 후 2번 함수를 수행한다면 동기\r\n\r\n**비동기**\r\n\r\n함수 1을 호출하고 결과를 확인하지 않고 함수 2를 호출한다면 비동기\r\n\r\n## 비동기 == 논블로킹??\r\n\r\n일반적으로 동기와 블로킹, 비동기와 논블로킹이 연관되어 쓰이기 때문에 이 개념을 혼동할 수 있다.\r\n\r\n비동기와 논블로킹의 차이:\r\n\r\n```jsx\r\n\r\nconsole.log(\"시작\");\r\n\r\nsetTimeout(() => {\r\n\r\n  console.log(\"1초 후에 실행됩니다!\");\r\n\r\n}, 1000);\r\n\r\nconsole.log(\"끝\");\r\n\r\n// 결과\r\n\r\n// 시작\r\n\r\n// 끝\r\n\r\n// 1초 후에 실행됩니다!\r\n\r\n```\r\n\r\n자바스크립트의 `setTimeout()`를 예로 들면 이는 비동기, 논블로킹 함수이다.\r\n\r\n`setTimeout()`의 결과가 제일 늦게 나온다. 순서의 관점 ⇒ 비동기\r\n\r\n함수는 타이머 작업을 수행하기 위해 함수를 block하지 않고 백그라운드에서 별도로 처리 ⇒ 논블로킹\r\n\r\n## 크로스오버 예시\r\n\r\n[[Blocking-NonBlocking-Synchronous-Asynchronous - 뒤태지존의 끄적거림 (homoefficio.github.io)](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)](https://camo.githubusercontent.com/b7b28ae739c50d5ed8a4594f52f24e671aeeae234befd0991e5230561ba303bf/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d6874747073253341253246253246626c6f672e6b616b616f63646e2e6e6574253246646e25324664613530597a2532466274713044736a65345a562532466c47653848386e5a676442646746766f3749637a5330253246696d672e706e67)\r\n\r\n[Blocking-NonBlocking-Synchronous-Asynchronous - 뒤태지존의 끄적거림 (homoefficio.github.io)](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)\r\n\r\n두 명의 요리사가 피자, 파스타를 만들어 파는 레스토랑 예시\r\n\r\n- 동기 - 블로킹\r\n\r\n두 요리사는 각각 피자 또는 파스타 요리를 담당하고 있다. 이들이 요리할 때 반드시 순차적으로 처리해야 하는 부분이 있다. 가령 도우 반죽이 완성되어야 반죽을 오븐에 구울 수 있다. 요리사는 도우 반죽이 완성될 때까지 밀대를 놓을 수 없으며(블로킹), 반죽이 다 된 것을 확인한 후에 오븐에 넣을 수 있다(동기).\r\n\r\n- 동기 - 논블로킹\r\n\r\n피자 담당 요리사는 오븐에서 도우가 다 구워진 것을 확인한 다음, 꺼내서 토핑을 얹을 수 있다(동기). 하지만 그동안 다른 일을 할 수 없는 것은 아니다. 요리사는 주기적으로 남은 오븐 시간을 확인하고, 완료되지 않았다면 그동안 토핑을 만들 수 있다(논블로킹). 마침내 시간이 되어 도우가 구워졌다면 꺼내어 토핑을 얹는다.\r\n\r\n- 비동기 - 논블로킹\r\n\r\n피자 담당 요리사와 파스타 담당 요리사는 각자 맡은 요리만 할 뿐, 서로의 요리 과정에는 별 관심이 없다. 각자가 어떤 단계를 수행하고 있는지 확인하지 않고(비동기), 서로의 작업을 방해하지도 않는다(논블로킹). 다만 두 요리가 함께 나가야 한다면, 먼저 완성된 요리와 나중에 완성된 요리를 모아줄 주체가 필요하다.\r\n\r\n- 비동기 - 블로킹\r\n\r\n비동기와 블로킹은 특수한 상황으로 볼 수 있다. 피자 요리사와 파스타 요리사는 서로의 작업에 대해 확인할 필요가 없지만, 모종의 이유로 작업을 번갈아서 수행한다. 피자 요리사가 도우를 반죽하는 동안 파스타 요리사는 쉬고, 파스타 요리사가 면을 삶는 동안 피자 요리사는 쉬는 것이다.\r\n\r\n---\r\n\r\n",
        "qna": "## 정리\r\n\r\n\r\n\r\n### Q. 동기와 비동기, 블로킹과 논블로킹의 차이점은?\r\n\r\n**동기 / 비동기**\r\n\r\n작업을 수행하는 시점과 관련있다.\r\n\r\n- 동기: 요청한 작업에 대해 완료 여부를 따져 순차대로 처리하는 것\r\n\r\n- 비동기: 요청한 작업에 대해 완료 여부를 따지지 않고 다음 작업 수행\r\n\r\n**블로킹 / 논블로킹**\r\n\r\n호출자와 피호출자의 제어권과 관련있다.\r\n\r\n- 블로킹: 요청받은 함수가 작업을 완료하면 요청자에게 제어권이 이동(요청한 작업을 마칠 때까지 기다려야한다.)\r\n\r\n- 논블로킹: 요청받은 함수가 요청자에게 제어권을 바로 넘겨줌(요청한 작업을 즉시 마칠 수 없으면 바로 return)\r\n\r\n- Reference\r\n\r\n    \r\n\r\n    [👩‍💻 완벽히 이해하는 동기/비동기 & 블로킹/논블로킹 (tistory.com)](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC#%EB%8F%99%EA%B8%B0/%EB%B9%84%EB%8F%99%EA%B8%B0_+_%EB%B8%94%EB%A1%9C%ED%82%B9/%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9_%EC%A1%B0%ED%95%A9)\r\n\r\n    \r\n\r\n    [주니어 웹 개발자가 알아야 할 ‘비동기 통신’ | 요즘IT (wishket.com)](https://yozm.wishket.com/magazine/detail/1982/)\r\n\r\n    \r\n\r\n    [[10분 테코톡] 🐰 멍토의 Blocking vs Non-Blocking, Sync vs Async - YouTube](https://www.youtube.com/watch?v=oEIoqGd-Sns&t=259s)\r\n\r\n    \r\n\r\n    [백엔드 개발자들이 알아야할 동시성 2 — 블로킹과 논블로킹, 동기와 비동기 | by Choi Geonu | Medium](https://choi-geonu.medium.com/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EB%8F%99%EC%8B%9C%EC%84%B1-2-%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-e11b3d01fdf8)\r\n\r\n    \r\n\r\n    [Blocking-NonBlocking-Synchronous-Asynchronous - 뒤태지존의 끄적거림 (homoefficio.github.io)](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)\r\n\r\n    \r\n\r\n    [블로킹(Blocking)/논블로킹(Non-Blocking), 동기(Sync)/비동기(Async) 구분하기 (tistory.com)](https://joooing.tistory.com/entry/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9)\r\n\r\n    \r\n\r\n    [블로킹 Vs. 논블로킹, 동기 Vs. 비동기 (velog.io)](https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0)\r\n\r\n    \r\n\r\n    [동기-비동기, 블로킹-논블로킹, 대체 차이가 뭐에요? (velog.io)](https://velog.io/@ohzzi/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8C%80%EC%B2%B4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%AD%90%EC%97%90%EC%9A%94)\""
      },
      {
        "id": "21",
        "title": "CS",
        "topic": "Linked List와 Array",
        "texture": "# Linked List와 Array\r\n\r\n\r\n\r\n선형 자료구조의 배열과 연결 리스트 비교.\r\n\r\n\r\n\r\n<aside>\r\n\r\n💡 **자바스크립트의 배열과 다른 점**\r\n\r\n자바스크립트의 배열은 인덱스를 키로 갖고, length 프로퍼티를 가지고 있는 일반적인 배열을 흉내 낸 특수한 객체이다.\r\n\r\n****\r\n\r\n자바스크립트의 배열은 메모리 공간의 크기가 다르고, 연속적으로 이어져 있지 않는 희소 배열이다.\r\n\r\n자료구조에서 말하는 배열은 같은 데이터 타입과 동일한 크기의 메모리 공간이 연속적으로 나열된 자료구조(밀집 배열)를 말한다.\r\n\r\n\r\n\r\n</aside>\r\n\r\n\r\n\r\n## Array (배열)\r\n\r\n\r\n\r\n데이터 타입과 크기가 정해져 있고, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합이다.\r\n\r\n\r\n\r\n인덱스가 있어 랜덤(직접) 접근이 가능하다.\r\n\r\n\r\n\r\n데이터의 크기는 정해져 있기 때문에 생성 후 변경할 수 없다.\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so//image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F22b0756a-c5c8-4d51-b2f4-2f2f6003b924%2FUntitled.png?table=block&id=32546754-ed15-49a5-8da5-33b1aea9825b&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=&cache=v2)\r\n\r\n\r\n\r\n## Linked List (연결 리스트)\r\n\r\n\r\n\r\n각 노드의 데이터가 포인터로 연결되어 있는 선형 자료구조.\r\n\r\n\r\n\r\n인덱스가 존재하지 않아 랜덤 접근이 불가능하다.\r\n\r\n\r\n\r\n노드: 데이터와 포인터로 구성\r\n\r\n\r\n\r\nhead 노드: 맨 앞에 있는 노드\r\n\r\n\r\n\r\n포인터: 메모리 주소를 가리키는 변수, 다른 노드의 위치 정보\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffe282cb0-ba2a-4219-9bc6-b0cec32fcd86%2FUntitled.png?table=block&id=9b0ca961-11fa-45b8-978c-9df74ab17e27&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=&cache=v2)\r\n\r\n\r\n\r\n단일 연결 리스트: 각 노드에 자료 공간과 next 포인터 한 개만 가진다.\r\n\r\n\r\n\r\n이중 연결 리스트: 포인터 공간이 두 개 있고 next, prev 포인터를 가진다.\r\n\r\n\r\n\r\n원형 연결 리스트: 단일 연결 리스트에서 마지막 노드의 next 포인터가 헤드 노드를 가리킨다.\r\n\r\n\r\n\r\n- 자바스크립트에서 Linked List 구현\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    class Node {\r\n\r\n      constructor(value) {\r\n\r\n        this.value = value;\r\n\r\n        this.next = null;\r\n\r\n      }\r\n\r\n    }\r\n\r\n    \r\n\r\n    class LinkedList {\r\n\r\n      constructor() {\r\n\r\n        this.head = null;\r\n\r\n        this.tail = null;\r\n\r\n      }\r\n\r\n    \r\n\r\n      // 맨 끝에 노드 추가\r\n\r\n      append(value) {\r\n\r\n        const newNode = new Node(value);\r\n\r\n    \r\n\r\n        if (!this.head) {\r\n\r\n          // 리스트가 비어있을 경우\r\n\r\n          this.head = newNode;\r\n\r\n          this.tail = newNode;\r\n\r\n        } else {\r\n\r\n          // 이미 노드가 있는 경우\r\n\r\n          this.tail.next = newNode;\r\n\r\n          this.tail = newNode;\r\n\r\n        }\r\n\r\n      }\r\n\r\n    \r\n\r\n      // 특정 위치에 노드 삽입\r\n\r\n      insertAt(index, value) {\r\n\r\n        if (index === 0) {\r\n\r\n          // 리스트의 맨 앞에 삽입하는 경우\r\n\r\n          const newNode = new Node(value);\r\n\r\n          newNode.next = this.head;\r\n\r\n          this.head = newNode;\r\n\r\n          if (!this.tail) {\r\n\r\n            // 리스트가 비어있을 경우\r\n\r\n            this.tail = newNode;\r\n\r\n          }\r\n\r\n        } else {\r\n\r\n          let currentNode = this.head;\r\n\r\n          let currentIndex = 0;\r\n\r\n          while (currentNode && currentIndex < index - 1) {\r\n\r\n            currentNode = currentNode.next;\r\n\r\n            currentIndex++;\r\n\r\n          }\r\n\r\n          if (!currentNode) {\r\n\r\n            // 인덱스가 리스트의 길이보다 큰 경우\r\n\r\n            this.append(value);\r\n\r\n          } else {\r\n\r\n            const newNode = new Node(value);\r\n\r\n            newNode.next = currentNode.next;\r\n\r\n            currentNode.next = newNode;\r\n\r\n            if (currentNode === this.tail) {\r\n\r\n              // 리스트의 맨 끝에 삽입하는 경우\r\n\r\n              this.tail = newNode;\r\n\r\n            }\r\n\r\n          }\r\n\r\n        }\r\n\r\n      }\r\n\r\n    \r\n\r\n      // 특정 위치의 노드 삭제\r\n\r\n      removeAt(index) {\r\n\r\n        if (!this.head) {\r\n\r\n          // 리스트가 비어있는 경우\r\n\r\n          return;\r\n\r\n        }\r\n\r\n    \r\n\r\n        let currentNode = this.head;\r\n\r\n        let previousNode = null;\r\n\r\n        let currentIndex = 0;\r\n\r\n    \r\n\r\n        if (index === 0) {\r\n\r\n          // 리스트의 맨 앞 노드 삭제\r\n\r\n          this.head = currentNode.next;\r\n\r\n          if (currentNode === this.tail) {\r\n\r\n            // 리스트에 노드가 하나만 남아있는 경우\r\n\r\n            this.tail = null;\r\n\r\n          }\r\n\r\n        } else {\r\n\r\n          while (currentNode && currentIndex < index) {\r\n\r\n            previousNode = currentNode;\r\n\r\n            currentNode = currentNode.next;\r\n\r\n            currentIndex++;\r\n\r\n          }\r\n\r\n    \r\n\r\n          if (!currentNode) {\r\n\r\n            // 인덱스가 리스트의 길이보다 큰 경우\r\n\r\n            return;\r\n\r\n          }\r\n\r\n    \r\n\r\n          previousNode.next = currentNode.next;\r\n\r\n    \r\n\r\n          if (currentNode === this.tail) {\r\n\r\n            // 리스트의 맨 끝 노드 삭제\r\n\r\n            this.tail = previousNode;\r\n\r\n          }\r\n\r\n        }\r\n\r\n      }\r\n\r\n    \r\n\r\n      // 리스트 출력\r\n\r\n      print() {\r\n\r\n        let currentNode = this.head;\r\n\r\n        const values = [];\r\n\r\n        while (currentNode) {\r\n\r\n          values.push(currentNode.value);\r\n\r\n          currentNode = currentNode.next;\r\n\r\n        }\r\n\r\n        console.log(values.join(\" -> \"));\r\n\r\n      }\r\n\r\n    }\r\n\r\n    \r\n\r\n    // LinkedList 사용 예시\r\n\r\n    const linkedList = new LinkedList();\r\n\r\n    linkedList.append(1);\r\n\r\n    linkedList.append(2);\r\n\r\n    linkedList.append(3);\r\n\r\n    linkedList.print(); // 출력: 1 -> 2 -> 3\r\n\r\n    \r\n\r\n    linkedList.insertAt(1, 4);\r\n\r\n    linkedList.print(); // 출력: 1 -> 4 -> 2 ->\r\n\r\n    ```\r\n\r\n    \r\n\r\n\r\n\r\n## 배열과 연결 리스트 비교\r\n\r\n\r\n\r\n### 접근\r\n\r\n\r\n\r\n배열은 랜덤 접근이 가능하지만 연결 리스트는 불가능하기 때문에 어떤 요소에 접근하기 위해서는 반드시 첫 번째 요소부터 접근해야 한다.\r\n\r\n\r\n\r\n따라서 접근을 할 때, 배열은 배열의 크기와 상관 없이 동일한 시간이 걸리지만, 연결 리스트는 배열의 크기에 따라 커지게 된다.\r\n\r\n\r\n\r\n### 삽입/삭제\r\n\r\n\r\n\r\n배열은 마지막 요소면 삽입, 삭제 만으로 끝나지만 마지막 요소가 아니라면 해당 요소 뒤의 요소들을 한 칸씩 옮겨야 한다.\r\n\r\n연결 리스트는 첫 번째 요소라면 다음 요소만 연결해 주면 끝나지만 그 이후의 요소라면 순차적으로 탐색하는 시간이 걸린다.\r\n\r\n\r\n\r\n### 메모리\r\n\r\n\r\n\r\n연결 리스트는 데이터 외에도 포인터를 저장할 공간이 필요하기 때문에 더 많은 메모리가 필요하다.\r\n\r\n\r\n\r\n> **시간 복잡도:** 문제를 해결하는데 걸리는 시간과 입력 함수 관계를 나타내는 척도. 주로 빅-오 표기법을 사용해 나타낸다.\r\n\r\n> \r\n\r\n> \r\n\r\n> 빅 오(Big O) 표기법: 계수와 낮은 차수의 항을 제외시키는 방법. \r\n\r\n> \r\n\r\n> ex) 입력의 크기가 n일 때 걸리는 시간이 $O(2n^2 + 2n)$인 경우 $O(n^2)$로 표기\r\n\r\n> \r\n\r\n> ![Untitled](https://www.notion.so//image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb89cdf69-3e2d-4409-915a-e7def4fc63ff%2FUntitled.png?table=block&id=107e525c-7f9e-48f4-b391-0a5d0107fdb6&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=&cache=v2)\r\n\r\n> \r\n\r\n> |  | 접근 | 첫 요소 삽입/삭제 | 중간 요소 삽입/삭제 | 마지막 요소 삽입/삭제 |\r\n\r\n> | --- | --- | --- | --- | --- |\r\n\r\n> | Linked List | O(n) | O(1) | O(n) / search time + O(1) | O(n) |\r\n\r\n> | Array | O(1) | O(n)  | O(n)  | O(1)  |\r\n\r\n\r\n\r\n일반적으로 접근이 잦은 작업이라면 Array, 삽입/삭제가 많은 작업이라면 Linked List를 사용하는 것이 좋다.\r\n\r\n\r\n\r\n",
        "qna": "## 정리\r\n\r\n\r\n\r\n### Q. 연결 리스트와 배열의 차이점은?\r\n\r\n\r\n\r\n|  | Linked List | Array |\r\n\r\n| --- | --- | --- |\r\n\r\n| 접근 | 순차적으로 접근하기 때문에 느림 | 임의로 접근 가능하기 때문에 빠름 |\r\n\r\n| 삽입/삭제 | 요소를 찾아서 연결만 바꿔주면 되기 때문에 빠름 | 삽입/삭제 위치 이후 요소들을 한 칸씩 이동해야하기 때문에 느림 |\r\n\r\n| 메모리 | 연속적으로 배치되지 않기 때문에 포인터 공간과 데이터 공간을 모두 사용해야 하므로 비효율적 | 연속적으로 배치되므로 효율적 |\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n- Reference\r\n\r\n    - 면접을 위한 CS 전공지식 노트\r\n\r\n    - 모던 자바스크립트 딥 다이브\r\n\r\n    - [Difference between Linked List and Arrays (faceprep.in)](https://www.faceprep.in/data-structures/linked-list-vs-array/)\r\n\r\n    - [Interview_Question_for_Beginner/DataStructure at master · JaeYeopHan/Interview_Question_for_Beginner (github.com)](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#array-vs-linked-list)\r\n\r\n    - [Array 배열 기초개념? 10분안에 정리해줌! - YouTube](https://www.youtube.com/watch?v=NFETSCJON2M)\r\n\r\n    - [연결리스트(Linked List)와 배열(Array), 그리고 시간복잡도의 차이에 대해 : 네이버 블로그 (naver.com)](https://m.blog.naver.com/raylee00/221944085465)"
      },
      {
        "id": "22",
        "title": "React",
        "topic": "CSR과 SSR",
        "texture": "**SPA(Single Page Application)**\r\n\r\n\r\n\r\n하나의 페이지로 구성된 웹 애플리케이션으로 자바스크립트를 이용해 동적으로 화면의 컨텐츠를 바꾼다.\r\n\r\n\r\n\r\n**MPA(Multi Page Application)**\r\n\r\n\r\n\r\n전통적인 방식으로 다른 경로를 이동할 때마다 서버로부터 새로운 HTML파일을 받아와 렌더링한다.\r\n\r\n\r\n\r\n일반적으로 SPA는 CSR방식을, MPA는 SSR방식으로 렌더링 한다. \r\n\r\n\r\n\r\n SPA, MPA는 페이지의 수를 말하는 것이고, CSR, SSR은 렌더링을 어디에서 하냐는 것이다.\r\n\r\n\r\n\r\n## CSR\r\n\r\n\r\n\r\n### 동작 과정\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F56e4dd20-f47e-44cf-a9cb-85710fa8756e%2FUntitled.png?table=block&id=e0c320c0-648f-460c-8f8b-c9a42aa9a5d1&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1130&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n1. 브라우저가 서버에 컨텐츠 요청\r\n\r\n2. 서버는 뼈대만 있는 HTML파일을 응답\r\n\r\n3. 브라우저가 연결된 링크로 자바스크립트 파일 다운로드\r\n\r\n4. 자바스크립트 파일로 동적으로 페이지를 생성해 보여준다.\r\n\r\n\r\n\r\n### 장점\r\n\r\n\r\n\r\n- 초기 로딩 이후에 구동 속도가 빠르다.\r\n\r\n- HTML을 생성하지 않고 파일만 넘겨주기 때문에 서버의 부하가 적다.\r\n\r\n- 전체 페이지가 다시 로드되지 않기 때문에 화면 깜빡임이 없다.\r\n\r\n- 자바스크립트 파일이 다운로드되고 실행돼야 페이지가 보이기 시작하기 때문에 TTV와 TTI가 같다.\r\n\r\n\r\n\r\n<aside>\r\n\r\n💡 TTV, TTI\r\n\r\nTTV(Time To View): 페이지가 로드되어 보이기 시작하는 시점.\r\n\r\nTTI(Time To Interactive): 페이지가 사용자와 상호작용 할 수 있는 상태가 되는 시점.\r\n\r\n\r\n\r\n</aside>\r\n\r\n\r\n\r\n### 단점\r\n\r\n\r\n\r\n- 자바스크립트 파일은 앱에서 필요한 로직 뿐만 아니라 앱을 구동하는 코드도 포함하기 때문에 크기가 크기 때문에 초기 로딩 속도가 느리다.\r\n\r\n- 웹 크롤러는 HTML을 기반으로 검색하기 때문에 SEO에 불리하다. CSR도 크롤링이 가능하지만 여전히 SSR보다는 좋지 않다.\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5e294f5a-9bc4-499d-8cd3-4c4d8dc39e14%2FUntitled.png?table=block&id=247a1420-a338-42ca-b044-ee76c1a6bd33&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n## SSR\r\n\r\n\r\n\r\n### 동작 과정\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5e294f5a-9bc4-499d-8cd3-4c4d8dc39e14%2FUntitled.png?table=block&id=247a1420-a338-42ca-b044-ee76c1a6bd33&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n1. 브라우저가 서버에 컨텐츠 요청\r\n\r\n2. 서버에서 필요한 데이터를 가져와 HTML생성 후 JS파일과 함께 응답\r\n\r\n3. 브라우저는 전달 받은 페이지를 보여준다.\r\n\r\n\r\n\r\n### 장점\r\n\r\n\r\n\r\n- 첫 번째 페이지 로딩이 빠르다.\r\n\r\n- 모든 컨텐츠가 HTML에 담긴채로 브라우저에 전달하기 때문에 SEO에 유리하다.\r\n\r\n\r\n\r\n### 단점\r\n\r\n\r\n\r\n- 페이지 이동 시 html 파일을 서버에서 다시 받아오기 때문에 깜빡이는 현상이 발생한다.\r\n\r\n- 서버에 걸리는 부하가 크다.\r\n\r\n- HTML은 다운로드가 되어 빠르게 볼 수 있지만 자바스크립트가 다운로드 되기까지 반응이 없는 경우가 발생할 수 있다. (TTV와 TTI의 간극이 있다.)\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F79daa224-9e82-40d5-a69d-7109b898494a%2FUntitled.png?table=block&id=c6a1bd44-efdd-4c8c-9d31-6113d7730061&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n### SSG (Static Site Generation)\r\n\r\n\r\n\r\nSSR은 클라이언트의 요청에 대해 HTML을 동적으로 생성해서 전달하지만, SSG는 미리 만들어둔 다음에 준다. 때문에 페이지의 내용이 거의 바뀌지 않는 경우에 적합하다.\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n",
        "qna": "## 정리\r\n\r\n\r\n\r\n### Q. 클라이언트 사이드 렌더링(CSR)과 서버 사이드 렌더링(SSR)의 차이는?\r\n\r\n\r\n\r\n|  | CSR | SSR |\r\n\r\n| --- | --- | --- |\r\n\r\n| 장점 | 화면 깜빡임이 없다.\r\n\r\n초기 로딩 이후 구동 속도 빠름\r\n\r\nTTV와 TTI가 같다.\r\n\r\n서버 부하 분산 | 초기 구동 속도가 빠름\r\n\r\nSEO에 유리하다 |\r\n\r\n| 단점 | 초기 로딩 속도 느림\r\n\r\nSEO에 불리함 | 페이지 이동시 화면 깜빡임 있음\r\n\r\nTTV와 TTI 사이 간극이 있다\r\n\r\n서버 부하가 있다. |\r\n\r\n\r\n\r\n- **Reference**"
      },
      {
        "id": "23",
        "title": "CS",
        "topic": "디자인 패턴",
        "texture": "### 디자인 패턴\r\n\r\n\r\n\r\n디자인 패턴이란 소프트웨어 개발에서 자주 발생하는 문제들에 대한 재사용 가능한 해결책이다.\r\n\r\n\r\n\r\n디자인 패턴은 구체적인 구현 방법이 아니라 일종의 설계 원칙이므로, 다양한 프로그래밍 언어와 도구에 적용할 수 있다.\r\n\r\n\r\n\r\n**디자인 패턴이 필요한 이유**\r\n\r\n\r\n\r\n- 소프트웨어 디자인의 일반적인 문제들에 대해 시도되고 검증된 해결책을 모은 것이다.\r\n\r\n이런 문제를 다루지 않더라고 객체 지향 디자인 원칙들을 사용해 많은 종류의 문제를 해결하는 방법을 배울 수 있다.\r\n\r\n- 팀원과 더 효율적으로 의사소통 할 수 있는 공통 언어를 정의한다.\r\n\r\n예를 들어 팀의 모두가 디자인 패턴을 이해하면 ‘그 문제를 위해서는 싱글턴을 사용하세요’ 라고 말하면 무엇을 뜻하는지 이해할 수 있고 설명할 필요도 없다.\r\n\r\n\r\n\r\n### GoF 디자인 패턴의 종류\r\n\r\n\r\n\r\n- 생성 패턴\r\n\r\n    - 기존 코드의 재활용과 유연성을 증가시키는 객체 생성 매커니즘들을 제공한다.\r\n\r\n- 구조 패턴\r\n\r\n    - 구조를 유연하고 효율적으로 유지하면서 객체와 클래스를 더 큰 구조로 조합하는 방법을 설명한다.\r\n\r\n- 행동 패턴\r\n\r\n    - 객체 간의 효과적인 의사소통과 책임 할당을 처리한다.\r\n\r\n\r\n\r\n| 생성 패턴 | 구조 패턴 | 행동 패턴 |\r\n\r\n| --- | --- | --- |\r\n\r\n| - 추상 팩토리 (Abstract Factory)\r\n\r\n- 빌더 (Builder)\r\n\r\n- 팩토리 메서드 (Factory Method)\r\n\r\n- 프로토타입 (Prototype)\r\n\r\n- 싱글톤 (Singleton) | - 어댑터 (Adapter)\r\n\r\n- 브리지 (Bridge)\r\n\r\n- 복합체 (Composite)\r\n\r\n- 데코레이터 (Decorator)\r\n\r\n- 퍼사드 (Facade)\r\n\r\n- 플라이웨이트 (Flyweight)\r\n\r\n- 프록시 (Proxy) | - 책임 연쇄 (Chain of Responsibility)\r\n\r\n- 커맨드 (Command)\r\n\r\n- 인터프리터 (Interpreter)\r\n\r\n- 이터레이터 (Iterator)\r\n\r\n- 미디에이터 (Mediator)\r\n\r\n- 메멘토 (Memento)\r\n\r\n- 옵저버 (Observer)\r\n\r\n- 상태 (State)\r\n\r\n- 전략 (Strategy)\r\n\r\n- 템플릿 메서드 (Template Method)\r\n\r\n- 방문자 (Visitor) |\r\n\r\n\r\n\r\n**예시)** **싱글톤 패턴**\r\n\r\n\r\n\r\n하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴이다. \r\n\r\n\r\n\r\n주로 DB연결 모듈에 많이 사용된다.\r\n\r\n\r\n\r\n```jsx\r\n\r\nclass Singleton {\r\n\r\n  constructor() {\r\n\r\n    if (!Singleton.instance) {\r\n\r\n      Singleton.instance = this;\r\n\r\n    }\r\n\r\n    return Singleton.instance;\r\n\r\n  }\r\n\r\n\r\n\r\n  getInstance() {\r\n\r\n    return this.instance;\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\nconst a = new Singleton();\r\n\r\nconst b = new Singleton();\r\n\r\nconsole.log(a === b);\r\n\r\n```\r\n\r\n\r\n\r\n장점: \r\n\r\n\r\n\r\n- 반복적인 인스턴스 생성을 피하고 생성된 인스턴스를 재사용함으로써 메모리 공간을 절약할 수 있다.\r\n\r\n- 인스턴스에 대한 전역 접근 지점을 얻는다.\r\n\r\n\r\n\r\n단점:\r\n\r\n\r\n\r\n- 독립적인 인스턴스를 만들기 어렵기 때문에 단위 테스트가 어렵다.\r\n\r\n\r\n\r\n",
        "qna": "## 정리\r\n\r\n\r\n\r\n### Q. 디자인 패턴이란?\r\n\r\n\r\n\r\n소프트웨어 개발에서 자주 발생하는 문제들에 대한 재사용 가능한 해결책으로 재사용성, 호환성, 유지보수성을 위해 사용한다.\r\n\r\n\r\n\r\n객체의 생성방식을 결정하는 생성 패턴, 객체간의 관계를 조직하는 구조 패턴, 객체의 행위를 관리하는 행위 패턴으로 분류할 수 있다.\r\n\r\n\r\n\r\n- Reference\r\n\r\n    - 면접을 위한 CS 전공지식 노트\r\n\r\n    - [디자인 패턴들 (refactoring.guru)](https://refactoring.guru/ko/design-patterns)\r\n\r\n    - [개발자가 알아야할 디자인패턴 | ep1. Singleton Pattern | 자바스크립트 싱글톤 패턴 - YouTube](https://www.youtube.com/watch?v=M4q3sY81gR8&list=PL3xNAKVIm80JldJ6IZBx5eQxck5JA6VuV)\r\n\r\n    - [Singleton 패턴 | Patterns.dev.kr - 모던 웹 앱 디자인 패턴 (patterns-dev-kr.github.io)](https://patterns-dev-kr.github.io/design-patterns/singleton-pattern/)\r\n\r\n\r\n\r\n더 공부하면 좋을 내용: [프론트엔드에서 MV* 아키텍쳐란 무엇인가요? (velog.io)](https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94#%EA%B3%A0%EC%A0%84-%EC%A4%91%EC%9D%98-%EA%B3%A0%EC%A0%84-mvc-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98)"
      },
      {
        "id": "24",
        "title": "CS",
        "topic": "CORS",
        "texture": "## SOP\r\n\r\n\r\n\r\nSOP(Same-Origin Policy, 동일 출처 정책)\r\n\r\n\r\n\r\n어떤 출처에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 보안 방식이다. 동일 출처 정책은 잠재적으로 해로울 수 있는 문서를 분리함으로써 공격받을 수 있는 경로를 줄여준다.\r\n\r\n\r\n\r\n**Origin(출처)란?**\r\n\r\nOrigin = Protocol + Host + Port(명시한 경우)\r\n\r\n\r\n\r\n![URL 구조](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fc69962b0-3951-485b-b10a-5bb29576bba8%2F27087fe0-dc9e-42e9-971a-01f0874288c0%2FUntitled.png?table=block&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&id=35514320-4eab-46ae-82ad-49633f4120c0&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\nURL 구조\r\n\r\n\r\n\r\n예시) `http://store.company.com/dir/page.html`와 출처 비교\r\n\r\n\r\n\r\n| URL | 결과 | 이유 |\r\n\r\n| --- | --- | --- |\r\n\r\n| http://store.company.com/dir2/other.html | 성공 | 경로만 다름 |\r\n\r\n| http://store.company.com/dir/inner/another.html | 성공 | 경로만 다름 |\r\n\r\n| https://store.company.com/secure.html | 실패 | 프로토콜 다름 |\r\n\r\n| http://store.company.com:81/dir/etc.html | 실패 | 포트 다름 (http://는 80이 기본값) |\r\n\r\n| http://news.company.com/dir/other.html | 실패 | 호스트 다름 |\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbb10b935-5b57-46dd-b3eb-f4fe7aee0d64%2FUntitled.png?table=block&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&id=59d93e45-fc67-464c-8cf0-e486e5ad3e7c&width=1850&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n웹에서는 다른 출처에 있는 리소스를 사용하는 일이 굉장히 흔한 일이기 때문에 몇 가지 예외 조항을 두고 이 조항에 해당 리소스 요청은 출처가 다르더라도 허용하기로 했는데, 그중 하나가 CORS 정책을 지킨 리소스 요청이다.\r\n\r\n\r\n\r\n## CORS\r\n\r\n\r\n\r\nCORS(Cross-Origin Resource Sharing, 교차 출처 리소스 공유)\r\n\r\n\r\n\r\n교차 출처란 다른 출처를 의미한다.\r\n\r\n\r\n\r\nHTTP 헤더를 사용해, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제이다.\r\n\r\n\r\n\r\n### **동작 방식**\r\n\r\n\r\n\r\n1. **Preflight Request**\r\n\r\n    \r\n\r\n    프리플라이트 방식은 웹 개발시 가장 많이 마주치는 시나리오이다.\r\n\r\n    \r\n\r\n    브라우저는 요청을 한번에 보내지 않고 예비 요청과 본 요청으로 나눠 서버로 전송한다.\r\n\r\n    \r\n\r\n    이때 본 요청을 보내기 전에 보내는 예비요청을 Preflight라고 하며, 이 요청에는 HTTP의 `OPTIONS`메소드가 사용된다.\r\n\r\n    \r\n\r\n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fc69962b0-3951-485b-b10a-5bb29576bba8%2F51b5d872-11ca-45e5-90fa-872bcba3dca5%2FUntitled.png?table=block&id=f8b09407-fcf6-4be8-b111-b89890a2760d&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1280&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n    \r\n\r\n    브라우저가 서버에 예비 요청을 먼저 보내고, 서버는 응답으로 자신이 어떤 것을 허용하고 있는지에 대한 정보를 응답 헤더에 담아 브라우저에 다시 보내준다.\r\n\r\n    \r\n\r\n    브라우저는 예비 요청과 서버가 보낸 응답의 허용 정책을 비교한 후 요청을 보내는 것이 안전하다고 판단되면 다시 본 요청을 보낸다.\r\n\r\n    \r\n\r\n2. **Simple Request**\r\n\r\n    \r\n\r\n    단순 요청은 예비 요청을 보내지 않고 바로 서버에게 요청한다. 서버가 응답으로 헤더에 `Access-Control-Allow-Origin`헤더를 전송하면 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다.\r\n\r\n    \r\n\r\n    - 단순 요청은 아래 조건을 **모두** 만족해야 사용할 수 있다.\r\n\r\n        \r\n\r\n        > 다음 중 하나의 메서드\r\n\r\n        > \r\n\r\n        > - `GET`\r\n\r\n        > - `HEAD`\r\n\r\n        > - `POST`\r\n\r\n        > \r\n\r\n        > 유저 에이전트가 자동으로 설정 한 헤더\r\n\r\n        > \r\n\r\n        > - `Accept`\r\n\r\n        > - `Accept-Language`\r\n\r\n        > - `Content-Language`\r\n\r\n        > - `Content-Type` (아래의 추가 요구 사항에 유의하세요.)\r\n\r\n        > \r\n\r\n        > `Content-Type` 헤더는 다음의 값들만 허용됩니다.\r\n\r\n        > \r\n\r\n        > - `application/x-www-form-urlencoded`\r\n\r\n        > - `multipart/form-data`\r\n\r\n        > - `text/plain`\r\n\r\n        > - 요청에 사용된 `XMLHttpRequestUpload` 객체에는 이벤트 리스너가 등록되어 있지 않습니다. 이들은 `XMLHttpRequest.upload` 프로퍼티를 사용하여 접근합니다..\r\n\r\n        > - 요청에 `ReadableStream` 객체가 사용되지 않습니다.\r\n\r\n    \r\n\r\n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fc69962b0-3951-485b-b10a-5bb29576bba8%2Fc9d7b2ab-1790-415b-a179-52392e298685%2FUntitled.png?table=block&id=d27bb389-c32c-4f6e-a362-786b37ef6a2e&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1280&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n    \r\n\r\n3. **Credentialed Request**\r\n\r\n\r\n\r\n인증된 요청은 다른 출처 간 통신에서 보안을 강화하고 싶을 때 사용한다.\r\n\r\n\r\n\r\n기본적으로 다른 출처에 대한 요청은 자격 증명(쿠키, 인증 관련 헤더)을 보내지 않는다.\r\n\r\n\r\n\r\ncredential 옵션을 통해 요청에 인증과 관련된 정보를 담을 수 있다.\r\n\r\n\r\n\r\n인증된 요청에서는 `Access-Control-Allow-Origin`에 모든 출처를 허용하는 *(와일드 카드)를 지정할 수 없고 명시적인 URL이어야 한다.\r\n\r\n\r\n\r\n응답 헤더에는 반드시 `Access-Control-Allow-Credentials: true`가 있어야 한다.\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n",
        "qna": "## 정리\r\n\r\n\r\n\r\n### Q1. SOP란?\r\n\r\n\r\n\r\n동일 출처 정책은 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 중요한 보안 방식이다. 악의를 가진 모방 사이트를 제지하기 위해 필요한 제약사항이다.\r\n\r\n\r\n\r\n출처란 프로토콜, 호스트, 포트를 포함한 것을 의미한다.\r\n\r\n\r\n\r\n### Q2. CORS에러가 무엇이고 해결하는 방법은?\r\n\r\n\r\n\r\nSOP를 지키기 위해서 나온 에러고, 그 에러를 해결하기 위해서는 서버에서 CORS 설정을 해주는 것이다. Simple request가 아니라면 예비 요청을 한 번 더 요청하게 된다. 민감한 인증 정보같은 경우는 `Access-Control-Allow-Credentials`를 true로 설정해줘야 하고 이 때 *(와일드카드)를 넣으면 에러가 발생한다.\r\n\r\n\r\n\r\n- - Reference\r\n\r\n  \r\n\r\n  [CORS는 왜 이렇게 우리를 힘들게 하는걸까? | Evans Library (evan-moon.github.io)](https://evan-moon.github.io/2020/05/21/about-cors/)\r\n\r\n  \r\n\r\n  [교차 출처 리소스 공유 (CORS) - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/HTTP/CORS)\r\n\r\n  \r\n\r\n  [동일 출처 정책 - 웹 보안 | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/Security/Same-origin_policy)\r\n\r\n  \r\n\r\n  [웹개발 짜증유발자! CORS가 뭔가요? - YouTube](https://www.youtube.com/watch?v=bW31xiNB8Nc)\r\n\r\n  \r\n\r\n  [CORS - YouTube](https://www.youtube.com/watch?v=j2Q2Ev6CZzQ)"
      },
      {
        "id": "25",
        "title": "CS",
        "topic": "렌더링 과정 - 브라우저는 어떻게 화면을 렌더링할까?",
        "texture": "HTML, CSS, 자바스크립트로 작성된 텍스트 문서를 **어떻게 파싱(해석)하여 브라우저에 렌더링**하는지 알아보기\r\n\r\n\r\n\r\n- 파싱(parsing): parse(분석하다)\r\n\r\n    \r\n\r\n    브라우저가 코드를 이해하고 사용하기 쉬운 구조로 변환하는 것을 말한다.\r\n\r\n    \r\n\r\n    파싱(구문 분석)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰(문법적으로 더는 나눌 수 없는 코드의 기본 요소)으로 분해(어휘 분석)하고, 토큰에 문법적 의미와 구조를 반영하여 트리 구조의 자료구조인 파스 트리를 생성하는 일련의 과정을 말한다. \r\n\r\n    \r\n\r\n- 리소스란: resource(재료, 자산)\r\n\r\n    \r\n\r\n    HTML, CSS, 자바스크립트, 이미지, 폰트 등의 정적 파일 또는 서버가 동적으로 생성한 데이터\r\n\r\n    \r\n\r\n    - 동적으로 생성한 데이터 (참고 사이트: 네이버 뉴스 [https://news.naver.com](https://news.naver.com/)/)\r\n\r\n        \r\n\r\n        ChatGPT에게 물어본 질문\r\n\r\n        \r\n\r\n        서버가 동적으로 생성한 데이터는 클라이언트에게 동적으로 제공되는 정보입니다. 이 데이터는 서버 측에서 요청에 따라 생성되며, 주로 데이터베이스나 외부 API와 상호작용하여 생성됩니다.\r\n\r\n        \r\n\r\n        예를 들어, 웹 애플리케이션이 사용자에게 개인화된 환영 메시지를 보여주기 위해 사용자 이름을 가져와야 한다고 가정해 봅시다. 이 경우, 사용자 이름은 클라이언트가 제공하는 정적 데이터가 아닌, 서버에서 동적으로 생성된 데이터입니다. 서버는 사용자가 요청을 보내면, 데이터베이스에서 사용자 이름을 조회하여 클라이언트에게 반환할 수 있습니다.\r\n\r\n        \r\n\r\n        또 다른 예로는 뉴스 웹사이트를 생각해 볼 수 있습니다. 사용자가 뉴스 카테고리를 선택하면, 서버는 해당 카테고리에 대한 동적으로 생성된 데이터를 가져와서 클라이언트에 표시할 수 있습니다. 이 데이터는 사용자가 선택한 카테고리에 따라 계속 변경될 수 있으므로 동적인 데이터입니다.\r\n\r\n        \r\n\r\n        서버가 동적으로 생성한 데이터는 주로 서버 사이드 프로그래밍 언어(예: PHP, Python, Node.js)를 사용하여 생성되며, 클라이언트에게 전달되기 전에 HTML, CSS 및 JavaScript와 결합되어 웹 페이지를 구성합니다.\r\n\r\n        \r\n\r\n    \r\n\r\n- 렌더링이란?: render(만들다)\r\n\r\n    \r\n\r\n    렌더링은 HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.\r\n\r\n    \r\n\r\n- 웹 브라우저란?: browse(둘러보다, 인터넷을 돌아다니다.)\r\n\r\n    \r\n\r\n    웹 브라우저란 웹에서 정보를 탐색하고 HTML 문서, 이미지 등 여러 콘텐츠를 우리에게 표현해주는 소프트웨어로 구글 크롬(Chrome), 애플의 사파리(Safari), 마이크로소프트 엣지(Microsoft Edge), 모질라 파이어폭스(Firefox) 등이 있다.\r\n\r\n    \r\n\r\n    브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다\r\n\r\n    \r\n\r\n\r\n\r\n프론트엔드 개발자와 떼려야 뗄 수 없는 것은 브라우저다. 그렇기에 이제부터 본격적으로 브라우저의 렌더링에 대해서 알아보겠다. \r\n\r\n\r\n\r\n![브라우저렌더링(구글).png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7fbb8dc8-08de-4cad-b01c-cd0022b93981%2F%25EB%25B8%258C%25EB%259D%25BC%25EC%259A%25B0%25EC%25A0%2580%25EB%25A0%258C%25EB%258D%2594%25EB%25A7%2581(%25EA%25B5%25AC%25EA%25B8%2580).png?table=block&id=e1815fa1-218f-42dc-a9bc-c45c2d011e15&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1920&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n### 브라우저의 렌더링 수행 순서 요약\r\n\r\n\r\n\r\n1. 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.\r\n\r\n2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML, CSS를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합하여 렌더 트리를 생성한다.\r\n\r\n3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다. \r\n\r\n- 바이트 코드\r\n\r\n    \r\n\r\n    바이트코드(Bytecode)는 컴퓨터 프로그램을 실행하기 위해 컴파일러나 인터프리터에 의해 생성되는 저수준의 중간 언어입니다. 바이트코드는 기계어보다는 인간이 이해하기 쉬우면서도 컴퓨터가 실행하기에 효율적인 형태로 작성됩니다.\r\n\r\n    \r\n\r\n1. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.\r\n\r\n\r\n\r\n### 1. 요청과 응답\r\n\r\n\r\n\r\n브라우저의 핵심 기능: 필요한 리소스를 서버에 요청하고 서버로부터 응답받아 브라우저에 시각적으로 렌더링하는 것이다. \r\n\r\n\r\n\r\n서버에 요청을 전송하기 위해 브라우저는 주소창을 제공한다.\r\n\r\n\r\n\r\n브라우저의 주소창에 URL을 입력하고 엔터 키를 누르면 URL의 호스트 이름이 DNS를 통해 IP 주소로 변환되고 이 IP주소를 갖는 서버에게 요청을 전송한다.\r\n\r\n\r\n\r\n- 자세한 설명(ChatGPT)\r\n\r\n    1. 호스트 이름 추출: 먼저, 입력한 URL에서 호스트 이름을 추출합니다. 호스트 이름은 일반적으로 \"**[www.example.com\"과](http://www.example.xn--com%22-nl6w/)** 같이 도메인 이름으로 표시됩니다. URL은 \"http://\" 또는 \"https://\"와 같은 프로토콜로 시작하며, 호스트 이름은 프로토콜과 경로 정보 사이에 위치합니다.\r\n\r\n    2. DNS(Domain Name System) 조회: 추출한 호스트 이름을 DNS에게 전달하여 IP 주소로 변환해야 합니다. DNS는 인터넷 상의 도메인 이름을 해당 도메인의 IP 주소로 매핑하는 역할을 합니다. DNS 서버에 호스트 이름을 보내면 DNS 서버는 해당 호스트 이름에 대한 IP 주소를 찾아서 반환합니다.\r\n\r\n    3. IP 주소 획득: 브라우저는 DNS 조회 결과로부터 호스트 이름에 대응하는 IP 주소를 얻습니다. 이 IP 주소는 해당 웹 서버를 식별하는 고유한 주소입니다.\r\n\r\n    4. 서버 요청: 브라우저는 얻은 IP 주소를 사용하여 웹 서버에 요청을 전송합니다. 이 요청은 HTTP(HyperText Transfer Protocol)나 HTTPS와 같은 프로토콜을 사용하여 서버와 통신하며, 요청 내용은 HTTP 메소드(GET, POST, PUT 등)와 함께 전송됩니다. 요청에는 브라우저가 서버에게 필요한 정보(예: 웹 페이지, 이미지, 동영상)를 요청하는 것이 포함될 수 있습니다.\r\n\r\n    5. 서버 응답: 서버는 요청을 받은 후 해당하는 작업을 수행한 뒤, 클라이언트인 브라우저에게 응답을 보냅니다. 응답은 웹 페이지의 HTML, CSS, JavaScript 코드, 이미지, 동영상 등의 형태로 전달될 수 있습니다. 브라우저는 이 응답을 받아서 해석하고, 필요한 경우 웹 페이지를 렌더링하여 사용자에게 보여줍니다.\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F87f8ab4f-7dc4-4bfa-a86b-4426766ffd2a%2FUntitled.png?table=block&id=01ba5a0a-1c54-456f-88ac-7545a3ad3be3&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n참고: HTTP(HyperText Transfer Protocol)는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)이다. \r\n\r\n\r\n\r\n### 2. HTML 파싱과 DOM 생성\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe5f83b9f-0083-415c-8186-81dbac8b3617%2FUntitled.png?table=block&id=ab7d0192-7c58-4f3e-8296-07a862630231&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1960&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n브라우저의 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트다. 순수한 텍스트인 HTML 문서를 브라우저에 시각적인 픽셀로 렌더링하려면 HTML 문서를 브라우저가 이해할 수 있는 자료구조(객체)로 변환하여 메모리에 저장해야한다. 브라우저의 렌더링 엔진은 응답받은 HTML 문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 DOM(Document Object Model)을 생성한다.\r\n\r\n\r\n\r\n- 자세한 설명\r\n\r\n    1. 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답된다. 이때 서버는 브라우저가 요청한 HTML 파일을 읽어 들여 메모리에 저장한 다음 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답한다.\r\n\r\n    2.  브라우저는 서버가 응답한 HTML 문서를 바이트(2진수) 형태로 응답받는다. 그리고 응답된 바이트 형태의 HTML 문서는 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환된다. 참고로 meta 태그의 charset 어트리뷰트에 선언된 인코딩 방식은 content-type:text/html; charset=utf-8과 같이 응답헤더에 담겨 응답된다. 브라우저는 이를 확인하고 문자열로 변환한다.\r\n\r\n    3.  문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 최소 단위인 토큰들로 분해한다.\r\n\r\n    4.  각 토큰들을 객체로 변환하여 노드들을 생성한다. 토큰의 내용에 따라 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드가 생성된다. 노드는 이후 DOM을 구성하는 기본 요소가 된다.\r\n\r\n    5.  HTML 문서는 HTML 요소들의 집합으로 이루어지며 HTML 요소는 중첩 관계를 갖는다. 즉, HTML 요소의 콘텐츠 영역(시작 태그와 종료 태그 사이)에는 텍스트뿐만 아니라 다른 HTML 요소도 포함될 수 있다. 이때 HTML 요소간에는 중첩 관계에 의해 부자 관계가 형성된다. 이러한 HTML 요소 간의 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다. 이 노드들로 구성된 트리 자료구조를 DOM이라 부른다.\r\n\r\n\r\n\r\n즉, DOM은 HTML 문서를 파싱한 결과물이다. \r\n\r\n\r\n\r\n### 3. CSS파싱과 CSSOM 생성\r\n\r\n\r\n\r\n렌더링 엔진은 HTML을 처음부터 한 줄씩 순차적으로 파싱하여 DOM을 생성해 나간다. 이처럼 렌더링 엔진은 DOM을 생성해 나가다가 CSS를 로드하는 link 태그나 style태그를 만나면 DOM 생성을 일시 중단한다. \r\n\r\n\r\n\r\n그리고 link 태그의 href 어트리뷰트에 지정된 css파일을 서버에 요청하여 로드한 CSS 파일이나 style태그 내의 CSS를 HTML과 동일한 파싱 과정(바이트 → 문자 → 토큰 →  노드 → CSSOM)을 거치며 해석하여 CSSOM을 생성한다. 이후 CSS 파싱을 완료하면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작하여 DOM 생성을 재개한다.\r\n\r\n\r\n\r\n### 4. 렌더 트리 생성\r\n\r\n\r\n\r\n렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 각각 DOM과 CSSOM를 생성한다. 그리고 DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합된다. \r\n\r\n\r\n\r\n렌더 트리: 렌더링을 위한 트리 구조의 자료구조다. 따라서 브라우저 화면에 렌더링되지 않는 노드(ex.meta 태그, script 태그 등)와 CSS에 의해 비표시(ex. display: none)되는 노드들은 포함하지 않는다. 다시 말해, 렌더 트리는 브라우저 화면에 렌더링되는 노드만으로 구성된다. \r\n\r\n\r\n\r\n지금까지 살펴본 브라우저의 렌더링 과정은 반복해서 실행될 수 있다. 예를 들어, 다음과 같은 경우 반복해서 레이아웃 계산과 페인팅이 재차 실행된다.\r\n\r\n\r\n\r\n- 자바스크립트에 의한 노드 추가 또는 삭제\r\n\r\n- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경\r\n\r\n- HTML 요소의 레이아웃(위치, 크기)에 변경을 발생시키는 width/height, margin, padding, border, display, position, top/right/bottom/left 등의 스타일 변경\r\n\r\n\r\n\r\n레이아웃 계산과 페인팅을 다시 실행하는 리렌더링은 비용이 많이 드는, 즉 성능에 악영향을 주는 작업이다.\r\n\r\n\r\n\r\n따라서 가급적 리렌더링이 빈번하게 발생하지 않도록 주의할 필요가 있다.\r\n\r\n\r\n\r\n### 5. 자바스크립트 파싱과 실행\r\n\r\n\r\n\r\nHTML 문서를 파싱한 결과물로서 생성된 DOM은 HTML 문서의 구조와 정보뿐만 아니라 HTML 요소와 스타일 등을 변경할 수 있는 프로그래밍 인터페이스로서 DOM API를 제공한다. 즉, 자바스크립트 코드에서 DOM API를 사용하면 이미 생성된 DOM을 동적으로 조작할 수 있다.\r\n\r\n\r\n\r\n자바스크립트 파싱과 실행은 브라우저의 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. 자바스크립트 엔진은 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행하는 역할을 한다. \r\n\r\n\r\n\r\n렌더링 엔진이 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하듯이 자바스크립트 엔진은 자바스크립트를 해석하여 AST(Abstract Syntax Tree 추상적 구문 트리)를 생성한다. 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다.\r\n\r\n\r\n\r\n바이트코드: 바이트코드는 기계가 이해하기 쉬운 형태로, AST의 추상적인 구문을 구체적인 연산 명령어로 변환한 것입니다. 바이트코드는 일반적으로 인터프리터나 JIT(Just-In-Time) 컴파일러를 통해 실행됩니다.\r\n\r\n\r\n\r\n### 6. 리플로우와 리페인트\r\n\r\n\r\n\r\n만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM이나 CSSOM이 변경된다. 이때 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 리플로우, 리페인트라 한다.\r\n\r\n\r\n\r\n리플로우: 레이아웃 계산을 다시 하는 것을 말하며, 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우에 한하야 실행된다.\r\n\r\n\r\n\r\n리페인트: 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것을 말한다.\r\n\r\n\r\n\r\n따라서 리플로우와 리페인트가 반드시 순차적으로 동시에 실행되는 것은 아닌다. 레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 실행된다. \r\n\r\n\r\n\r\n### 7. 자바스크립트 파싱에 의한 HTML 파싱 중단\r\n\r\n\r\n\r\nDOM을 변경하는 DOM API를 사용할 때 DOM 생성이 완료되지 않은 상태라면 문제가 발생할 수 있다. 이러한 문제를 회피하기 위해 body 요소의 가장 아래에 자바스크립트를 위치시키는 것은 좋은 아이디어다.\r\n\r\n\r\n\r\n- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수 있다.\r\n\r\n- 자바스크립트 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.\r\n\r\n\r\n\r\n### 8. script 태그의 async/defer 어트리뷰트\r\n\r\n\r\n\r\n```jsx\r\n\r\n<!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />\r\n\r\n    <title>Document</title>\r\n\r\n    <script src=\"main.js\"><script>\r\n\r\n  </head>\r\n\r\n  <body></body>\r\n\r\n</html>\r\n\r\n```\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6e338a9b-8dab-432d-acac-115fe4345c95%2FUntitled.png?table=block&id=243c1eb7-5fe6-4f2c-84cd-ad785a47c6e7&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1730&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n1. HTML을 쭉 파싱하다가 script 태그가 보이면 main.js를 다운받아야하네 하고 HTML 파싱을 잠시 멈춘다.\r\n\r\n2. 필요한 JavaScript 파일을 서버에서 다운받아서 이것을 실행한 다음에 다시 HTML 파싱하는 부분으로 넘어간다. // fetch: 가져오다. \r\n\r\n\r\n\r\n→ 단점: JavaScript 파일의 사이즈가 어마어마하게 크고, 인터넷이 엄청 느리면 사용자가 웹사이트를 보는데까지 많은 시간이 소요된다.\r\n\r\n\r\n\r\n그래서 많이 쓰는 방식이 아래와 같다.\r\n\r\n\r\n\r\n```jsx\r\n\r\n<!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />\r\n\r\n    <title>Document</title>\r\n\r\n  </head>\r\n\r\n  <body>\r\n\r\n    <div></div>\r\n\r\n    <script src=\"main.js\"></script>\r\n\r\n  </body>\r\n\r\n</html>\r\n\r\n```\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F43d49b76-3dd2-4078-b241-2c73ebbb6ba2%2FUntitled.png?table=block&id=6a79020f-70ec-48ec-9cc0-30e8dee41278&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1730&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n1. 브라우저가 HTML 다운받아서 쭉 파싱해서 페이지가 다 준비된다.\r\n\r\n2. 다음에 script 태그를 만나서 script를 서버에서 받아오고(fetch), 실행하게 된다.\r\n\r\n\r\n\r\n→ 단점: 사용자가 기본적인 HTML 컨텐츠를 빠르게 볼 수 있지만, 웹사이트가 JavaScript에 매우 의존적이면 사용자가 의미있는 콘텐츠를 보기 위해서 자바스크립트를 이용해서 서버에 있는 데이터를 받아온다던지, DOM 요소를 더 이쁘게 꾸며주는 웹사이트라면 사용자가 정상적인 페이지를 보기 전까지는 오래기다려야한다. \r\n\r\n\r\n\r\n**자바스크립트 파싱에 의한 DOM 생성이 중단되는 문제를 근본적으로 해결하기 위해 HTML5부터 script 태그에 async와 defer 어트리뷰트가 추가되었다.** async와 defer 어트리뷰트는 src 어트리뷰트를 통해 외부 자바스크립트 파일을 로드하는 경우에만 사용할 수 있다.                                                            \r\n\r\n\r\n\r\nasync와 defer 어트리뷰트를 사용하면 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 하지만 실행 시점에 차이가 있다.\r\n\r\n\r\n\r\n1) async 어트리뷰트\r\n\r\n\r\n\r\n: HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 단 자바스크립트의 파싱과 실행은 자바스크립트 파일의 로드가 완료된 직후 진행되며, 이때 HTML 파싱이 중단된다. \r\n\r\n\r\n\r\n```jsx\r\n\r\n!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />페\r\n\r\n    <title>Document</title>\r\n\r\n    <script async src=\"main.js\"><script>\r\n\r\n  </head>\r\n\r\n  <body>\r\n\r\n    <div></div>\r\n\r\n<p></p>\r\n\r\n  </body>\r\n\r\n</html>\r\n\r\n```\r\n\r\nCORS\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdfa4667f-6f24-4e5c-b625-e62165043dbe%2FUntitled.png?table=block&id=c44f5412-4f60-4a78-a2e1-3864567fa5b1&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1730&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\nasync는 불리언타입의 속성값이기 때문에 이렇게 선언하는 것만으로도 true로 설정이 되어서 async 옵션을 사용할 수 있다.\r\n\r\n\r\n\r\n1. async를 사용하게 되면 브라우저가 HTML을 다운로드 받아서 파싱하다가 async가 있으면 병렬로 main.js를 다운로드받자고 명령한다.\r\n\r\n2.  다시 파싱하다가 main.js가 다 다운로드되면 그때 파싱을 멈추고 다운로드된 js파일을 실행한다. \r\n\r\n3. 실행 다하고 나서 나머지 HTML을 파싱하게 된다. \r\n\r\n\r\n\r\n→ 장점: body끝에 사용하는 것보다 fetching이 pasing하는 동안 병렬적으로 일어나기 때문에 다운로드 받는 시간을 절약할 수 있다. \r\n\r\n\r\n\r\n→ 단점: 하지만 js가 HTML이 파싱되기도 전에 실행되어서 만약 js 파일에서 queryselector를 이용해서 DOM 요소를 조작한다고하면 이 조작하려는 시점에 HTML이 원하는 요소가 아직 정의되어 있지 않을 수 있다. 그리고 HTML 파싱하는 동안에 언제든지 js를 실행하기 위해서 멈출 수 있어서 사용자가 페이지를 보는데 시간이 여전히 걸릴 수 있다.\r\n\r\n\r\n\r\n2) defer 어트리뷰트 \r\n\r\n\r\n\r\n: defer 어트리뷰트도 HTML 파싱과 외부 자바스크립트 파일이 로드가 비동기적으로 동시에 진행된다. 단, 자바스크립트의 파싱과 실행은 HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후(이때 DOMContentLoaded 이벤트가 발생한다) 진행된다. 따라서 DOM 생성이 완료된 이후 실행되어야 할 자바스크립트에 유용하다. \r\n\r\n\r\n\r\n```jsx\r\n\r\n!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />\r\n\r\n    <title>Document</title>\r\n\r\n    <script defer src=\"main.js\"><script>\r\n\r\n  </head>\r\n\r\n  <body>\r\n\r\n    <div></div>\r\n\r\n  </body>\r\n\r\n</html>\r\n\r\n```\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F19bfd3a6-4e28-44ce-a102-2fb79ee78ffa%2FUntitled.png?table=block&id=7d041916-7bc6-47df-aee0-4b87c6e236fa&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1730&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n1. 파싱을 하다가 script에 defer가 있으면 main.js를 다운로드 받자 명령만 시켜놓고, 나머지 HTML을 끝까지 파싱한다.\r\n\r\n2. 마지막에 파싱이 끝난 다음에 다운로드된 자바스크립트를 실행한다.\r\n\r\n\r\n\r\n즉, HTML을 파싱하는 동안 필요한 js를 다 다운로드 받고, HTML 파싱을 먼저해서 사용자에게 페이지를 보여준 다음에 바로 이어서 js를 실행한다.\r\n\r\n\r\n\r\n두 개의 차이점을 더 명확하게 파악해보자! \r\n\r\n\r\n\r\n```jsx\r\n\r\n!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />\r\n\r\n    <title>Document</title>\r\n\r\n    <script async src=\"a.js\"><script>\r\n\r\n    <script async src=\"b.js\"><script>\r\n\r\n    <script async src=\"c.js\"><script>\r\n\r\n  </head>\r\n\r\n```\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa2945c44-6882-4bab-81d8-5e8f54ab5e90%2FUntitled.png?table=block&id=fe458900-38ec-48b0-951f-4da4cf489d4a&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1820&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n여러 개의 script 태그에 async 어트리뷰트를 지정하면 script 태그의 순서와는 상관없이 로드가 완료된 자바스크립트부터 먼저 실행되므로 순서가 보장되지 않는다. 따라서 순서 보장이 필요한 script 태그에는 async 어트리뷰트를 지정하지 않아야 한다. (순서에 의존적인거라면 문제가 될 수 있다.)\r\n\r\n\r\n\r\n```jsx\r\n\r\n!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />\r\n\r\n    <title>Document</title>\r\n\r\n    <script defer src=\"a.js\"><script>\r\n\r\n    <script defer src=\"b.js\"><script>\r\n\r\n    <script defer src=\"c.js\"><script>\r\n\r\n  </head>\r\n\r\n```\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F95e84e91-9b6b-4282-8510-6fe78ac99caf%2FUntitled.png?table=block&id=04532ec6-cd8a-4484-a846-e4800cd07d31&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1730&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n파싱하는동안 필요한 js를 다 다운로브받고 순서대로 실행된다. 즉, 정의한 순서가 지켜진다. → 제일 효율적이고 안전하다\r\n\r\n\r\n\r\n",
        "qna": "**브라우저 렌더링 원리에 대해서 설명해보세요.**\r\n\r\n    \r\n\r\n    브라우저 렌더링은 HTML, CSS, JavaScript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정을 말합니다. 브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성됩니다.\r\n\r\n    \r\n\r\n    1. 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.\r\n\r\n    2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML, CSS를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합하여 렌더 트리를 생성한다.\r\n\r\n    3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다. \r\n\r\n    4. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다."
      },
      {
        "id": "26",
        "title": "JavaScript",
        "topic": "이벤트 루프(event loop)에 관하여",
        "texture": "이벤트 루프는 자바스크립트에서 **비동기 처리**를 담당하는 *메커니즘이자* 장치입니다. 이벤트 루프는자바스크립트의 비동기 작업들을 큐(Queue)에 추가하고 작업들을 순차적으로 처리합니다. 이벤트 루프는 **싱글 스레드**로 동작하며, 이를 통해 자바스크립트가 비동기 처리를 하면서도 블로킹이나 데드락 등의 문제를 방지하여 더욱 안정적인 비동기 처리를 가능하게 합니다.\r\n\r\n- 이벤트 루프의 특징\r\n\r\n    \r\n\r\n    ***스레드**(thread)는 어떠한 프로그램 내에서 실행되는 흐름의 단위를 말합니다. 일종의 컨베이어 벨트이다.!*\r\n\r\n    \r\n\r\n    - 이벤트 루프는 메인 스레드의 동작 타이밍을 관리하면서, 비동기적인 처리를 가능하게 하여 브라우저의 응답성을 향상시키는 역할을 한다.\r\n\r\n    - 메인 스레드(단일 스레드로 구성)란 자바스크립트 코드 실행이나 브라우저 렌더링을 맡는 등 브라우저의 주된 동작이 수행되는 곳이다.\r\n\r\n    - 이벤트 루프는 큐에 추가된 작업들을 주로 타이머, I/O 이벤트, 콜백 함수 등으로 처리합니다.\r\n\r\n    - 이벤트 루프는 하나 이상의 태스크 큐를 갖는다.\r\n\r\n    - 논 블로킹I/O는 이벤트 루프 모델의 무척 흥미로운 특징(동시성을 높임)\r\n\r\n    **논 블로킹**이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행\r\n\r\n    **블로킹**이란 이전 작업이 끝나야만 다음 작업을 수행\r\n\r\n    - 자바스크립트에서 **비동기 처리란**, 네트워크 요청, 파일 읽기/쓰기 등의 작업으로 인해 시간이 오래 걸리는 작업 완료되는 시점을 기다리지 않고  다음 코드를 실행하는 것을 의미 (즉, 동기적으로 처리하지 않는다.)\r\n\r\n    - 이벤트 루프는 각 작업들의 우선순위를 고려하여 처리하며, 마이크로 태스크(Microtask queeu)와 매크로 태스크(Macrotask queue)를 구분하여 처리합니다. 이는 자바스크립트의 비동기 처리에 중요한 역할을 합니다.\r\n\r\n    - 마이크로 태스크는 작업 큐에 들어온 매크로 태스크보다 우선순위가 높습니다. 이벤트 루프는 현재 실행 중인 작업이 완료되면 마이크로 태스크부터 순서대로 처리하고, 그 후에 매크로 태스크를 처리합니다.\r\n\r\n    대표적인 메크로 테스크로는 setTimeout, setInterval, setImmediate 등\r\n\r\n    대표적인 마이크로 테스크는 Promise 콜백, then, catch, async함수 등\r\n\r\n- 이벤트 루프가 왜 중요함?\r\n\r\n    \r\n\r\n    이벤트 루프는 브라우저 메인 스레드 동작 타이밍을 관리하는 관리자라고 할 수 있다. 관리자라고 하니까 중요한 것 같기는 한데 감이 오지 않을 수 있다. 브라우저 동작 특징을 알아보면서 이벤트 루프가 중요한 이유를 알아보자.\r\n\r\n    \r\n\r\n    1. ****브라우저 동작의 대부분이 메인 스레드에서 싱글 스레드로 실행된다.****\r\n\r\n    \r\n\r\n    메인 스레드가 싱글 스레드로 동작하는 것이 중요한 이유는 싱글 스레드에서 하나의 작업을 하고 있다면 다른 작업은 지연시키기 때문이다. 예를 들어 싱글 스레드의 동작은 한 사람이 여러 가지 일을 동시에 처리할 수 없는 것과 비슷하다. `게임`과 `식사`라는 2개의 작업이 수행되어야 할 때 `게임`을 하고 있다면 `식사` 작업은 지연될 수밖에 없다. 둘 중 하나의 작업이 굉장히 길어진다면 다른 작업은 시작조차 못 할 것이다. (하나의 스레드는 코드가 실행되는 하나의 흐름)\r\n\r\n    \r\n\r\n    - 메인스레드? 싱글스레드?\r\n\r\n        \r\n\r\n        여기서는 구체적으로 브라우저 환경에서 메인 스레드가 싱글 스레드로 동작하는 것이 중요한 이유를 설명하고 있습니다. 즉, 브라우저의 대부분의 동작이 메인 스레드에서 처리되며, 이 때 메인 스레드가 싱글 스레드로 동작하기 때문에 작업 관리가 매우 중요하다는 것을 강조하고 있습니다.\r\n\r\n        \r\n\r\n        그렇다면 보조 스레드란?\r\n\r\n        \r\n\r\n        메인 스레드는 보통 UI와 관련된 작업들을 처리하는 스레드입니다. 예를 들어 사용자의 입력을 받아들이고, 이에 따라 UI를 업데이트하거나, JavaScript 코드를 실행하거나, HTTP 요청을 처리하는 등의 작업을 합니다.\r\n\r\n        \r\n\r\n        반면에 보조 스레드(Helper 혹은 Worker Thread)는 메인 스레드에서 처리하기 어려운 작업들을 처리하는 데 사용됩니다. 대표적으로는 네트워크 통신, 이미지 로딩, 파일 다운로드, 암호화 및 복호화 등이 있습니다. 이러한 작업들은 메인 스레드에서 처리하면 UI가 멈추거나 끊기는 현상이 발생할 수 있기 때문에, 보조 스레드에서 처리됩니다. 보조 스레드는 메인 스레드와 달리 프로그램의 흐름을 제어하지 않고, 병행적으로 실행되기 때문에 다른 스레드들과 경쟁하며 자원을 공유합니다. 프로그램의 기능을 향상시키고 멀티태스킹을 구현하는 데 중요한 역할을 합니다.\r\n\r\n        \r\n\r\n    \r\n\r\n    메인 스레드에서도 마찬가지로, 개발자가 만약 자바스크립트 코드에 무한 루프 코드를 작성한다면 해당 작업이 다른 모든 작업을 지연시키고 메인 스레드에서 무한히 동작할 것이다. 결국에는 브라우저가 먹통이 되는 현상이 발생한다. 사용자 이벤트도 메인 스레드에서 동작하기 때문에 키보드 입력이나 마우스 클릭도 동작하지 않는다. 그러므로 싱글 스레드의 작업 관리는 매우 중요하다고 할 수 있다.\r\n\r\n    \r\n\r\n    즉, 싱글 스레드로 실행되는 특징은 **동시성 관리, 안정성 보장, 자원 관리, 예측 가능성** 등을 높인다.\r\n\r\n    \r\n\r\n    - 동시성 관리: 여러 개의 작업을 동시에 처리하는 것은 어려운 일입니다. 여러 개의 스레드를 사용하여 작업을 분산할 수 있지만, 이로 인해 발생하는 복잡도와 위험성이 높아집니다. 싱글 스레드로 작업을 관리하면 작업의 우선순위를 결정하고 순서에 따라 처리할 수 있습니다.\r\n\r\n    - 안정성 보장: 여러 개의 스레드가 동시에 실행되면, 서로의 작업에 영향을 미치거나 충돌이 발생할 수 있습니다. 싱글 스레드로 작업을 관리하면 이러한 위험을 최소화할 수 있습니다.\r\n\r\n    - 자원 관리: 각 스레드는 메모리와 같은 시스템 자원을 사용합니다. 여러 개의 스레드를 사용하면 자원을 효율적으로 관리하기가 어렵습니다. 싱글 스레드로 작업을 관리하면 자원을 보다 효율적으로 사용할 수 있습니다.\r\n\r\n    - 예측 가능성: 싱글 스레드로 작업을 관리하면 작업의 순서와 우선순위를 예측할 수 있습니다. 이는 시스템의 안정성과 예측 가능성을 높이는 데 도움이 됩니다.\r\n\r\n    \r\n\r\n    1. **메인 스레드는 이벤트 루프에 의해 관리된다.**\r\n\r\n    \r\n\r\n    앞서 언급한 것처럼, 메인 스레드와 같은 싱글 스레드에서 하나의 작업이 오랫동안 실행되어서도 안 되고, 여러 작업 중 어떤 작업을 우선으로 동작시킬 것인가 결정하는 것도 매우 중요하다. 또한, 작업 간 전환 속도를 빠르게 하여 한 번에 하나의 작업씩 수행하지만 **마치 동시에 수행하는 것처럼** 동작해야 한다. 이러한 섬세한 컨트롤을 바로 이벤트 루프가 메인 스레드의 동작을 관리를 통해 일어난다.\r\n\r\n    \r\n\r\n\r\n\r\n![img (1).gif](https://file.notion.so/f/s/c2dd7425-60f7-49fd-88fe-acb4f549c0ce/img_(1).gif?id=cc9f993b-bd16-48fb-9f9d-31f8197bb51f&table=block&spaceId=78e0979c-6197-4792-a235-719f1075b969&expirationTimestamp=1694361600000&signature=i3SaZS2NINhYnhR_HUJV7tkyWVg9uhp-9Vod-SFyjyY)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n**이벤트 루프 알고리즘**\r\n\r\n\r\n\r\n이벤트 루프는 런타임(브라우저 / 노드)에서 비동기 작업을 돕는다. 싱글스레드로 동작하는 자바스크립트 엔진이 왜 여러 작업들이 함께 발생하는 것 처럼 느껴지게 하는지, 자바스크립트 엔진과 이벤트 루프가 어떻게 동작하는지부터 알아보자.\r\n\r\n\r\n\r\n**이벤트 루프의 작업을 다루는 순서**\r\n\r\n\r\n\r\n콜스택이 비어있다는 전제하에,\r\n\r\n\r\n\r\n1. **마이크로 태스크 큐**에 있는 마이크로 태스크를 FIFO(선입선출)로 순차 실행한다.\r\n\r\n\r\n\r\n2. 마이크로 태스크 큐가 비면, **렌더링 작업을 수행**한다.\r\n\r\n\r\n\r\n3. 렌더링 작업 후에는 **매크로 태스크 큐(=태스크 큐)**에 있는 태스크를 실행한다.\r\n\r\n\r\n\r\n4. 매크로 태스크 큐의 작업이 1개 실행되고, 다시 1번으로 돌아간다.\r\n\r\n\r\n\r\n주목할 점은 마이크로 태스크가 모두 처리되지 않으면, 렌더링이 되지 않는다는 것이다. 대표적인  마이크로 태스크 큐에 담길 태스크는 Promise 콜백과 then, catch, finally 콜백, async 함수 등이 있다.\r\n\r\n\r\n\r\n**출처**\r\n\r\n\r\n\r\n****[마이크로 태스크 큐의 비동기 작업 처리와 렌더링 시점을 알아보자.](https://gobae.tistory.com/134)****\r\n\r\n\r\n\r\n****[마이크로태스크(Microtask)와 매크로태스크(Macrotask) 알아보기](https://velog.io/@dami/JS-Microtask-Queue)****\r\n\r\n\r\n\r\n****[이벤트 루프, 넌 누구냐](https://tecoble.techcourse.co.kr/post/2021-08-28-event-loop/)****\r\n\r\n\r\n\r\n****[이벤트 루프와 태스크 큐](https://velog.io/@yejineee/%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EC%99%80-%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%ED%83%9C%EC%8A%A4%ED%81%AC-%EB%A7%A4%ED%81%AC%EB%A1%9C-%ED%83%9C%EC%8A%A4%ED%81%AC-g6f0joxx)****\r\n\r\n\r\n\r\nChat Gpt\r\n\r\n\r\n\r\n**참고자료**\r\n\r\n\r\n\r\n[[10분 테코톡] 🍗 피터의 이벤트루프](https://www.youtube.com/watch?v=wcxWlyps4Vg)\r\n\r\n\r\n\r\n[개발자 90%가 모르는 자바스크립트 동작원리 (Stack, Queue, event loop)](https://www.youtube.com/watch?v=v67LloZ1ieI)\r\n\r\n\r\n\r\n[Promise, async & await](https://evanai.notion.site/evanai/Promise-async-await-4506f8d25e64416bb124f0fac772fed6)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n- **브라우저의 구조와 동작원리**\r\n\r\n    \r\n\r\n    *웹브라우저 동작원리 ? 왜 알아야 하는데 - 우리가 짠 자바스크립트는 크롬이 실행시켜주니까..*\r\n\r\n    \r\n\r\n    자바스크립트 엔진은 다음과 같다.\r\n\r\n    \r\n\r\n    웹킷,V8 등의 자바스크립트 엔진, JS코드를 해석하고 실행하는 인터프리터이며, 크게 **힙**과 **콜스택**으로 이루어져 있다.\r\n\r\n    \r\n\r\n    힙은 메모리 할당이 일어나는 부분.*변수, 객체 등이 저장되는 창고라고 생각.\r\n\r\n    \r\n\r\n    - Memory Heap : 메모리 할당이 일어나는 장소\r\n\r\n    - Call Stack : 코드가 실행될 경우 하나씩 stack의 형태로 쌓이는 장소\r\n\r\n    \r\n\r\n    콜스택(호출 스택)이란?\r\n\r\n    \r\n\r\n    함수가 호출되는 순서대로 쌓이는 스택\r\n\r\n    \r\n\r\n    함수실행 시 호출 스택에 해당 함수를 집어넣는다.(정확히는 함수가 아니라 함수의 실행 문맥이 쌓임. 자바스크립트가 함수를 실행하기 위해 가지고 있어야 하는 여러가지 정보들을 의미. 변수나 함수의 선언, 스코프, this 등의 정보들을 물리적 객체형태로 보관)\r\n\r\n    \r\n\r\n    함수 실행시에 콜스택에 함수를 넣어서 실행시키고, 함수 리턴시에 콜스택의 맨위에서 해당함수를 끄집어 내서 리턴을 시키는.. 그러한 방식으로 작동\r\n\r\n    \r\n\r\n    콜스택이 빈다 = 실행할 함수가 남아있지 않다.\r\n\r\n    \r\n\r\n    자바스크립트는 싱글 스레이드 언어인데, 이것은 호출 스택을 하나만 사용한다라는 의미이며, 동시에 하나의 일만 처리할 수 있다라는 뜻이다. \r\n\r\n    \r\n\r\n    그렇다면 함수가 호출되는 스택이 하나뿐인데, 그렇다면 어떻게 비동기 요청을 지원하고, 동시성에 대한 처리는 누가함?\r\n\r\n    \r\n\r\n    그것에 대한 답은 웹브라우저 전체로 시야를 넓혀볼 필요가 있다. 웹브라우저는 JS엔진 말고도 Web APIs, 테스크 큐, 이벤트 루프 등이있다. 참고로 우리가 많이 사용하는 DOM, AJAX(XMLHttpRequest),Timeout(setTimeout)들은 사실 JavaScript에서 지원하는 것이 아닌 웹 브라우저 Web APIs에서 제공하는 메서드들이다. 이들은 비동기 메서드들이며, 메서드의 작동을 마치면 (이를테면 setTime이 지나고 나면 콜백을 테스크큐로) 콜백함수를 콜백큐(테스크 큐)에 집어넣는다. *[*콜백큐는 공식적인 용어가 아님.*](https://velog.io/@dev-mish-mash/Task-queue%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%A4%ED%95%B4-%EC%A0%95%EB%A6%AC)\r\n\r\n    \r\n\r\n    테스크 큐 = Web API의 콜백 함수들이 대기하는 공간\r\n\r\n    \r\n\r\n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4e8715dc-065c-4e8c-a8a6-5b01fadd88bc%2FUntitled.png?table=block&id=78a19d8d-61ae-484b-a2e1-9352ba6ceca7&spaceId=78e0979c-6197-4792-a235-719f1075b969&width=1600&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n    \r\n\r\n    이렇게 자바스크립트 엔진 자체는 싱글스레드로 구동되지만, 실제로 자바스크립트의 런타임 환경인 웹 브라우저, 자세히 말하자면 Web API가 멀티스레드로 동작한다. 그리고 자바스크립트 엔진이 이것들과 **상호 연동하기 위한 장치**가 *테스크 큐(콜백 큐)*와 *이벤트 루프*가 되는 셈이다.\r\n\r\n    \r\n\r\n    이벤트 루프는 호출 스택과 콜백 큐를 계속해서 주시하고 있다.\r\n\r\n    \r\n\r\n    *호출스택이 비어있으면,* 먼저 들어온 순서대로 콜백 큐에 있는 콜백 함수들을 호출 스택으로 집어 넣는다.\r\n\r\n    \r\n\r\n    전역 문맥 Global Context(전역 변수등을 가지고 있는) \r\n\r\n    \r\n\r\n    콜스택의 밑바닥에는 전역문맥이 항상 존재함.\r\n\r\n    \r\n\r\n    스크립트가 시작하면서 전역 문백부터 시작하고 스크립트가 끝나면 얘도 같이 사라짐.",
        "qna": ""
      },
      {
        "id": "27",
        "title": "JavaScript",
        "topic": "얕은 복사, 깊은 복사에 관하여",
        "texture": "### 얕은 복사와 깊은 복사에 관해서 설명해주세요.\r\n\r\n<aside>\r\n\r\n1️⃣ 얕은 복사는 객체나 배열을 복사할 때 참조값(주소값)을 복사하는 것을 의미합니다. 이것은 데이터가 그대로 생성되는 것이 아닌 해당 데이터의 참조 값을 전달하여 한 데이터의 값을 공유한다는 것을 의미하므로 이로 인해 한 객체나 배열을 수정하면 다른 객체나 배열도 영향을 받을 수 있습니다.\r\n\r\n\r\n\r\n</aside>\r\n\r\n\r\n\r\n<aside>\r\n\r\n2️⃣ 깊은 복사는 객체나 배열을 복사할 때 실제 값들을 새로운 메모리 공간에 복사하는 것을 의미합니다. 복사된 객체나 배열은 완전히 독립적인 메모리를 차지하게 되어 원본 객체나 배열과는 별개로 동작합니다. 따라서 한 객체나 배열을 수정해도 다른 객체나 배열은 영향을 받지 않습니다.\r\n\r\n\r\n\r\n</aside>\r\n\r\n\r\n\r\n<aside>\r\n\r\n3️⃣ 따라서, 깊은 복사는 데이터 자체를 복사하여 독립적인 복사본을 생성하는 반면, 얕은 복사는 참조값을 복사하여 원본과 복사본이 동일한 데이터를 참조하게 됩니다.\r\n\r\n\r\n\r\n</aside>\r\n\r\n\r\n\r\n복사는 어떤 데이터 타입인지에 따라 다르게 진행되기 때문에, 얉은 복사와 깊은 복사의 더 깊은 이해를 위해서는 먼저 **[데이터 타입**에 대한 이해](https://www.notion.so/4-0a503396ea9d46e1b09a59c1f3005374?pvs=21)를 하면 좋습니다. (원시값, 참조값의 특성)\r\n\r\n\r\n\r\n**얕은 복사, 깊은 복사를 쓰는이유**\r\n\r\n\r\n\r\n→ 원본 값이 변화될 수 있다. ([혹은 독립적인 카피가 필요할 경우](https://www.notion.so/4-0a503396ea9d46e1b09a59c1f3005374?pvs=21))\r\n\r\n\r\n\r\n```jsx\r\n\r\n//얕은 복사\r\n\r\nconst obj = { a: 1 };\r\n\r\nconst copyObj = obj;\r\n\r\n\r\n\r\ncopyObj.a = 2;\r\n\r\n\r\n\r\nconsole.log(obj.a); // 2, 원본 데이터에 영향을 준다.\r\n\r\nconsole.log(obj === copyObj); // true\r\n\r\n\r\n\r\n//깊은 복사(1depth한정)\r\n\r\nconst obj = {\r\n\r\n  a: 1,\r\n\r\n  b: { c: 2 }, //중첩 객체\r\n\r\n}\r\n\r\n\r\n\r\nconst copyObj = Object.assign({}, obj);\r\n\r\n\r\n\r\ncopyObj.b.c = 3;\r\n\r\n\r\n\r\nconsole.log(obj); // { a: 1, b: { c: 3 } } -> 2depth부턴 얕은 복사가 됨.\r\n\r\nconsole.log(obj.b.c === copyObj.b.c); // true\r\n\r\n```\r\n\r\n\r\n\r\n이렇게 참조 값만을 복사하게되는 것은 원치않는 결과를 가져올 수 있기 때문에, 상황에 따라 얉은 복사와 깊은 복사를 사용할 줄 알아야한다. 얉은 복사와 깊은 복사는 **참조 값**이 아닌 **값 자체**를 복사하기 위함이다. (블로그마다 얕은 복사에 속하는 복사법들*(Object.assign(), 전개 연산자 등)*을 깊은 복사에 분류 해놓기도 하는데, **~~그것은 1depth 한정 깊은 복사이다.~~**)\r\n\r\n\r\n\r\n- **얕은 복사(Shallow Copy)**\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    //얕은 복사(일반)\r\n\r\n    const obj1 = { a: 1, b: 2}\r\n\r\n    const obj2 = obj\r\n\r\n    console.log(obj === obj2) // true\r\n\r\n    \r\n\r\n    obj2.a = 100\r\n\r\n    console.log(obj1.a) // 100\r\n\r\n    ```\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    //깊은 복사가 됐는데(a에 할당하는 부분), spread는 얕은 복사라고 하지 않았나?\r\n\r\n    const obj = { a:1, b:2 }\r\n\r\n    const obj2 = {...obj}\r\n\r\n    obj2.a = 100\r\n\r\n    console.log(obj === obj2) // false \r\n\r\n    console.log(obj.a) // 1\r\n\r\n    \r\n\r\n    //이러면 얕은 복사의 특징(1depth까지만 깊은 복사)을 알 수 있다.\r\n\r\n    const obj = { a: { b:1, c:1 }, d: 2}\r\n\r\n    const obj2 = {...obj}\r\n\r\n    obj.a.b = 100\r\n\r\n    console.log(obj === obj2) // false\r\n\r\n    console.log(obj2.a.b) // 100\r\n\r\n    ```\r\n\r\n    \r\n\r\n    - 참조값 복사\r\n\r\n    - 일반적으로 객체를 복사할 때(일반 복사), 얕은 복사가 일어납니다. [(*원시값의 깊은복사 먼저 보셈)](https://www.notion.so/4-0a503396ea9d46e1b09a59c1f3005374?pvs=21)\r\n\r\n    - 1depth까지만 복사합니다.\r\n\r\n    - 객체나 배열을 복사할 때 참조값을 복사하여 동일한 데이터를 공유합니다.\r\n\r\n    - 복사된 객체나 배열을 수정하면 원본 객체나 배열도 영향을 받습니다.\r\n\r\n    - 메모리 사용량이 적고 복사 속도가 빠릅니다.\r\n\r\n    - 대표적으로 **Object.assign(), 전개 연산자(Spread), Array.prototype.slice()** 등이 있다.\r\n\r\n- **깊은 복사(Deep Copy)**\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    //결국 1레벨 깊이 이상의 객체를 깊은 복사하려면, 코드가 길어진다.\r\n\r\n    const obj = { a: { b:1, c:1 }, d: 2}\r\n\r\n    const obj2 = {...obj, a:{...obj.a}}\r\n\r\n    obj.a.b = 100\r\n\r\n    console.log(obj === obj2) // false\r\n\r\n    console.log(obj2.a.b) // 1\r\n\r\n    \r\n\r\n    //JSON.stringify()이용 깊은 복사\r\n\r\n    const obj = {\r\n\r\n      a: 1,\r\n\r\n      b: {\r\n\r\n        c: 2,\r\n\r\n      },\r\n\r\n    };\r\n\r\n    \r\n\r\n    const copiedObj = JSON.parse(JSON.stringify(obj)); \r\n\r\n    //자바스크립트 객체 -> json문자열 -> 자바스크립트 객체\r\n\r\n    //json 문자열로 바꾸는데(stringify) 이과정에서 원본 객체와의 참조가 모두 끊어진다.\r\n\r\n    \r\n\r\n    copiedObj.b.c = 3\r\n\r\n    \r\n\r\n    obj.b.c === copiedObj.b.c //false\r\n\r\n    ```\r\n\r\n    \r\n\r\n    - 값자체 복사\r\n\r\n    - 원시값을 복사할 때에는, 깊은 복사가 일어납니다.\r\n\r\n    - 복잡한 구조(2depth 이상)을 전부 복사합니다.\r\n\r\n    - 실제 값들을 새로운 메모리 공간에 복사하여 독립적인 복사본을 생성합니다.\r\n\r\n    - 복사본의 변경이 원본에 영향을 주지 않습니다.\r\n\r\n    - 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않습니다.\r\n\r\n    - 객체가 참조 타입의 멤버를 포함할 경우 참조값의 복사가 아닌 참조된 객체 자체가 복사되는 것을 의미합니다. 기존 원본의 참조는 더 이상 하지 않습니다.\r\n\r\n    - 대표적으로 **재귀함수, JSON.parse(JSON.stringify(obj)), lodash 라이브러리의 등이 있다.**\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n- 원시값의 복사\r\n\r\n    \r\n\r\n    원시값은 깊은 복사를 하게 됩니다. 값타입이라고도 하며, JavaScript에서 string, number, boolean, null, undefined와 같은 데이터 타입을 말합니다. 원시값은 불변(immutable)하므로 복사된 변수를 변경하면 원*본 변수에는 영향을 주지 않습니다.*\r\n\r\n    \r\n\r\n    예를 들어, 원시값을 변수에 할당하고 그 변수를 다른 변수에 복사하는 경우:\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    let num1 = 1;\r\n\r\n    let num2 = num1; //num2에는 1이라는 값 자체가 복사되어 들어간다.\r\n\r\n    \r\n\r\n    num2 = 2;\r\n\r\n    \r\n\r\n    console.log(num1, num2); //num1: 1, num2: 2\r\n\r\n    ```\r\n\r\n    \r\n\r\n    원시값은 불변(immutable)하기 때문에 값 자체가 변경되지 않습니다. 따라서 원시값을 복사하는 경우에는 얕은 복사와 깊은 복사의 개념이 크게 중요하지 않습니다. 원시값을 다른 변수에 할당하면 해당 변수에는 실제 값이 복사되며, 이후에 복사된 변수를 변경하더라도 원본 변수에는 영향을 주지 않습니다.\r\n\r\n    \r\n\r\n    **즉, 원시값은 깊은 복사가 일어난다라고 기억합시다.**\r\n\r\n    \r\n\r\n- 얕은 복사가 중첩구조를 복사하지 못하는 이유 → spread 연산자의 작동 원리\r\n\r\n    \r\n\r\n    ****Spread Operator****\r\n\r\n    \r\n\r\n    전개 연사자가 호출될 때, 내부적으로는 *iterator-looping* 액션을 수행한다. 조금 더 자세히 설명하자면, 어떤 객체에 `[Symbol.iterator]` 프로퍼티가 존재한다면 이터러블하다고 할 수 있고 반복문을 돌릴 수 있다.\r\n\r\n    \r\n\r\n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6cc6d816-da46-4235-b522-824a78e5affd%2FUntitled.png?table=block&id=4f502988-3f91-400d-bb24-9acadaef8dc8&spaceId=78e0979c-6197-4792-a235-719f1075b969&width=1020&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    //스프레드 연산자에 의한 객체 얕은 복사\r\n\r\n    const b = [1, 2, 3];\r\n\r\n    const a = [ ...b ];\r\n\r\n    \r\n\r\n    // 내부 동작 원리\r\n\r\n    if (!(Typeof(b) is Iterable)) {\r\n\r\n      throw TypeError\r\n\r\n    }var a = [];\r\n\r\n    for (var i = 0; i < b.length; i += 1) {\r\n\r\n      a.push(b[i]);\r\n\r\n    }\r\n\r\n    ```\r\n\r\n    \r\n\r\n\r\n\r\n**얕은 복사와 깊은 복사의 선택은 데이터 구조의 복잡도와 성능 요구 사항에 따라 달라질 수 있습니다. 데이터 구조에 대한 이해와 상황에 맞는 선택이 중요합니다.*\r\n\r\n\r\n\r\n참조\r\n\r\n\r\n\r\n[얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)](https://dori-coding.tistory.com/entry/JavaScript-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%ACShallow-Copy%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%ACDeep-Copy)\r\n\r\n\r\n\r\n[얉은 복사, 깊은 복사 그리고 React의 리렌더링](https://velog.io/@jellybrown/ReactJS-%EC%96%89%EC%9D%80-%EB%B3%B5%EC%82%ACShallow-Copy-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%ACDeep-Copy-%EA%B7%B8%EB%A6%AC%EA%B3%A0-React%EC%9D%98-%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81)\r\n\r\n\r\n\r\n[얉은 복사, 깊은 복사](https://podocoding.tistory.com/48)\r\n\r\n\r\n\r\n[리액트 불변성이란 무엇이고, 왜 지켜야 할까?](https://hsp0418.tistory.com/171)\r\n\r\n\r\n\r\n추가자료\r\n\r\n\r\n\r\n[비전공자용 자바스크립트 deep copy, shallow copy 설명](https://www.youtube.com/watch?v=JtrOxaTvOEM), 큰돌\r\n\r\n\r\n\r\n[state가 array/object면](https://www.youtube.com/watch?v=jAFogNao6CA&list=PLfLgtT94nNq0qTRunX9OEmUzQv4lI4pnP&index=5), 코딩애플",
        "qna": ""
      },
      {
        "id": "28",
        "title": "JavaScript",
        "topic": "1. ==(동등)과 ===(일치)의 차이점 / 2. 컴파일러 언어와 인터프리터 언어",
        "texture": "---\r\n\r\n### **Q. 동등 연산자(==)와 일치 연산자(===)의 차이점을 설명해주세요.**\r\n\r\n\r\n\r\n- 동등 연산자(==)와 일치 연산자(===)는 모두 피연산자에 값을 비교하고 Boolean값을 반환합니다. 동등 연산자는 오직 값에 대한 비교를 수행하지만, 일치 연산자는 값과 자료형 모두를 비교합니다.\r\n\r\n    \r\n\r\n    동등 연산자는 두 값을 비교할 때 숫자형으로 강제 형변환(type coercion)을 진행합니다. 즉, 비교하는 데이터의타입 다르더라도 자동으로 형변환을 수행한 후에 비교를 진행합니다. 이러한 형변환은 때로 예측하지 못한* 결과를 초래하므로 동등 연산자를 사용할 때에는 주의가 필요합니다.  따라서 두 값의 자료형과 값이 모두 같은지 비교하는 일치 연산자를 사용하는 것이 형변환 없이 더 안전하고 정확한 값을 비교할 수 있습니다.\r\n\r\n    \r\n\r\n\r\n\r\n```jsx\r\n\r\n'1' == 1 // t   \r\n\r\n\r\n\r\n10 == '10' // t\r\n\r\n\r\n\r\n0 == false // t\r\n\r\n\r\n\r\n1 == true // t\r\n\r\n\r\n\r\n'' == false // t\r\n\r\n\r\n\r\n0 == '' // t \r\n\r\n\r\n\r\n------\r\n\r\nlet a = 0;\r\n\r\nalert( Boolean(a) ); // false\r\n\r\n\r\n\r\nlet b = \"0\";\r\n\r\nalert( Boolean(b) ); // true\r\n\r\n\r\n\r\nalert(a == b); // true!\r\n\r\n\r\n\r\nfalsy값: false, 0, \"\", undefined, null, NaN\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n0 === false // false\r\n\r\n\r\n\r\n0 === '' // false\r\n\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n### Q. 컴파일 언어(compilation)와 인터프리터 언어(interpretation)의 차이는 무엇인가요?\r\n\r\n\r\n\r\n- 컴파일 언어의 경우, 소스코드(사용자가 작성한 원시코드)를 다른 형태인 기계어로 전부 변환 시킨 후 코드를 실행하는 언어이며, 대표적으로는 C, C++, 자바 등이 있다. 인터프리터 언어는 소스코드를 기계어로 변환하는 과정 없이 한 줄씩 실시간으로 해석하며 바로 실행하는 언어이다. JavaScript, Python, Ruby 등이 있다.\r\n\r\n    \r\n\r\n    보통 컴파일 언어는 코드 실행전 기계어나 다른 코드로 먼저 ‘번역’하는 과정을 거친다고하며, 인터프리터 언어는 컴파일 과정을 미리 거치지 않고 컴퓨터에 설치된 프로그램인 인터프리터를 거쳐 실시간으로 소스코드를 ‘통역’해주는 것으로 많은 비유를 한다.\r\n\r\n    \r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd7f6b36f-a601-4b3d-bfa8-a2992926077b%2FUntitled.png?table=block&id=8445c167-b6cc-4587-b3e3-3a7aea822723&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n컴파일 언어는 프로그래밍 언어로 짠 코드 컴파일이란 과정을 통해 다른 형태 (기계어)로 바꿔준다. 그 결과물을 실행하는 것이 컴파일 언어의 특성이다. 반면 인터프리터 언어는 코딩 후 다른 과정을 거치지 않고 코드가 그대로 실행할 곳으로 보내져서 인터프리터라는 프로그램을 통해 곧바로 통역되어 실행된다.\r\n\r\n\r\n\r\n<aside>\r\n\r\n✅ 컴파일러 (compiler)\r\n\r\n\r\n\r\n- 전체 파일을 스캔하여 한꺼번에 번역\r\n\r\n- 초기 스캔시간이 오래 걸리지만, 한번 실행 파일이 만들어지고 나면 빠르다.\r\n\r\n- 대표적인 언어로 C, C++\r\n\r\n</aside>\r\n\r\n\r\n\r\n<aside>\r\n\r\n✅ 인터프리터 (interpreter)\r\n\r\n\r\n\r\n- 한번에 한문장씩 번역후 실행 시키기 때문에 실행 시간이 느리다.\r\n\r\n- 프로그램을 실행시키고 나서 오류를 발견하면 바로 실행을 중지 시킨다. 실행 후에 오류를 알 수 있다.\r\n\r\n- • 대표적인 언어로 Python, Ruby, Javascript 등\r\n\r\n</aside>\r\n\r\n\r\n\r\n- *Java는 하이브리드 언어다.*\r\n\r\n    \r\n\r\n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7bc667fb-6f0a-47b2-a809-318f53c3170b%2FUntitled.png?table=block&id=c7f60d45-3cb7-4d3d-9c1d-b6d5022c95f6&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1670&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n    \r\n\r\n    Java는 다른 컴파일 언어들이 작동하듯이 컴파일러를 이용해 전체 코드를 한번에 번역한다. 여기서 사용하 컴파일러를 **자바 컴파일러(Java Compiler)**라고 하며, 이 자바 컴파일러는 우리가 작성한 Java 코드를 **자바 가상 머신(Java Virtual Machine, JVM)**이 실행시킬 수 있는 **자바 바이트 코드**로 번역한다. \r\n\r\n    \r\n\r\n    하지만 자바 바이트 코드는 자바 가상 머신(JVM)의 **자바 인터프리터(Java Interpreter)**를 이용해 한 줄씩 실행된다.자바 바이트 코드로 작성되어 있는 실행 프로그램을 자바 인터프리터가 한 줄씩 읽으면서 컴퓨터가 이해할 수 있는 2진 코드로 번역한 후 실행시킨다는 뜻이다.\r\n\r\n    \r\n\r\n    그래서 Java는 하이브리드 언어라는 괴상한 이름으로 불린다. 컴파일 언어와 인터프리터 언어를 혼합한 형태의 언어라는 의미인데, 처음에는 인터프리터 언어로써 사용되다가, 성능 향상을 위하여 컴파일 언어의 장점을 가져왔다고 한다.\r\n\r\n    \r\n\r\n\r\n\r\n**정적 타입과 동적 타입의 특성**\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4630695e-2692-4112-9798-628a2e95867b%2FUntitled.png?table=block&id=d3d591f3-2e3b-48d4-929f-5946469ed73b&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n컴파일 언어는 정적 타입의 언어이다. 변수 등에 지정된 자료형을 바꿀 수 없다. 컴파일 시에 자료형에 맞지 않은 값이 들어있으면 컴파일 에러가 발생한다. 하지만 컴파일 시에 타입에 대한 정보를 결정하기 때문에 실행시 속도가 빠르고, 타입 에러로 인한 문제점을 초기에 발견할 수 있어 타입의 안정성을 높혀준다.\r\n\r\n\r\n\r\n반면 인터프리터 언어는 동적 타입의 언어이다. 변수에 다른 자료형의 값(숫자형, 문자형)을 넣을 수 있다. 자료형의 일관성이 강제되지 않기 때문에 자유롭고 편한 프로그래밍이 가능하지만, 실행 시점이 되어서야 오류가 확인되거나 잘못된 자료형에 의한 오류의 위험성이 높다. JavaScript도 이런 한계를 갖는데, 이를 보완하고자 정적 타입의 TypeScript가 탄생했다.  프로그래밍 할때에는 타입스크립트로 안정적이게, 배포할 떄에는 js로 빌드해서 사용한다.\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa9965159-fd05-4b48-95dd-9d481e855c94%2FUntitled.png?table=block&id=1345a313-250c-4883-b932-478031682857&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n*이 작업을 언제 실행하느냐에 따라 둘 중 한 범주(컴파일 언어, 인터프리터 언어)에 들어가게 됩니다. 사실 컴파일 언어에도 인터프리터가 있고, 인터프리터 언어에서도 컴파일 과정이 있다고 한다. 그렇기 때문에  해당 구분이 절대적인 것은 아니며, 어디까지나 일반적인 ‘경향’으로 기억하면 된다.*\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F81dd8d34-a398-4650-a122-76cad10f32f1%2FUntitled.png?table=block&id=c738926e-c858-450e-a602-eaf0f956077c&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2ac6d39c-0ca0-41d1-923e-63c6a1f9367b%2FUntitled.png?table=block&id=f3e2b03a-0554-457b-a668-1ee727c8bf35&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n[인터프리터와 컴파일러 (한국어 자막을 켜고 보세요)](https://www.youtube.com/watch?v=Dx2tSsd3aFc)\r\n\r\n\r\n\r\n[자료형과 정적/동적 타입 (+ 컴파일/인터프리터 언어와의 관계)](https://www.youtube.com/watch?v=50N_NiDUKpw)",
        "qna": ""
      }
    ]
  },
  {
    "title": "JavaScript",
    "items": [
      {
        "id": "1",
        "title": "JavaScript",
        "topic": "객체",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "2",
        "title": "JavaScript",
        "topic": "상속",
        "texture": "# 1. 주제 선정 이유\n\n코딩을 하다보면, 종종 상속이라는 용어를 많이 들어봤을 것이다. 물론, 상속의 사전적인 개념인 '하위존재가 상위존재로부터 무언가를 물림받는다.' 는 것 정도는 유추할 수 있을 것이다. 하지만, 코딩이나 IT업계에서 언급하는 상속에 대해 제대로 알고 넘어가는 것이 실제로 프로젝트에 적용할 때, 보다 수월하고 익숙하게 사용할 수 있을 것이기에 선정했다.\n\n# 2. 상속\n\n## 2-1. 상속의 정의 및 종류\n\n- 자바스크립트에서 사용되는 상속은 프로토타입 상속과 클래스 상속 크게 두 가지로 나뉜다. \n- 프로토타입 상속 : 상속을 받든 객체가 상속을 해주는 객체의 프로퍼티나 메서드를 추가로 사용할 수 있게 해주는 체계를 의미한다. \n- 클래스 상속 : 기존의 클래스를 확장시키는 개념으로 이해하면 좋다. 상속받은 기존의 클래스를 토대로 새로운 기능을 추가하는 시스템을 의미한다.\n\n## 2-2. 프로토타입과 상속의 관계\n\n- 프로토타입 (객체) : 다른 객체에 대한 참조 하는 대상을 의미한다. 모든 객체는 [[prototype]]이라는 내부 프로퍼티를 갖는다. [[prototype]]를 저장창고라고 이해면 좋다.\n\n - 예를 들어, 아래의 경우, 전부 객체로 이루어져있기에 객체의 프로토타입은, [[prototype]] : Object 즉, Object.prototype이다. 그리고 상속받는 객체들이 [[prototype]]안으로 들어간다. \n- `__proto__` : 객체가 자신의 프로토타입에 접근하도록 해주는 접근자 프로퍼티이다. 일종의 **다리(bridge)**라고 이해하면 좋을 듯하다. 해당 프로퍼티를 사용하여 상속받을 객체가 자신의 프로토타입에 들어갈 수 있도록 연결해준다. \n - 즉, `__proto__` 를 사용하여 상위(부모) 객체가 하위(자식) 객체의 프로토타입에 추가되는 과정을 상속이라고 한다.\n\n![사진](https://velog.velcdn.com/images/dainel-q/post/0ba7368c-6a60-4f68-8da4-be69a0422c37/image.png) \n\n## Q. 그런데 왜 프로토타입 상속을 하는 것인가요??\n\n -우선은 한 사례를 통해 살펴보자\n\n![사진](https://velog.velcdn.com/images/dainel-q/post/7f14b541-0997-4b62-b31f-86a9e4328d7c/image.png)\n - 위 예시의 경우, food를 상속받은 pasta 객체가 cook이라는 메서드를 자유롭게 사용할 수 있는 사례이다. 즉, pasta 객체에서 cook메서드를 더 만들지 않고 상속받아 편하게 사용할 수 있다는 것을 의미한다. 이는 곧, 코드의 재사용성을 높이고 , 관리를 용이하게 해준다는 장점을 갖고 있다.\n\n## 2-3. 클래스와 상속의 관계\n\n- 클래스(class) : 하나의 생성자 함수를 여러개 찍어낼 수 있게 해주는 문법으로 흔히 붕어빵 틀에 비유한다. - 먼저 상속을 할 부모 클래스를 생성한다.\n\nclass Food {\n constructor (name) {\n this.name = name;\n this.won = 0;\n }\n\n price(won) {\n this.won = won;\n console.log(${this.name}의 가격은 ${this.won}원 입니다.)\n }\n\n pay(){\n console.log(${this.won}원을 지불하셨습니다.)\n }\n}\n\nconst food = new Food('음식');\n\nclass Pasta extends Food {\n tasty(){\n console.log(${this.name} 맛있네요!)\n }\n}\n\nconst pasta = new Pasta('아라비따 파스타');\n\n- 위 예시를 합치면\nclass Food {\n constructor (name) {\n this.name = name;\n this.won = 0;\n }\n\n price(won) {\n this.won = won;\n console.log(${this.name}의 가격은 ${this.won}원 입니다.)\n }\n\n pay(){\n console.log(${this.won}원을 지불하셨습니다.)\n }\n}\n\nconst food = new Food('음식');\n\nclass Pasta extends Food {\n tasty(){\n console.log(${this.name} 맛있네요!)\n }\n}\n\nconst pasta = new Pasta('아라비따 파스타');\n\n- pasta클래스는 food 클래스를 상속받고 있다는 것을 의미한다. 그렇기에 food클래스의 메서드를 사용할 수 있다.\npasta.price(12000; // 아라비따 파스타의 가격은 12000원 입니다.\npasta.pay(12000); // 12000원을 지불하셨습니다.\npasta.tasty(); // 아라비따 파스타 맛있네요!\n\n## Q. 그런데 왜 클래스 상속을 하는 것인가요??\n\n- 프로토타입의 상속을 하는 이유와 유사하게, 상속을 주고 받기에, 작성해야할 코드의 양이 줄어든다. 특히, 클래스의 경우, 생성자 메서드등 작성해야할 내용이 많기에, 상속의 장점이 더욱 부각된다. - 코드의 재사용성을 높이고 , 관리를 용이하게 해준다는 장점이 있기 때문에 사용한다.",
        "qna": "# 3. 요약 정리 및 면접형 QnA\n\nQnA: 자바스크립트에서 사용하는 상속은 무엇이고, 그 기능이 무엇인가요?\n\n상속은 상속받는 자식요소가 상속해주는 부모요소의 프로퍼티나 메서드를 **추가로** 사용할 수 있도록 **확장**해주는 기능입니다. 자바스크립트의 경우, **프로토타입 상속**과 **클래스 상속** 두 가지 유형의 상속이 있습니다.\n\n- 프로토타입의 상속은, 객체 안의 `[[prototype]]`라는 내부 프로퍼티 안에 `__proto__`라는 접근자 프로퍼티로 객체들을 상속받아 저장하여 사용합니다.\n- 클래스 상속은, 부모 클래스를 `extends`라는 키워드를 사용하여 자식 클래스가 상속받아 사용합니다.\n\n상속을 사용하는 이유는 코드의 재사용성을 높이고, 유지보수가 필요한 경우 특정 부분만 수정해도 되기에 관리를 용이하게 만든다는 장점이 있습니다."
      },
      {
        "id": "7",
        "title": "JavaScript",
        "topic": "이벤트 버블링",
        "texture": " ## 1.  정의 : \n\n🎯 이벤트 버블링(event bubbling)은 HTML에서 이벤트가 발생했을 때, 해당 요소에서 이벤트가 처리된 후, **상위 요소로 이벤트가 전파되는 현상**을 말합니다. *(Trigger clicks all the way up)* 이벤트 버블링은 이벤트가 전파되는 동안 부모 요소에서도 이벤트를 감지할 수 있다는 **장점**이 있습니다. 즉, 이벤트를 처리하는 핸들러 함수를 부모 요소에 등록해놓으면, 자식 요소에서 발생한 이벤트도 모두 처리할 수 있습니다. 이를 활용하면, 여러 개의 하위 요소에서 발생하는 이벤트를 하나의 이벤트 핸들러로 바인딩하는 **이벤트 위임 처리**를 할 수 있습니다.\n\n![이벤트 버블링](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F58daf214-1434-4922-8f83-d22f9ea4129c%2FUntitled.png?table=block&id=db53aae9-446e-4eda-9c51-6781a607031b&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1440&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이벤트 버블링\n\n\n![이벤트 흐름 3단계](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6ad187ed-1aaf-4bdf-8294-3dec2e6e6ead%2FUntitled.png?table=block&id=28e1fbd7-40fa-4f4e-94cb-6e26b17b0ff7&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1280&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이벤트 흐름 3단계\n\n```jsx\n//이벤트 버블링\n<style>\n    body * {\n      margin: 10px;\n      border: 1px solid rgb(255, 2, 74);\n    }\n</style>\n\n    <div class='DIV1'>\n      DIV1\n      <div class='DIV2'>\n        DIV2\n        <div class='DIV3'>DIV3</div>\n      </div>\n    </div>\n\n<script>\nconst divs = document.querySelectorAll('div');\n\nconst clickEvent = (e) => {\n  console.log(e.currentTarget.className);\n};\n\ndivs.forEach((div) => {\n  div.addEventListener('click', clickEvent);\n});\n\n</script>\n```\n\n```jsx\n//onclick\n<body>\n  <div class='DIV1'>\n    DIV1\n    <div class='DIV2'>\n      DIV2\n      <div class='DIV3'>DIV3</div>\n    </div>\n  </div>\n\n  <script>\n    const divs = document.querySelectorAll('div');\n\n    divs.forEach((div) => {\n      div.addEventListener('click',function(event){\n        console.log(event.currentTarget.className);\n      };\n    });\n\n  </script>\n</body>\n```\n\n\n## 2.  내용:\n- 이벤트 전파(흐름)가 있는 이유\n\n    *이벤트 전파란*: 브라우저는 사용자로부터 이벤트가 발생하면 가장 상단의 요소부터 하위의 요소까지 내려오고 다시 거슬러 올라가는 식으로 이벤트를 전달하여 발생하도록 한다.\n    \n    - 논리적 측면\n    \n    어쩌면 당연할지도 모르지만, 자식 요소가 부모 요소 영역 안에 위치하고 있기 때문에, 자식 요소만을 클릭했다고 그것은 부모 요소도 클릭한 셈이 되기 때문이다.\n    \n    - 성능적 측면\n    \n    이런 특징은 이벤트 등록 코드를 줄일 수 있는 장점이 있음. 여러개의 리스트가 있다고하고, 몇번째를 클릭하든 같은 종류의 이벤트를 발생시키고 싶다고하자. 그러면 일일히 이벤트를 등록해야하는데, 부모요소인 ul에만 이벤트 등록을하면, 전파에 의해 어떠한 li를 클릭해도 이벤트를 사용할 수 있음. 이를 이벤트 위임이라고 한다.\n    \n- **이벤트 버블링과 캡쳐링의 차이점에 대해서 구분해서 인지한다.**\n    \n    **이벤트 캡처링**\n    \n    이벤트가 하위 요소로 전파되는 단계. 캡처링은 버블링과는 반대로 최상위 태그에서 해당 태그를 찾아 내려간다.\n    \n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1baa6ba7-8fc6-41f1-883a-b79ea096ddca%2FUntitled.png?table=block&id=07802a68-ab20-4e72-8b71-8a07315494bd&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1840&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n    \n    위 그림처럼 특정 이벤트가 발생했을 때 최상위 요소인 body 태그에서 해당 태그를 찾아 내려갑니다. 캡처링 단계를 이용해야 하는 경우는 흔치 않기 때문에, 캡처링 단계에서 이벤트를 잡아내려면 `addEventListener` 의 옵션 객체에 `{ capture: true }` 또는 `true` 를 설정해주면 캡처링을 구현할 수 있다.\n    \n    ```jsx\n    target.addEventListener('이벤트', 콜백 함수, {capture:ture});\n    target.addEventListener('이벤트', 콜백 함수, true);\n    ```\n    \n    - `false`이면(default 값) 핸들러는 버블링 단계에서 동작합니다. (*default 값은 false이고 생략가능합니다.*)\n    - `true`이면 핸들러는 캡처링 단계에서 동작합니다.\n    \n    ```jsx\n    //이벤트 캡처링\n    <style>\n        body * {\n          margin: 10px;\n          border: 1px solid rgb(255, 2, 74);\n        }\n    </style>\n    \n    <body>\n        <div class='DIV1'>\n          DIV1\n          <div class='DIV2'>\n            DIV2\n            <div class='DIV3'>DIV3</div>\n          </div>\n        </div>\n      </body>\n    \n    <script>\n    const divs = document.querySelectorAll('div');\n    \n    const clickEvent = (event) => {\n      console.log(event.currentTarget.className); //DIV1 DIV2 DIV3\n    };\n    \n    divs.forEach((div) => {\n      div.addEventListener('click', clickEvent, { capture: true });\n    // {capture: true} 대신, true를 써줘도 됩니다.\n    });\n    </script>\n    ```\n    \n- **이벤트 위임 패턴을 이해한다.**\n    \n    이벤트 위임(Event Delegation)이란 ‘**하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식**’입니다. 캡처링과 버블링을 활용하면 강력한 이벤트 핸들링 패턴인 *이벤트 위임(event delegation)* 을 구현할 수 있습니다. \n    \n    ```html\n    <h1>오늘의 할 일</h1>\n      <ul class='itemList'>\n        <li>\n          <input type='checkbox' id='item1'>\n          <label for='item1'>이벤트 버블링 학습</label>\n        </li>\n        <li>\n          <input type='checkbox' id='item2'>\n          <label for='item2'>이벤트 캡쳐 학습</label>\n        </li>\n      </ul>\n      <script>\n        //이벤트 위임 전, 각 인풋 박스의 요소에 클릭 이벤트 리스너를 추가\n        var inputs = document.querySelectorAll('input');\n        inputs.forEach(function (input) {\n          input.addEventListener('click', function (event) {\n            alert('clicked');\n          });\n        });\n    \n        //이벤트 위임 후\n        // var itemList = document.querySelector('.itemList');\n        // itemList.addEventListener('click', function (event) {\n        //   alert('clicked');\n        // });\n    \n        // 새 리스트 아이템을 추가하는 코드,  새 리스트를 추가할 때에는, li가 2개가 있는 시점 다음이기 때문에, 새로 생기는 li들은 이벤트가 적용되지 않는다.\n        // var itemList = document.querySelector('.itemList');\n    \n        // var li = document.createElement('li');\n        // var input = document.createElement('input');\n        // var label = document.createElement('label');\n        // var labelText = document.createTextNode('이벤트 위임 학습');\n    \n        // input.setAttribute('type', 'checkbox');\n        // input.setAttribute('id', 'item3');\n        // label.setAttribute('for', 'item3');\n        // label.appendChild(labelText);\n        // li.appendChild(input);\n        // li.appendChild(label);\n        // itemList.appendChild(li);\n      </script>\n    ```\n    \n    **이벤트 위임의 목적?**\n    \n    ```html\n    <div id='div-content'>\n      <span id='span-content'>\n        <button id='btn'>버튼</button>\n      </span>\n    </div>\n    ```\n    \n    [이벤트 위임 사용 전]\n    \n    ```jsx\n    // 개별 요소를 접근해야함\n    const divNode = document.getElementById('div-content');\n    const spanNode = document.getElementById('span-content');\n    const btnNode = document.getElementById('btn');\n    \n    // 개별 요소마다 이벤트 리스너를 등록해야함\n    divNode.addEventListener('click', function () {\n      console.log('divNode Click');\n    });\n    \n    spanNode.addEventListener('click', function () {\n      console.log('spanNode Click');\n    });\n    \n    btnNode.addEventListener('click', function () {\n      console.log('btnNode Click');\n    });\n    ```\n    \n    여러 개의 이벤트 리스너를 등록하면 이벤트 버블링에 의해 상위 요소의 이벤트 리스너도 실행됩니다. 이벤트 버블링에 의해 <button> 태그에서 click 이벤트가 발생하면, 해당 이벤트는 최상위 객체인 Document까지 전파됩니다. 위 코드의 문제점은 **상위 요소의 이벤트도 실행**함으로써 t상위 요소 이벤트 리스너에 문제가 되는 코드가 존재한다면.. 개발자가 **원하지 않는 결과**를 발생시킬 수 있습니다.\n    \n    ![img.gif](https://file.notion.so/f/s/dca28498-1342-48a1-82a7-a0de390e9738/img.gif?id=46fee168-0dc5-48ad-b4a1-40e24cb2fbd3&table=block&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&expirationTimestamp=1693972800000&signature=I1B4tmgdogxyH1hH2MyUOkK_4o7GyueSUAB94zxKkx4)\n    \n    [이벤트 위임 적용 후]\n    \n    - JavaScript에서 함수는 객체입니다. 함수가 많을수록 메모리 사용량이 증가하고 함수가 적을수록 메모리 사용량이 감소합니다.\n    - 이벤트 위임을 적용하면 조건문에 의해 원하는 요소에 원하는 동작을 수행하도록 코드를 구현할 수 있습니다.\n    - 코드의 간결화, 메모리 사용량 감소, 성능향상,\n    \n    ```jsx\n    // 상위 요소인 id가 'div-content'인 div 노드만 접근함\n    const divNode = document.getElementById('div-content');\n    \n    // div 노드에만 이벤트 리스너를 설정\n    divNode.addEventListener('click', function (e) {\n      const tagName = e.target.tagName;\n    \n      if (tagName === 'DIV') {\n        console.log('div Click');\n      } else if (tagName === 'SPAN') {\n        console.log('span id Click');\n      } else if (tagName === 'BUTTON') {\n        console.log('button Click');\n      }\n    });\n    ```\n    \n- stopPropagation() 이란?\n    \n    *이렇게 복잡한 이벤트 전달 방식 알고 싶지 않고, 그냥 원하는 화면 요소의 이벤트만 신경 쓰고 싶어요. →* Event객체의  **`stopPropagation()` 메서드를 활용해서 현재 이벤트가 캡처링/버블링 단계에서 더 이상 전파되지 않도록 방지합니다.\n    \n    *이벤트 버블링의 경우*에는 **클릭한 요소의 이벤트만 발생시키고 상위 요소로 이벤트를 전달하는 것을 방해**합니다. *이벤트 캡쳐의 경우*에는 **클릭한 요소의 최상위 요소의 이벤트만 동작시키고** 하위 요소들로 이벤트를 전달하지 않습니다.\n    \n    ```html\n    <div class='DIV1'>\n        DIV1\n        <div class='DIV2'>\n          DIV2\n          <div class='DIV3'>DIV3</div>\n        </div>\n    ```\n    \n    ```jsx\n    //캡처링 stopPropagation()\n    <script>\n    const divs = document.querySelectorAll('div');\n\n    const clickEvent = (event) => {\n      event.stopPropagation();\n      console.log(event.currentTarget.className); //DIV1\n    };\n    \n    divs.forEach((div) => {\n      div.addEventListener('click', clickEvent, { capture: true });\n    });\n    </script>\n    ```\n    \n    ```jsx\n    //버블링 stopPropagation()\n    <script>\n    const divs = document.querySelectorAll('div');\n    \n    const clickEvent = (event) => {\nevent.stopPropagation();\n      console.log(event.currentTarget.className); //DIV3\n};\n\ndivs.forEach((div) => {\ndiv.addEventListener('click', clickEvent);\n});\n</script>\n    ```",
        "qna": "추가해야함"
      },
      {
        "id": "8",
        "title": "JavaScript",
        "topic": "this",
        "texture": "## this\n\nthis는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. \n\nthis는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다. 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. \n\n단, 자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.\n\n🧐 **arguments 객체는 무엇인가..?** \n\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F928ac1fc-a7a3-487f-9694-5f63e231cfb8%2FUntitled.png?table=block&id=f0e6eeef-d205-4c31-9d05-6c0d9845c5ff&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1340&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n🧐 **this 바인딩**\n\n바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어, 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다. this 바인딩은 this와 this가 가리킬 객체를 바인딩하는 것이다. \n\n```jsx\n// this는 어디서든지 참조 가능하다.\n// 전역에서 this는 전역 객체 window를 가리킨다.\nconsole.log(this); // window\n\nfunction square(number) {\n\t// 일반 함수 내부에서 this는 전역 객체 window를 가리킨다.\n  console.log(this); // window\n\treturn number * number;\n}\nsquare(2);\n\nconst person = {\n\tname: 'Lee',\n\tgetName() {\n\t\t// 메서드 내부에서 this는 메서드를 호출한 객체를 가리킨다. \n    console.log(this); {name: 'Lee', getName: f}\n\t\treturn this.hame;\n  }\n};\nconsole.log(person.getName()); // Lee\n\nfunction Person(name) {\n\tthis.name = name;\n  // 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.\n  console.log(this); // Person {name: 'Lee}\n}\n\nconst me = new Person('Lee');\n```\n\n하지만 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반적으로 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다. 따라서 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다. 일반 함수 내부에서 this를 사용할 필요가 없기 때문이다. \n\n## 함수 호출 방식과 this 바인딩\n\n**this바인딩(this에 바인딩될 값)은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.** \n\n🧐**렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.**\n\n함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. 하지만 this 바인딩은 함수 호출 시점에 결정된다.\n\n함수를 호출하는 방식 \n\n1. 일반 함수 호출\n2. 메서드 호출\n3. 생성자 함수 호출\n4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출\n\n### 1. 일반 함수 호출\n\n기본적으로 this에는 전역 객체(global object)가 바인딩된다.\n\n```jsx\nfunction foo() {\n\tconsole.log(\"foo's this: \", this); // window\n  function bar() {\n\t  console.log(\"bar's this: \", this); // window\n  }\n  bar();\n}\nfoo();\n```\n\n전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.                                           \n\n다만 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 객체를 생성하지 않는 일반 함수에서 this는 의미가 없다. 따라서 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다.                                                                         \n\n일반 함수로 호출된 모든 함수(중첩함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.\n\n하지만 메서드 내에서 정의한 중첩 함수나 메서드에게 전달한 콜백 함수(보조 함수)가 일반 함수로 호출될 때 메서드 내의 중첩 함수 또는 콜백 함수의 this가 전역 객체를 바인딩하는 것은 문제가 있다. 중첩 함수 또는 콜백 함수는 외부 함수를 돕는 헬퍼 함수의 역할을 하므로 외부 함수의 일부 로직을 대신하는 경우가 대부분이다. 하지만 외부 함수인 메서드와 중첩 함수 또는 콜백 함수의 this가 일치하지 않는다는 것은 중첩 함수 또는 콜백 함수를 헬퍼 함수로 동작하기 어렵게 만든다. \n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n\tconsole.log(\"foo's this: \", this); // {value: 100, foo: f}\n    // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.\n    setTimeout(function () {\n\t\tconsole.log(\"callback's this: \", this); // window\n      console.log(\"callback's this.value: \", this.value); // 1\n    }, 100);\n  }\n};\n\nobj.foo()\n```\n\n메서드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메서드의 this 바인딩과 일치시키기 위한 방법은 다음과 같다. \n\n방법①\n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n  // this 바인딩(obj)을 변수 that에 할당한다.\n  const that = this;\n  \n  // 콜백 함수 내부에서 this 대신 that을 참조한다.\n  setTimeout(function () {\n\t\tconsole.log(that.value); // 100\n\t}, 100);\n }\n};\n\nobj.foo();\n```\n\n방법② \n\n- this를 명시적으로 바인딩할 수 있는 Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메서드 사용하기 \n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n\tfoo() {\n\t\t// 콜백 함수에 명시적으로 this를 바인딩한다.\n    setTimeout(function () {\n\t\t\tconsole.log(this.value); // 100\n    }.bind(this), 100);\n  }\n};\n\nobj.foo();\n```\n\n방법③ \n\n- 화살표 함수를 사용해서 this 바인딩을 일치시키기\n\n```jsx\nvar value = 1;\n\nconst obj = {\n\tvalue: 100,\n  foo() {\n\t\t// 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.\n  setTimeout(() => console.log(this.value), 100); // 100\n  }\n};\n\nobj.foo(); \n```\n\n### 2. 메서드 호출\n\n메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다. 주의할 것은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다. \n\n```jsx\nconst person = {\n\tname: 'Lee',\n  getName() {\n\t\t// 메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다. \n    console.log(this); {name: 'Lee', getName: f}\n\t\treturn this.name;\n  }\n};\n\n// 메서드 getName을 호출한 객체는 person이다.\nconsole.log(person.getName()); // Lee  \n```\n\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbbcb928d-8ddf-465c-909d-7af0fbd7215a%2FUntitled.png?table=block&id=68a5ce2d-c73a-4b2d-8220-561ff980a838&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1770&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n### 3. 생성자 함수 호출\n\n생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.\n\n```jsx\nfunction Circle(radius) {\n\t// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.\n  this.radius = radius;\n  this.getDiameter = function () {\n\t\treturn 2 * this.radius;\n  };\n}\n\n// 반지름이 5인 Circle 객체를 생성\nconst circle1 = new Circle(5);\n// 반지름이 10인 Circle 객체를 생성\nconst circle2 = new Circle(10);\n\nconsole.log(circle1.getDiameter()); // 10\nconsole.log(circle2.getDiameter()); // 20 \n```\n\n### 4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출\n\napply, call, bind 메서드는 Function.prototype의 메서드다. 즉 이들 메서드는 모든 함수가 상속받아 사용할 수 있다. \n\nFunction.prototype.apply,  Function.prototype.call 메서드는 this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 호출한다.\n\n```jsx\nfunction getThisBinding() {\n\treturn this;\n}\n\n// this로 사용할 객체\nconst thisArg = {a: 1};\n\nconsole.log(getThisBinding()); // window\n\n// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.\nconsole.log(getThisBinding.apply(this.Arg)); // {a: 1}\nconsole.log(getThisBinding.call(this.Arg)); // {a: 1} \n```\n\napply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다. \n\napply와 call 메서드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작한다. apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다. call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다. \n\n 그렇다면 apply와 call 메서드의 용도는 무엇일까? \n\napply와 call 메서드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice 같은 배열의 메서드를 사용할 수 없으나 apply와 call 메서드를 이용하면 가능하다. \n\n```jsx\nfunction convertArgsToArray() {\n\tconsole.log(arguments);\n\t\n\t// arguments 객체를 배열로 변환\n  // Array.prototype.slice를 인수 없이 호출하면 배열의 복사본을 생성한다. \n  const arr = Array.prototype.slice.call(arguments);\n  // const arr = Array.prototype.apply(arguments);\n  console.log(arr);\n \n  return arr;\n}\n\nconvertArgsToArray(1, 2, 3); // [1, 2, 3]\n\n```\n\nFunction.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않는다. 다만 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 새롭게 생성해 반환한다. \n\n```jsx\nfunction getThisBinding() {\n\treturn this;\n}\n\n// this로 사용할 객체\nconst thisArg - {a : 1};\n\n// bind 메서드는 첫 번째 인수로 전달한 thisArg로 this 바인딩이 교체된\n// getThisBinding 함수를 새롭게 생성해 반환한다.\nconsole.log(getThisBinding.bind(thisArg)); // getThisBinding\n// bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.\nconsole.log(getThisBinding.bind(thisArg())); // {a : 1}\n```\n\n그렇다면 bind메서드는 언제 사용할까? \n\n```jsx\nconst person = {\n\tname: 'Lee',\n  foo(callback) {\n   // ①\n  setTimeout(callback, 100);\n  }\n};\n\nperson.foo(function () {\n\tconsole.log(`Hi! my name is ${this.name}.`); // ② Hi my name is .\n  // 일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.\n  // 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 '' 이다.\n  // Node.js 환경에서 this.name은 undefined다.\n}); \n```\n\nperson.foo의 콜백 함수가 호출되기 이전인 ①의 시점에서 this는 foo 메서드를 호출한 객체, 즉 person 객체를 가리킨다. \n\n그러나 person.foo의 콜백 함수가 일반 함수로서 호출된 ②의 시점에서 this는 전역 객체 window를 가리킨다. 따라서 person.foo의 콜백 함수 내부에서 this.name은 window.name과 같다.\n\n이때 위 예제에서 person.foo의 콜백 함수는 외부 함수 person.foo를 돕는 헬퍼 함수(보조 함수) 역할을 하기 때문에 외부 함수 person.foo 내부의 this와 콜백 함수 내부의 this가 상이하면 문맥상 문제가 발생한다.\n\n따라서 콜백 함수 내부의 this를 외부 함수 내부의 this와 일치시켜야 한다. 이때 bind 메서드를 사용하여 this를 일치시킬 수 있다.",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. this에 대해서 설명해주세요.\n\n # A.\n\n this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. \n\n그리고 this가 가리키는 값, 즉 this 바인딩(this와 this가 가리킬 객체를 바인딩하는 것)은 함수 호출 방식에 의해 동적으로 결정된다."
      },
      {
        "id": "9",
        "title": "JavaScript",
        "topic": "이터러블",
        "texture": "### 🎈주제 선정 이유?\n\n호이스팅, 브라우저 렌더링 등과 같이 프론트엔드 기술면접 단골질문까진 아니지만, 부트캠프 수업에서 이터러블에 대해 자세히 다룬적이 없어서 이터러블에 대한 이해가 부족했다. 스터디원분들도 마찬가지가 아닐까 싶어서 공부도 할겸 이터러블로 주제를 선정하게 되었다.\n\n### ⛳ 이번 목표\n\n이터러블과 이터레이션에 대해 알아보자\n\n---\n\n### 1. 이터러블\n\n네이버 영어사전에 iterate를 찾아보면 반복하다라는 의미가 있다.\n\n![image](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2F3a892a75-8c16-4b62-9212-55d3a7bb89f8%2Fimage.png?table=block&id=281d1b41-c4b4-4463-baea-99cb8df016ab&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n이터러블 프로토콜을 준수한 객체를 이터러블이라한다. 즉, 이터러블은 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다.\n\n```javascript\n// Symbol.iterator를 프로퍼티 키로 사용한 메서드\n [Symbol.iterator]() {\n// 이터레이터 객체 반환\n}\n```\n\n예를 들어, 배열은 Array.prototype의 Symbol.iterator 메서드를 상속받는 이터러블이다. 이터러블은 for ... of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.\n\n Symbol.iterator 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다. 따라서 일반 객체는 for ... of 문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭쳐링 할당의 대상으로 사용할 수 없다.\n\n```javascript\n const obj = {a: 1, b: 2};\n\n// 일반 객체는 Symbol.iterator 메서드를 구현하거나 상속받지 않는다.\n// 따라서 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.\n console.log(Symbol.iterator in obj); // false\n\n// 이터러블이 아닌 일반 객체는 for ... of 문으로 순회할 수 없다.\n for (const item of obj) { // → TypeError: obj is not iterable\n console.log(item);\n}\n\n// 이터러블이 아닌 일반 객체는 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.\n const [a, b] = obj; // → TypeError: obj is not iterable\n```\n\n🤔 그렇다면 이터러블이 아닌 일반 객체는 스프레드 문법도 사용하지 못하겠다라는 생각이 들 수 있다. 하지만 스프레드 프로퍼티 제안(stage 4)은 일반 객체에 스프레드 문법의 사용을 허용한다고 한다.\n\n```javascript\nconst obj = {a: 1, b: 2};\n\n console.log({...obj})l // {a: 1, b: 2};\n```\n\n그리고 일반 객체도 이터러블 프로토콜을 준수하도록 구현하면 이터러블이 된다고 한다.\n\n### 2. 이터레이터\n\n이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 next 메서드를 소유하며 next 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. 이러한 규약을 이터레이터 프로토콜이라 하며, 이터레이터 프로토콜을 준수한 객체를 이터레이터라 한다.\n\n```javascript\n// 배열은 이터러블 프로토콜을 준수한 이터러블이다.\n const array = [1, 2, 3]; \n\n // Symbol.iterator 메서드는 이터레이터를 반환한다.\n const iterator = array[Symbol.iterator]();\n\n// Symbol.iterator 메서드가 반환한 이터레이터는next 메서드를 갖는다.\n console.log('next' in iterator); // true\n\n// next 메서드를 호출하면 이터러블을 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다.\n// 이터레이터 리절트 객체는 value와 done 프로퍼티를 갖는 객체다.\n console.log(iterator.next());  // { value: 1, done: false }\n console.log(iterator.next());  // { value: 2, done: false }\n console.log(iterator.next());  // { value: 3, done: false }\n console.log(iterator.next());  // { value: undefined, done: true }\n```\n\n### 3. 이터러블과 유사 배열 객체\n\n유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.\n\n유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있고, 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로 가지므로 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.\n\n```javascript\n// 유사 배열 객체\n const arrayLike = {\n0: 1,\n 1: 2,\n 2: 3,\nlength: 3\n};\n\n// 유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있다.\nfor (let i = 0; i < arrayLike.length; i++) {\n  // 유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.\n  console.log(arrayLike[i]); // 1 2 3\n}\n```\n\n🤔 그렇다면 유사 배열 객체는 배열처럼 for ... of 문으로 순회할 수 있을까..?\n\n이에 대한 답은 'NO' 이다. 유사 배열 객체는 이터러블이 아닌 일반 객체다. 따라서 유사 배열 객체에는 Symbol.iterator 메서드가 없기 때문에 for ... of 문으로 순회할 수 없다.\n\n```javascript\n// 유사 배열 객체는 이터러블이 아니기 때문에 for ... of 문으로 순회할 수 없다.\nfor (const item of arrayLike) {\n console.log(item);\n}\n// → TypeError: arrayLike is not iterable\n```\n\n유사 배열 객체이면서 이터러블인 것: arguments, NodeList, HTMLCollection\n\n정확히 말하면 ES6에서 이터러블이 도입되면서 유사 배열 객체인 arguments, NodeList, HTMLCollection 객체에 Symbol.iterator 메서드를 구현하여 이터러블이 되었다. 하지만 이터러블이 된 이후에도 length 프로퍼티를 가지며 인덱스로 접근할 수 있는 것에는 변함이 없으므로 유사 배열 객체이면서 이터러블인 것이다.\n\n→ 모든 유사 배열 객체가 이터러블인 것은 아니다. 유사 배열 객체 중에 이터러블인 것이 있고 아닌 것이 있다.\n\n배열도 마찬가지로 ES6에서 이터러블이 도입되면서 Symbil.iterator 메서드를 구현하여 이터러블이 되었다.\n\n위의 예제에서의 arrayLike 객체는 ES6에서 도입된 Array.from 메서드를 사용하여 배열로 간단히 변환할 수 있다.\n\nArray.from 메서드는 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환하여 반환한다.\n\n```javascript\n// 유사 배열 객체\nconst arraLike = {\n 0: 1,\n 1: 2,\n 2: 3,\n length: 3\n};\n\n// Array.from은 유사 배열 객체 또는 이터러블을 배열로 변환한다.\nconst arr = Array.from(arrayLike);\nconsole.log(arr); // [1, 2, 3]\n```\n\n### 4. 이터레이션 프로토콜의 필요성\n\n💡 그렇다면 왜 이터레이션 프로토콜의 필요한가에 대해 알아보자.\n\nES6 이전의 순회 가능한 데이터 컬렉션(배열, 문자열, 유사 배열 객체, DOM 컬렉션 등)등은 통일한 규약 없이 각자 나름의 구조를 가지고 for 문, for ... in 문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다. ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for ... of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화했다.\n\n이터러블은 for ... of 문, 스프레드 문법, 배열 디스트럭처링 할당과 같은 데이터 소비자에 의해 사용되므로 데이터 공급자의 역할을 한다고 할 수 있다.\n\n만약 다양한 데이터 공급자가 각자의 순회 방식을 갖는다면 데이터 소비자는 다양한 데이터 공급자의 순회 방식을 모두 지원해야 한다. 이는 효율적이지 않다. 하지만 다양한 데이터 공급자가 이터레이션 프로토콜을 준수하도록 규정하면 데이터 소비자는 이터레이션 프로토콜만 지원하도록 구현하면 된다.\n\n즉, 이터러블을 지원하는 데이터 소비자는 내부에서 Symbol.iterator 메서드를 호출해 이터레이터를 생성하고 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 이터레이터 리절트 객체를 반환한다. 그리고 이터레이터 리절트 객체의 value/done 프로퍼티 값을 취득한다.\n\n이처럼 이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 한다.\n\n![image](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2Fa6742119-741e-4d11-bed2-be5624695fdf%2Fimage.png?table=block&id=be23645f-ed39-49ff-aaea-0c029d41be29&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. 이터러블에 대해서 설명해주세요.\n\n # A.\n\n \n이터러블이란 반복이 가능한 객체를 말합니다.\n이터러블은 `Symbol.iterator` 메서드를 가지고 있는데, 이 메서드는 이터레이터를 반환하여, 이터러블 객체의 각 요소를 반복할 수 있도록 해줍니다.\n\n이터레이터는 이터러블 객체에서 값을 순차적으로 가져오는 법을 정의합니다.\n\n이터레이터는`next()`메서드를 호출할 때마다 이터러블 객체에서 다음 값을 가져오고, 가져올 값이 없을 경우 done 프로퍼티가 true인 객체를 반환합니다.\n\n 이터러블과 이터레이터 프로토콜을 사용하여, 다양한 자료구조를 반복할 수 있습니다. \n\n 예를 들어 배열, 문자열, Map, Set, NodeList 등의 객체는 모두 이터러블입니다. 따라서 for ... of 문이나 전개 연산자, 구조 분해 할당 등을 사용하여 이러한 객체를 반복하고 다룰 수 있습니다."
      },
      {
        "id": "10",
        "title": "JavaScript",
        "topic": "props drilling",
        "texture": "## 🎈주제 선정 이유?\n\n프로젝트에 필요한 redux toolkit에 대해 공부하다가, 상태관리가 등장한 배경에 대해서 궁금해져서 조사하게 되었다.\n\n## ⛳ 학습 목표\n\nprops drilling은 무엇이고 어떻게 피할 수 있는지에 대해 학습한다.\n\n## ⛏️ Props Drilling이란\n\n![이미지](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2Fec3d3141-98e0-4288-994c-a4b107e852de%2Fimage.png?table=block&id=c70b3d1b-cfa4-4727-adc8-0e31edd09ed2&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n`Props Drilling` 은 props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정이다.\n\n### 😀 Props Drilling의 장점\n\n- 컴포넌트 간에 데이터를 전달하는 가장 쉽고 빠르게 전달할 수 있다.\n- (작은 규모의 어플리케이션에서) 컴포넌트를 잘게 분할해서 Props drilling을 통해 전달하면, 코드를 실행하지 않고 정적으로 따라가는 것만으로도 어떤 데이터가 어디서 사용되는지 쉽게 파악할 수 있으며, 수정도 용이하다\n\n### 😱 그렇다면 Props Drilling이 문제인 이유는 무엇인가?\n\n어플리케이션의 규모가 커지고, 중간 컴포넌트의 수가 많아지게 되면서 불필요한 props 전달로 인해 유지보수도 어렵고 가독성도 떨어질 수 있다.\n\n- 필요보다 많은 props를 전달하다가, 컴포넌트를 분리하는 과정에서 필요하지 않은 props가 계속 남거나 전달되는 문제\n- props 전달이 누락되었는데 `defaultProps`가 과용되었을 때, props가 전달되지 않은 상황을 인지하기가 어려운 문제\n- 자세한 설명\n\n    (ChatGPT)>> 일반적으로, React에서 defaultProps는 props의 기본값을 정의하는 데 사용된다. 만약 상위 컴포넌트에서 하위 컴포넌트로 props를 전달하지 않았을 때, defaultProps에 정의된 기본값이 하위 컴포넌트에 자동으로 적용된다. 이는 기본적으로 컴포넌트가 동작하는 데는 문제가 없지만, 때로는 예상치 못한 동작이 발생할 수 있다.문제는, defaultProps를 과용하여 하위 컴포넌트에서 필요한 props를 전달하지 않아도 문제가 발생하지 않는다고 착각할 수 있다는 점이다. 실제로는 props가 전달되지 않은 상황에서도 defaultProps에 정의된 기본값이 사용되기 때문에, 버그를 파악하고 수정하는 데 어려움을 겪을 수 있다.따라서, Props Drilling을 사용할 때는 defaultProps를 신중하게 사용해야 합니다. 필요한 props가 명시적으로 전달되도록 하고, defaultProps는 최소한의 기본값 설정에 사용하는 것이 좋다. 이렇게 하면 props 전달이 누락되었을 때 실제로 문제가 발생하며, 이를 빠르게 인지하고 수정할 수 있게 된다.\n\n- props의 이름이 전달 중에 변경되어서 데이터를 추적하기 쉽지 않게되는 문제\n- 자세한 설명(ChatGPT)>> Props Drilling을 사용하면서 props의 이름이 중간 컴포넌트를 거치면서 변경되는 경우를 의미한다. 이는 props의 이름이 상위 컴포넌트에서 하위 컴포넌트로 전달되는 동안 수정되거나 재정의되어 데이터의 추적이 어려워지는 상황을 말한다.예를 들어, 상위 컴포넌트에서 하위 컴포넌트로 value라는 이름의 props를 전달한다고 가정해보자. 하지만 중간 컴포넌트에서 value를 받은 후 다른 이름으로 변경하거나 다른 컴포넌트에 전달할 수 있다. 이 경우 하위 컴포넌트에서는 원래 props 이름이 무엇이었는지 추적하기 어려워지고, 코드를 분석하거나 디버깅하기 어려워진다.이러한 상황에서는 코드의 가독성과 유지보수성이 저하될 수 있다. 특히 프로젝트가 커지고 여러 컴포넌트가 복잡하게 얽혀있을 때, props 이름의 변경이 제대로 추적되지 않으면 버그를 찾기 어려워진다.\n\n    (ChatGPT)>> Props Drilling을 사용하면서 props의 이름이 중간 컴포넌트를 거치면서 변경되는 경우를 의미한다. 이는 props의 이름이 상위 컴포넌트에서 하위 컴포넌트로 전달되는 동안 수정되거나 재정의되어 데이터의 추적이 어려워지는 상황을 말한다.예를 들어, 상위 컴포넌트에서 하위 컴포넌트로 value라는 이름의 props를 전달한다고 가정해보자. 하지만 중간 컴포넌트에서 value를 받은 후 다른 이름으로 변경하거나 다른 컴포넌트에 전달할 수 있다. 이 경우 하위 컴포넌트에서는 원래 props 이름이 무엇이었는지 추적하기 어려워지고, 코드를 분석하거나 디버깅하기 어려워진다.이러한 상황에서는 코드의 가독성과 유지보수성이 저하될 수 있다. 특히 프로젝트가 커지고 여러 컴포넌트가 복잡하게 얽혀있을 때, props 이름의 변경이 제대로 추적되지 않으면 버그를 찾기 어려워진다.\n\n### 🔧 그렇다면 이러한 Props Drilling으로 생기는 문제 피하는 방법은?\n\n1) 렌더링 될 컴포넌트를 불필요하게 여러 컴포넌트로 나누지 않는다.\n\nReact는 (권장되지는 않지만)단 하나의 컴포넌트에 어플리케이션 전체를 작성하더라도 기술적인 제약은 없다. 따라서 성급하게 불필요한 컴포넌트 쪼개기를 할 필요는 없다. 컴포넌트를 재사용해야할 상황을 기다렸다 분할해도 늦지 않으며, 불필요한 prop drilling도 하지 않을 수 있다.\n\n2) defaultProps를 필수 컴포넌트에 사용하지 않는다.\n\ndefaultProps를 사용하면 컴포넌트가 제대로 동작하기 위해 꼭 필요한 props가 전달되지 못한 상황에도 중요한 오류가 가려지게 된다. 따라서 defaultProps를 필수적이지 않은 컴포넌트에만 사용하면 prop drilling으로 인한 문제를 막을 수 있다.\n\n3) 가능한 관련성이 높은 곳에 state를 위치 시킨다.\n\n어떤 데이터가 어플리케이션의 특정 위치에서만 필요하다면 최상위 컴포넌트에 state를 위치시키는 것보다 해당 데이터를 필요로 하는 최소 공통 부모 컴포넌트에서 관리를 하는 것이 가장 효율적이다.\n\n4) 상태관리 도구를 사용한다.\n\n데이터를 필요로 하는 컴포넌트가 정말 깊숙히 위치하고 있다면, React에서 제공하는 Context API를 사용하거나 Redux 등의 외부 상태관리 라이브러리를 사용해서 문제를 해결할 수 있다. 물론 어플리케이션의 모든 곳에서 이와 같은 도구를 사용해야하는 것은 아니지만, 비교적 손쉽게 문제를 해결할 수 있다.\n\n### Context API\n\nReact에 내장되어 컴포넌트 트리 전체에 데이터를 제공할 수 있는 API이다.\n\n장점\n\n- Redux는 무겁고 복잡한 라이브러리이다. 따라서 상태관리가 아닌 단순히 props를 전달할 목적이라면 context API를 사용하는 것이 적절하다.\n\n단점\n\n- Context API에서 상태값이 변경되면, provider로 감싼 모든 자식 컴포넌트가 리렌더링이 된다. 리렌더링은 성능에 영향을 미칠 수 있기 때문에 때문에 자식 컴포넌트의 불필요한 리렌더링을 방지해야한다.\n\n### Redux\n\n오픈 소스 자바스크립트 라이브러리로 state를 사용해 애플리케이션의 전역 상태 관리를 위해 사용한다.\n\n장점\n\n- 단방향 데이터 통신이 발생하기 때문에 데이터 흐름을 예측할 수 있고 디버깅에 유리하다.자세한 설명(ChatGPT)>> Redux는 상태 관리 라이브러리로서, 애플리케이션의 데이터를 중앙 집중적으로 관리하고 상태 변화를 예측 가능한 방식으로 처리한다. 이는 단방향 데이터 흐름을 갖는 아키텍처를 채택하여 데이터의 변화를 추적하고 예측하기 쉽게 만든다.단방향 데이터 흐름은 데이터의 이동 경로가 일정하고 예측 가능하다는 의미이다. Redux에서는 데이터의 흐름이 '액션 → 리듀서 → 상태'의 단방향으로 이루어진다. 액션은 상태 변화에 대한 정보를 담은 객체이며, 리듀서는 액션을 기반으로 상태를 업데이트하는 순수 함수이다. 이러한 단방향 흐름으로 인해 데이터의 변화가 어떤 경로를 따라가는지 예측할 수 있고, 디버깅 시 데이터 변화를 추적하기 용이하다.\n\n단점\n\n- 무겁고 사용하기에 복잡하다.(이를 보완하기 위해 redux toolkit 등의 라이브러리가 등장하였다.)",
        "qna": "## 요약 정리 및 면접형 QnA\n\n # Q. Props drilling은 무엇이고 어떻게 피할 수 있는가?.\n\n # A.\n\n Props Drilling은 props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정입니다.\n\n이는 컴포넌트 간에 데이터를 전달하는 가장 쉽고 빠르게 전달할 수 있다는 장점이 있다. 하지만 어플리케이션의 규모가 커지고, 중간 컴포넌트의 수가 많아지게 되면서 불필요한 props 전달로 인해 유지보수도 어렵고 가독성도 떨어질 수 있다.\n\n이를 피하기 위해 컴포넌트를 리팩토링하고, 컴포넌트를 더 작은 컴포넌트들로 쪼개지 않고, state를 가장 가까운 부모 컨포넌트와만 공유함으로써 props drilling 회피할 수 있습니다. 위계상 멀리/깊게(deep/far)떨어진 컴포넌트와 state를 공유할 때, React의 \n\nContext API 혹은 Redux와 같은 state 관리 라이브러리를 사용할 수 있습니다."
      },
      {
        "id": "26",
        "title": "JavaScript",
        "topic": "이벤트 루프(event loop)에 관하여",
        "texture": "이벤트 루프는 자바스크립트에서 **비동기 처리**를 담당하는 *메커니즘이자* 장치입니다. 이벤트 루프는자바스크립트의 비동기 작업들을 큐(Queue)에 추가하고 작업들을 순차적으로 처리합니다. 이벤트 루프는 **싱글 스레드**로 동작하며, 이를 통해 자바스크립트가 비동기 처리를 하면서도 블로킹이나 데드락 등의 문제를 방지하여 더욱 안정적인 비동기 처리를 가능하게 합니다.\r\n\r\n- 이벤트 루프의 특징\r\n\r\n    \r\n\r\n    ***스레드**(thread)는 어떠한 프로그램 내에서 실행되는 흐름의 단위를 말합니다. 일종의 컨베이어 벨트이다.!*\r\n\r\n    \r\n\r\n    - 이벤트 루프는 메인 스레드의 동작 타이밍을 관리하면서, 비동기적인 처리를 가능하게 하여 브라우저의 응답성을 향상시키는 역할을 한다.\r\n\r\n    - 메인 스레드(단일 스레드로 구성)란 자바스크립트 코드 실행이나 브라우저 렌더링을 맡는 등 브라우저의 주된 동작이 수행되는 곳이다.\r\n\r\n    - 이벤트 루프는 큐에 추가된 작업들을 주로 타이머, I/O 이벤트, 콜백 함수 등으로 처리합니다.\r\n\r\n    - 이벤트 루프는 하나 이상의 태스크 큐를 갖는다.\r\n\r\n    - 논 블로킹I/O는 이벤트 루프 모델의 무척 흥미로운 특징(동시성을 높임)\r\n\r\n    **논 블로킹**이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행\r\n\r\n    **블로킹**이란 이전 작업이 끝나야만 다음 작업을 수행\r\n\r\n    - 자바스크립트에서 **비동기 처리란**, 네트워크 요청, 파일 읽기/쓰기 등의 작업으로 인해 시간이 오래 걸리는 작업 완료되는 시점을 기다리지 않고  다음 코드를 실행하는 것을 의미 (즉, 동기적으로 처리하지 않는다.)\r\n\r\n    - 이벤트 루프는 각 작업들의 우선순위를 고려하여 처리하며, 마이크로 태스크(Microtask queeu)와 매크로 태스크(Macrotask queue)를 구분하여 처리합니다. 이는 자바스크립트의 비동기 처리에 중요한 역할을 합니다.\r\n\r\n    - 마이크로 태스크는 작업 큐에 들어온 매크로 태스크보다 우선순위가 높습니다. 이벤트 루프는 현재 실행 중인 작업이 완료되면 마이크로 태스크부터 순서대로 처리하고, 그 후에 매크로 태스크를 처리합니다.\r\n\r\n    대표적인 메크로 테스크로는 setTimeout, setInterval, setImmediate 등\r\n\r\n    대표적인 마이크로 테스크는 Promise 콜백, then, catch, async함수 등\r\n\r\n- 이벤트 루프가 왜 중요함?\r\n\r\n    \r\n\r\n    이벤트 루프는 브라우저 메인 스레드 동작 타이밍을 관리하는 관리자라고 할 수 있다. 관리자라고 하니까 중요한 것 같기는 한데 감이 오지 않을 수 있다. 브라우저 동작 특징을 알아보면서 이벤트 루프가 중요한 이유를 알아보자.\r\n\r\n    \r\n\r\n    1. ****브라우저 동작의 대부분이 메인 스레드에서 싱글 스레드로 실행된다.****\r\n\r\n    \r\n\r\n    메인 스레드가 싱글 스레드로 동작하는 것이 중요한 이유는 싱글 스레드에서 하나의 작업을 하고 있다면 다른 작업은 지연시키기 때문이다. 예를 들어 싱글 스레드의 동작은 한 사람이 여러 가지 일을 동시에 처리할 수 없는 것과 비슷하다. `게임`과 `식사`라는 2개의 작업이 수행되어야 할 때 `게임`을 하고 있다면 `식사` 작업은 지연될 수밖에 없다. 둘 중 하나의 작업이 굉장히 길어진다면 다른 작업은 시작조차 못 할 것이다. (하나의 스레드는 코드가 실행되는 하나의 흐름)\r\n\r\n    \r\n\r\n    - 메인스레드? 싱글스레드?\r\n\r\n        \r\n\r\n        여기서는 구체적으로 브라우저 환경에서 메인 스레드가 싱글 스레드로 동작하는 것이 중요한 이유를 설명하고 있습니다. 즉, 브라우저의 대부분의 동작이 메인 스레드에서 처리되며, 이 때 메인 스레드가 싱글 스레드로 동작하기 때문에 작업 관리가 매우 중요하다는 것을 강조하고 있습니다.\r\n\r\n        \r\n\r\n        그렇다면 보조 스레드란?\r\n\r\n        \r\n\r\n        메인 스레드는 보통 UI와 관련된 작업들을 처리하는 스레드입니다. 예를 들어 사용자의 입력을 받아들이고, 이에 따라 UI를 업데이트하거나, JavaScript 코드를 실행하거나, HTTP 요청을 처리하는 등의 작업을 합니다.\r\n\r\n        \r\n\r\n        반면에 보조 스레드(Helper 혹은 Worker Thread)는 메인 스레드에서 처리하기 어려운 작업들을 처리하는 데 사용됩니다. 대표적으로는 네트워크 통신, 이미지 로딩, 파일 다운로드, 암호화 및 복호화 등이 있습니다. 이러한 작업들은 메인 스레드에서 처리하면 UI가 멈추거나 끊기는 현상이 발생할 수 있기 때문에, 보조 스레드에서 처리됩니다. 보조 스레드는 메인 스레드와 달리 프로그램의 흐름을 제어하지 않고, 병행적으로 실행되기 때문에 다른 스레드들과 경쟁하며 자원을 공유합니다. 프로그램의 기능을 향상시키고 멀티태스킹을 구현하는 데 중요한 역할을 합니다.\r\n\r\n        \r\n\r\n    \r\n\r\n    메인 스레드에서도 마찬가지로, 개발자가 만약 자바스크립트 코드에 무한 루프 코드를 작성한다면 해당 작업이 다른 모든 작업을 지연시키고 메인 스레드에서 무한히 동작할 것이다. 결국에는 브라우저가 먹통이 되는 현상이 발생한다. 사용자 이벤트도 메인 스레드에서 동작하기 때문에 키보드 입력이나 마우스 클릭도 동작하지 않는다. 그러므로 싱글 스레드의 작업 관리는 매우 중요하다고 할 수 있다.\r\n\r\n    \r\n\r\n    즉, 싱글 스레드로 실행되는 특징은 **동시성 관리, 안정성 보장, 자원 관리, 예측 가능성** 등을 높인다.\r\n\r\n    \r\n\r\n    - 동시성 관리: 여러 개의 작업을 동시에 처리하는 것은 어려운 일입니다. 여러 개의 스레드를 사용하여 작업을 분산할 수 있지만, 이로 인해 발생하는 복잡도와 위험성이 높아집니다. 싱글 스레드로 작업을 관리하면 작업의 우선순위를 결정하고 순서에 따라 처리할 수 있습니다.\r\n\r\n    - 안정성 보장: 여러 개의 스레드가 동시에 실행되면, 서로의 작업에 영향을 미치거나 충돌이 발생할 수 있습니다. 싱글 스레드로 작업을 관리하면 이러한 위험을 최소화할 수 있습니다.\r\n\r\n    - 자원 관리: 각 스레드는 메모리와 같은 시스템 자원을 사용합니다. 여러 개의 스레드를 사용하면 자원을 효율적으로 관리하기가 어렵습니다. 싱글 스레드로 작업을 관리하면 자원을 보다 효율적으로 사용할 수 있습니다.\r\n\r\n    - 예측 가능성: 싱글 스레드로 작업을 관리하면 작업의 순서와 우선순위를 예측할 수 있습니다. 이는 시스템의 안정성과 예측 가능성을 높이는 데 도움이 됩니다.\r\n\r\n    \r\n\r\n    1. **메인 스레드는 이벤트 루프에 의해 관리된다.**\r\n\r\n    \r\n\r\n    앞서 언급한 것처럼, 메인 스레드와 같은 싱글 스레드에서 하나의 작업이 오랫동안 실행되어서도 안 되고, 여러 작업 중 어떤 작업을 우선으로 동작시킬 것인가 결정하는 것도 매우 중요하다. 또한, 작업 간 전환 속도를 빠르게 하여 한 번에 하나의 작업씩 수행하지만 **마치 동시에 수행하는 것처럼** 동작해야 한다. 이러한 섬세한 컨트롤을 바로 이벤트 루프가 메인 스레드의 동작을 관리를 통해 일어난다.\r\n\r\n    \r\n\r\n\r\n\r\n![img (1).gif](https://file.notion.so/f/s/c2dd7425-60f7-49fd-88fe-acb4f549c0ce/img_(1).gif?id=cc9f993b-bd16-48fb-9f9d-31f8197bb51f&table=block&spaceId=78e0979c-6197-4792-a235-719f1075b969&expirationTimestamp=1694361600000&signature=i3SaZS2NINhYnhR_HUJV7tkyWVg9uhp-9Vod-SFyjyY)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n**이벤트 루프 알고리즘**\r\n\r\n\r\n\r\n이벤트 루프는 런타임(브라우저 / 노드)에서 비동기 작업을 돕는다. 싱글스레드로 동작하는 자바스크립트 엔진이 왜 여러 작업들이 함께 발생하는 것 처럼 느껴지게 하는지, 자바스크립트 엔진과 이벤트 루프가 어떻게 동작하는지부터 알아보자.\r\n\r\n\r\n\r\n**이벤트 루프의 작업을 다루는 순서**\r\n\r\n\r\n\r\n콜스택이 비어있다는 전제하에,\r\n\r\n\r\n\r\n1. **마이크로 태스크 큐**에 있는 마이크로 태스크를 FIFO(선입선출)로 순차 실행한다.\r\n\r\n\r\n\r\n2. 마이크로 태스크 큐가 비면, **렌더링 작업을 수행**한다.\r\n\r\n\r\n\r\n3. 렌더링 작업 후에는 **매크로 태스크 큐(=태스크 큐)**에 있는 태스크를 실행한다.\r\n\r\n\r\n\r\n4. 매크로 태스크 큐의 작업이 1개 실행되고, 다시 1번으로 돌아간다.\r\n\r\n\r\n\r\n주목할 점은 마이크로 태스크가 모두 처리되지 않으면, 렌더링이 되지 않는다는 것이다. 대표적인  마이크로 태스크 큐에 담길 태스크는 Promise 콜백과 then, catch, finally 콜백, async 함수 등이 있다.\r\n\r\n\r\n\r\n**출처**\r\n\r\n\r\n\r\n****[마이크로 태스크 큐의 비동기 작업 처리와 렌더링 시점을 알아보자.](https://gobae.tistory.com/134)****\r\n\r\n\r\n\r\n****[마이크로태스크(Microtask)와 매크로태스크(Macrotask) 알아보기](https://velog.io/@dami/JS-Microtask-Queue)****\r\n\r\n\r\n\r\n****[이벤트 루프, 넌 누구냐](https://tecoble.techcourse.co.kr/post/2021-08-28-event-loop/)****\r\n\r\n\r\n\r\n****[이벤트 루프와 태스크 큐](https://velog.io/@yejineee/%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EC%99%80-%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%ED%83%9C%EC%8A%A4%ED%81%AC-%EB%A7%A4%ED%81%AC%EB%A1%9C-%ED%83%9C%EC%8A%A4%ED%81%AC-g6f0joxx)****\r\n\r\n\r\n\r\nChat Gpt\r\n\r\n\r\n\r\n**참고자료**\r\n\r\n\r\n\r\n[[10분 테코톡] 🍗 피터의 이벤트루프](https://www.youtube.com/watch?v=wcxWlyps4Vg)\r\n\r\n\r\n\r\n[개발자 90%가 모르는 자바스크립트 동작원리 (Stack, Queue, event loop)](https://www.youtube.com/watch?v=v67LloZ1ieI)\r\n\r\n\r\n\r\n[Promise, async & await](https://evanai.notion.site/evanai/Promise-async-await-4506f8d25e64416bb124f0fac772fed6)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n- **브라우저의 구조와 동작원리**\r\n\r\n    \r\n\r\n    *웹브라우저 동작원리 ? 왜 알아야 하는데 - 우리가 짠 자바스크립트는 크롬이 실행시켜주니까..*\r\n\r\n    \r\n\r\n    자바스크립트 엔진은 다음과 같다.\r\n\r\n    \r\n\r\n    웹킷,V8 등의 자바스크립트 엔진, JS코드를 해석하고 실행하는 인터프리터이며, 크게 **힙**과 **콜스택**으로 이루어져 있다.\r\n\r\n    \r\n\r\n    힙은 메모리 할당이 일어나는 부분.*변수, 객체 등이 저장되는 창고라고 생각.\r\n\r\n    \r\n\r\n    - Memory Heap : 메모리 할당이 일어나는 장소\r\n\r\n    - Call Stack : 코드가 실행될 경우 하나씩 stack의 형태로 쌓이는 장소\r\n\r\n    \r\n\r\n    콜스택(호출 스택)이란?\r\n\r\n    \r\n\r\n    함수가 호출되는 순서대로 쌓이는 스택\r\n\r\n    \r\n\r\n    함수실행 시 호출 스택에 해당 함수를 집어넣는다.(정확히는 함수가 아니라 함수의 실행 문맥이 쌓임. 자바스크립트가 함수를 실행하기 위해 가지고 있어야 하는 여러가지 정보들을 의미. 변수나 함수의 선언, 스코프, this 등의 정보들을 물리적 객체형태로 보관)\r\n\r\n    \r\n\r\n    함수 실행시에 콜스택에 함수를 넣어서 실행시키고, 함수 리턴시에 콜스택의 맨위에서 해당함수를 끄집어 내서 리턴을 시키는.. 그러한 방식으로 작동\r\n\r\n    \r\n\r\n    콜스택이 빈다 = 실행할 함수가 남아있지 않다.\r\n\r\n    \r\n\r\n    자바스크립트는 싱글 스레이드 언어인데, 이것은 호출 스택을 하나만 사용한다라는 의미이며, 동시에 하나의 일만 처리할 수 있다라는 뜻이다. \r\n\r\n    \r\n\r\n    그렇다면 함수가 호출되는 스택이 하나뿐인데, 그렇다면 어떻게 비동기 요청을 지원하고, 동시성에 대한 처리는 누가함?\r\n\r\n    \r\n\r\n    그것에 대한 답은 웹브라우저 전체로 시야를 넓혀볼 필요가 있다. 웹브라우저는 JS엔진 말고도 Web APIs, 테스크 큐, 이벤트 루프 등이있다. 참고로 우리가 많이 사용하는 DOM, AJAX(XMLHttpRequest),Timeout(setTimeout)들은 사실 JavaScript에서 지원하는 것이 아닌 웹 브라우저 Web APIs에서 제공하는 메서드들이다. 이들은 비동기 메서드들이며, 메서드의 작동을 마치면 (이를테면 setTime이 지나고 나면 콜백을 테스크큐로) 콜백함수를 콜백큐(테스크 큐)에 집어넣는다. *[*콜백큐는 공식적인 용어가 아님.*](https://velog.io/@dev-mish-mash/Task-queue%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%A4%ED%95%B4-%EC%A0%95%EB%A6%AC)\r\n\r\n    \r\n\r\n    테스크 큐 = Web API의 콜백 함수들이 대기하는 공간\r\n\r\n    \r\n\r\n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4e8715dc-065c-4e8c-a8a6-5b01fadd88bc%2FUntitled.png?table=block&id=78a19d8d-61ae-484b-a2e1-9352ba6ceca7&spaceId=78e0979c-6197-4792-a235-719f1075b969&width=1600&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n    \r\n\r\n    이렇게 자바스크립트 엔진 자체는 싱글스레드로 구동되지만, 실제로 자바스크립트의 런타임 환경인 웹 브라우저, 자세히 말하자면 Web API가 멀티스레드로 동작한다. 그리고 자바스크립트 엔진이 이것들과 **상호 연동하기 위한 장치**가 *테스크 큐(콜백 큐)*와 *이벤트 루프*가 되는 셈이다.\r\n\r\n    \r\n\r\n    이벤트 루프는 호출 스택과 콜백 큐를 계속해서 주시하고 있다.\r\n\r\n    \r\n\r\n    *호출스택이 비어있으면,* 먼저 들어온 순서대로 콜백 큐에 있는 콜백 함수들을 호출 스택으로 집어 넣는다.\r\n\r\n    \r\n\r\n    전역 문맥 Global Context(전역 변수등을 가지고 있는) \r\n\r\n    \r\n\r\n    콜스택의 밑바닥에는 전역문맥이 항상 존재함.\r\n\r\n    \r\n\r\n    스크립트가 시작하면서 전역 문백부터 시작하고 스크립트가 끝나면 얘도 같이 사라짐.",
        "qna": ""
      },
      {
        "id": "27",
        "title": "JavaScript",
        "topic": "얕은 복사, 깊은 복사에 관하여",
        "texture": "### 얕은 복사와 깊은 복사에 관해서 설명해주세요.\r\n\r\n<aside>\r\n\r\n1️⃣ 얕은 복사는 객체나 배열을 복사할 때 참조값(주소값)을 복사하는 것을 의미합니다. 이것은 데이터가 그대로 생성되는 것이 아닌 해당 데이터의 참조 값을 전달하여 한 데이터의 값을 공유한다는 것을 의미하므로 이로 인해 한 객체나 배열을 수정하면 다른 객체나 배열도 영향을 받을 수 있습니다.\r\n\r\n\r\n\r\n</aside>\r\n\r\n\r\n\r\n<aside>\r\n\r\n2️⃣ 깊은 복사는 객체나 배열을 복사할 때 실제 값들을 새로운 메모리 공간에 복사하는 것을 의미합니다. 복사된 객체나 배열은 완전히 독립적인 메모리를 차지하게 되어 원본 객체나 배열과는 별개로 동작합니다. 따라서 한 객체나 배열을 수정해도 다른 객체나 배열은 영향을 받지 않습니다.\r\n\r\n\r\n\r\n</aside>\r\n\r\n\r\n\r\n<aside>\r\n\r\n3️⃣ 따라서, 깊은 복사는 데이터 자체를 복사하여 독립적인 복사본을 생성하는 반면, 얕은 복사는 참조값을 복사하여 원본과 복사본이 동일한 데이터를 참조하게 됩니다.\r\n\r\n\r\n\r\n</aside>\r\n\r\n\r\n\r\n복사는 어떤 데이터 타입인지에 따라 다르게 진행되기 때문에, 얉은 복사와 깊은 복사의 더 깊은 이해를 위해서는 먼저 **[데이터 타입**에 대한 이해](https://www.notion.so/4-0a503396ea9d46e1b09a59c1f3005374?pvs=21)를 하면 좋습니다. (원시값, 참조값의 특성)\r\n\r\n\r\n\r\n**얕은 복사, 깊은 복사를 쓰는이유**\r\n\r\n\r\n\r\n→ 원본 값이 변화될 수 있다. ([혹은 독립적인 카피가 필요할 경우](https://www.notion.so/4-0a503396ea9d46e1b09a59c1f3005374?pvs=21))\r\n\r\n\r\n\r\n```jsx\r\n\r\n//얕은 복사\r\n\r\nconst obj = { a: 1 };\r\n\r\nconst copyObj = obj;\r\n\r\n\r\n\r\ncopyObj.a = 2;\r\n\r\n\r\n\r\nconsole.log(obj.a); // 2, 원본 데이터에 영향을 준다.\r\n\r\nconsole.log(obj === copyObj); // true\r\n\r\n\r\n\r\n//깊은 복사(1depth한정)\r\n\r\nconst obj = {\r\n\r\n  a: 1,\r\n\r\n  b: { c: 2 }, //중첩 객체\r\n\r\n}\r\n\r\n\r\n\r\nconst copyObj = Object.assign({}, obj);\r\n\r\n\r\n\r\ncopyObj.b.c = 3;\r\n\r\n\r\n\r\nconsole.log(obj); // { a: 1, b: { c: 3 } } -> 2depth부턴 얕은 복사가 됨.\r\n\r\nconsole.log(obj.b.c === copyObj.b.c); // true\r\n\r\n```\r\n\r\n\r\n\r\n이렇게 참조 값만을 복사하게되는 것은 원치않는 결과를 가져올 수 있기 때문에, 상황에 따라 얉은 복사와 깊은 복사를 사용할 줄 알아야한다. 얉은 복사와 깊은 복사는 **참조 값**이 아닌 **값 자체**를 복사하기 위함이다. (블로그마다 얕은 복사에 속하는 복사법들*(Object.assign(), 전개 연산자 등)*을 깊은 복사에 분류 해놓기도 하는데, **~~그것은 1depth 한정 깊은 복사이다.~~**)\r\n\r\n\r\n\r\n- **얕은 복사(Shallow Copy)**\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    //얕은 복사(일반)\r\n\r\n    const obj1 = { a: 1, b: 2}\r\n\r\n    const obj2 = obj\r\n\r\n    console.log(obj === obj2) // true\r\n\r\n    \r\n\r\n    obj2.a = 100\r\n\r\n    console.log(obj1.a) // 100\r\n\r\n    ```\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    //깊은 복사가 됐는데(a에 할당하는 부분), spread는 얕은 복사라고 하지 않았나?\r\n\r\n    const obj = { a:1, b:2 }\r\n\r\n    const obj2 = {...obj}\r\n\r\n    obj2.a = 100\r\n\r\n    console.log(obj === obj2) // false \r\n\r\n    console.log(obj.a) // 1\r\n\r\n    \r\n\r\n    //이러면 얕은 복사의 특징(1depth까지만 깊은 복사)을 알 수 있다.\r\n\r\n    const obj = { a: { b:1, c:1 }, d: 2}\r\n\r\n    const obj2 = {...obj}\r\n\r\n    obj.a.b = 100\r\n\r\n    console.log(obj === obj2) // false\r\n\r\n    console.log(obj2.a.b) // 100\r\n\r\n    ```\r\n\r\n    \r\n\r\n    - 참조값 복사\r\n\r\n    - 일반적으로 객체를 복사할 때(일반 복사), 얕은 복사가 일어납니다. [(*원시값의 깊은복사 먼저 보셈)](https://www.notion.so/4-0a503396ea9d46e1b09a59c1f3005374?pvs=21)\r\n\r\n    - 1depth까지만 복사합니다.\r\n\r\n    - 객체나 배열을 복사할 때 참조값을 복사하여 동일한 데이터를 공유합니다.\r\n\r\n    - 복사된 객체나 배열을 수정하면 원본 객체나 배열도 영향을 받습니다.\r\n\r\n    - 메모리 사용량이 적고 복사 속도가 빠릅니다.\r\n\r\n    - 대표적으로 **Object.assign(), 전개 연산자(Spread), Array.prototype.slice()** 등이 있다.\r\n\r\n- **깊은 복사(Deep Copy)**\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    //결국 1레벨 깊이 이상의 객체를 깊은 복사하려면, 코드가 길어진다.\r\n\r\n    const obj = { a: { b:1, c:1 }, d: 2}\r\n\r\n    const obj2 = {...obj, a:{...obj.a}}\r\n\r\n    obj.a.b = 100\r\n\r\n    console.log(obj === obj2) // false\r\n\r\n    console.log(obj2.a.b) // 1\r\n\r\n    \r\n\r\n    //JSON.stringify()이용 깊은 복사\r\n\r\n    const obj = {\r\n\r\n      a: 1,\r\n\r\n      b: {\r\n\r\n        c: 2,\r\n\r\n      },\r\n\r\n    };\r\n\r\n    \r\n\r\n    const copiedObj = JSON.parse(JSON.stringify(obj)); \r\n\r\n    //자바스크립트 객체 -> json문자열 -> 자바스크립트 객체\r\n\r\n    //json 문자열로 바꾸는데(stringify) 이과정에서 원본 객체와의 참조가 모두 끊어진다.\r\n\r\n    \r\n\r\n    copiedObj.b.c = 3\r\n\r\n    \r\n\r\n    obj.b.c === copiedObj.b.c //false\r\n\r\n    ```\r\n\r\n    \r\n\r\n    - 값자체 복사\r\n\r\n    - 원시값을 복사할 때에는, 깊은 복사가 일어납니다.\r\n\r\n    - 복잡한 구조(2depth 이상)을 전부 복사합니다.\r\n\r\n    - 실제 값들을 새로운 메모리 공간에 복사하여 독립적인 복사본을 생성합니다.\r\n\r\n    - 복사본의 변경이 원본에 영향을 주지 않습니다.\r\n\r\n    - 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않습니다.\r\n\r\n    - 객체가 참조 타입의 멤버를 포함할 경우 참조값의 복사가 아닌 참조된 객체 자체가 복사되는 것을 의미합니다. 기존 원본의 참조는 더 이상 하지 않습니다.\r\n\r\n    - 대표적으로 **재귀함수, JSON.parse(JSON.stringify(obj)), lodash 라이브러리의 등이 있다.**\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n- 원시값의 복사\r\n\r\n    \r\n\r\n    원시값은 깊은 복사를 하게 됩니다. 값타입이라고도 하며, JavaScript에서 string, number, boolean, null, undefined와 같은 데이터 타입을 말합니다. 원시값은 불변(immutable)하므로 복사된 변수를 변경하면 원*본 변수에는 영향을 주지 않습니다.*\r\n\r\n    \r\n\r\n    예를 들어, 원시값을 변수에 할당하고 그 변수를 다른 변수에 복사하는 경우:\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    let num1 = 1;\r\n\r\n    let num2 = num1; //num2에는 1이라는 값 자체가 복사되어 들어간다.\r\n\r\n    \r\n\r\n    num2 = 2;\r\n\r\n    \r\n\r\n    console.log(num1, num2); //num1: 1, num2: 2\r\n\r\n    ```\r\n\r\n    \r\n\r\n    원시값은 불변(immutable)하기 때문에 값 자체가 변경되지 않습니다. 따라서 원시값을 복사하는 경우에는 얕은 복사와 깊은 복사의 개념이 크게 중요하지 않습니다. 원시값을 다른 변수에 할당하면 해당 변수에는 실제 값이 복사되며, 이후에 복사된 변수를 변경하더라도 원본 변수에는 영향을 주지 않습니다.\r\n\r\n    \r\n\r\n    **즉, 원시값은 깊은 복사가 일어난다라고 기억합시다.**\r\n\r\n    \r\n\r\n- 얕은 복사가 중첩구조를 복사하지 못하는 이유 → spread 연산자의 작동 원리\r\n\r\n    \r\n\r\n    ****Spread Operator****\r\n\r\n    \r\n\r\n    전개 연사자가 호출될 때, 내부적으로는 *iterator-looping* 액션을 수행한다. 조금 더 자세히 설명하자면, 어떤 객체에 `[Symbol.iterator]` 프로퍼티가 존재한다면 이터러블하다고 할 수 있고 반복문을 돌릴 수 있다.\r\n\r\n    \r\n\r\n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6cc6d816-da46-4235-b522-824a78e5affd%2FUntitled.png?table=block&id=4f502988-3f91-400d-bb24-9acadaef8dc8&spaceId=78e0979c-6197-4792-a235-719f1075b969&width=1020&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    //스프레드 연산자에 의한 객체 얕은 복사\r\n\r\n    const b = [1, 2, 3];\r\n\r\n    const a = [ ...b ];\r\n\r\n    \r\n\r\n    // 내부 동작 원리\r\n\r\n    if (!(Typeof(b) is Iterable)) {\r\n\r\n      throw TypeError\r\n\r\n    }var a = [];\r\n\r\n    for (var i = 0; i < b.length; i += 1) {\r\n\r\n      a.push(b[i]);\r\n\r\n    }\r\n\r\n    ```\r\n\r\n    \r\n\r\n\r\n\r\n**얕은 복사와 깊은 복사의 선택은 데이터 구조의 복잡도와 성능 요구 사항에 따라 달라질 수 있습니다. 데이터 구조에 대한 이해와 상황에 맞는 선택이 중요합니다.*\r\n\r\n\r\n\r\n참조\r\n\r\n\r\n\r\n[얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)](https://dori-coding.tistory.com/entry/JavaScript-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%ACShallow-Copy%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%ACDeep-Copy)\r\n\r\n\r\n\r\n[얉은 복사, 깊은 복사 그리고 React의 리렌더링](https://velog.io/@jellybrown/ReactJS-%EC%96%89%EC%9D%80-%EB%B3%B5%EC%82%ACShallow-Copy-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%ACDeep-Copy-%EA%B7%B8%EB%A6%AC%EA%B3%A0-React%EC%9D%98-%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81)\r\n\r\n\r\n\r\n[얉은 복사, 깊은 복사](https://podocoding.tistory.com/48)\r\n\r\n\r\n\r\n[리액트 불변성이란 무엇이고, 왜 지켜야 할까?](https://hsp0418.tistory.com/171)\r\n\r\n\r\n\r\n추가자료\r\n\r\n\r\n\r\n[비전공자용 자바스크립트 deep copy, shallow copy 설명](https://www.youtube.com/watch?v=JtrOxaTvOEM), 큰돌\r\n\r\n\r\n\r\n[state가 array/object면](https://www.youtube.com/watch?v=jAFogNao6CA&list=PLfLgtT94nNq0qTRunX9OEmUzQv4lI4pnP&index=5), 코딩애플",
        "qna": ""
      },
      {
        "id": "28",
        "title": "JavaScript",
        "topic": "1. ==(동등)과 ===(일치)의 차이점 / 2. 컴파일러 언어와 인터프리터 언어",
        "texture": "---\r\n\r\n### **Q. 동등 연산자(==)와 일치 연산자(===)의 차이점을 설명해주세요.**\r\n\r\n\r\n\r\n- 동등 연산자(==)와 일치 연산자(===)는 모두 피연산자에 값을 비교하고 Boolean값을 반환합니다. 동등 연산자는 오직 값에 대한 비교를 수행하지만, 일치 연산자는 값과 자료형 모두를 비교합니다.\r\n\r\n    \r\n\r\n    동등 연산자는 두 값을 비교할 때 숫자형으로 강제 형변환(type coercion)을 진행합니다. 즉, 비교하는 데이터의타입 다르더라도 자동으로 형변환을 수행한 후에 비교를 진행합니다. 이러한 형변환은 때로 예측하지 못한* 결과를 초래하므로 동등 연산자를 사용할 때에는 주의가 필요합니다.  따라서 두 값의 자료형과 값이 모두 같은지 비교하는 일치 연산자를 사용하는 것이 형변환 없이 더 안전하고 정확한 값을 비교할 수 있습니다.\r\n\r\n    \r\n\r\n\r\n\r\n```jsx\r\n\r\n'1' == 1 // t   \r\n\r\n\r\n\r\n10 == '10' // t\r\n\r\n\r\n\r\n0 == false // t\r\n\r\n\r\n\r\n1 == true // t\r\n\r\n\r\n\r\n'' == false // t\r\n\r\n\r\n\r\n0 == '' // t \r\n\r\n\r\n\r\n------\r\n\r\nlet a = 0;\r\n\r\nalert( Boolean(a) ); // false\r\n\r\n\r\n\r\nlet b = \"0\";\r\n\r\nalert( Boolean(b) ); // true\r\n\r\n\r\n\r\nalert(a == b); // true!\r\n\r\n\r\n\r\nfalsy값: false, 0, \"\", undefined, null, NaN\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n0 === false // false\r\n\r\n\r\n\r\n0 === '' // false\r\n\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n### Q. 컴파일 언어(compilation)와 인터프리터 언어(interpretation)의 차이는 무엇인가요?\r\n\r\n\r\n\r\n- 컴파일 언어의 경우, 소스코드(사용자가 작성한 원시코드)를 다른 형태인 기계어로 전부 변환 시킨 후 코드를 실행하는 언어이며, 대표적으로는 C, C++, 자바 등이 있다. 인터프리터 언어는 소스코드를 기계어로 변환하는 과정 없이 한 줄씩 실시간으로 해석하며 바로 실행하는 언어이다. JavaScript, Python, Ruby 등이 있다.\r\n\r\n    \r\n\r\n    보통 컴파일 언어는 코드 실행전 기계어나 다른 코드로 먼저 ‘번역’하는 과정을 거친다고하며, 인터프리터 언어는 컴파일 과정을 미리 거치지 않고 컴퓨터에 설치된 프로그램인 인터프리터를 거쳐 실시간으로 소스코드를 ‘통역’해주는 것으로 많은 비유를 한다.\r\n\r\n    \r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd7f6b36f-a601-4b3d-bfa8-a2992926077b%2FUntitled.png?table=block&id=8445c167-b6cc-4587-b3e3-3a7aea822723&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n컴파일 언어는 프로그래밍 언어로 짠 코드 컴파일이란 과정을 통해 다른 형태 (기계어)로 바꿔준다. 그 결과물을 실행하는 것이 컴파일 언어의 특성이다. 반면 인터프리터 언어는 코딩 후 다른 과정을 거치지 않고 코드가 그대로 실행할 곳으로 보내져서 인터프리터라는 프로그램을 통해 곧바로 통역되어 실행된다.\r\n\r\n\r\n\r\n<aside>\r\n\r\n✅ 컴파일러 (compiler)\r\n\r\n\r\n\r\n- 전체 파일을 스캔하여 한꺼번에 번역\r\n\r\n- 초기 스캔시간이 오래 걸리지만, 한번 실행 파일이 만들어지고 나면 빠르다.\r\n\r\n- 대표적인 언어로 C, C++\r\n\r\n</aside>\r\n\r\n\r\n\r\n<aside>\r\n\r\n✅ 인터프리터 (interpreter)\r\n\r\n\r\n\r\n- 한번에 한문장씩 번역후 실행 시키기 때문에 실행 시간이 느리다.\r\n\r\n- 프로그램을 실행시키고 나서 오류를 발견하면 바로 실행을 중지 시킨다. 실행 후에 오류를 알 수 있다.\r\n\r\n- • 대표적인 언어로 Python, Ruby, Javascript 등\r\n\r\n</aside>\r\n\r\n\r\n\r\n- *Java는 하이브리드 언어다.*\r\n\r\n    \r\n\r\n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7bc667fb-6f0a-47b2-a809-318f53c3170b%2FUntitled.png?table=block&id=c7f60d45-3cb7-4d3d-9c1d-b6d5022c95f6&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1670&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n    \r\n\r\n    Java는 다른 컴파일 언어들이 작동하듯이 컴파일러를 이용해 전체 코드를 한번에 번역한다. 여기서 사용하 컴파일러를 **자바 컴파일러(Java Compiler)**라고 하며, 이 자바 컴파일러는 우리가 작성한 Java 코드를 **자바 가상 머신(Java Virtual Machine, JVM)**이 실행시킬 수 있는 **자바 바이트 코드**로 번역한다. \r\n\r\n    \r\n\r\n    하지만 자바 바이트 코드는 자바 가상 머신(JVM)의 **자바 인터프리터(Java Interpreter)**를 이용해 한 줄씩 실행된다.자바 바이트 코드로 작성되어 있는 실행 프로그램을 자바 인터프리터가 한 줄씩 읽으면서 컴퓨터가 이해할 수 있는 2진 코드로 번역한 후 실행시킨다는 뜻이다.\r\n\r\n    \r\n\r\n    그래서 Java는 하이브리드 언어라는 괴상한 이름으로 불린다. 컴파일 언어와 인터프리터 언어를 혼합한 형태의 언어라는 의미인데, 처음에는 인터프리터 언어로써 사용되다가, 성능 향상을 위하여 컴파일 언어의 장점을 가져왔다고 한다.\r\n\r\n    \r\n\r\n\r\n\r\n**정적 타입과 동적 타입의 특성**\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4630695e-2692-4112-9798-628a2e95867b%2FUntitled.png?table=block&id=d3d591f3-2e3b-48d4-929f-5946469ed73b&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n컴파일 언어는 정적 타입의 언어이다. 변수 등에 지정된 자료형을 바꿀 수 없다. 컴파일 시에 자료형에 맞지 않은 값이 들어있으면 컴파일 에러가 발생한다. 하지만 컴파일 시에 타입에 대한 정보를 결정하기 때문에 실행시 속도가 빠르고, 타입 에러로 인한 문제점을 초기에 발견할 수 있어 타입의 안정성을 높혀준다.\r\n\r\n\r\n\r\n반면 인터프리터 언어는 동적 타입의 언어이다. 변수에 다른 자료형의 값(숫자형, 문자형)을 넣을 수 있다. 자료형의 일관성이 강제되지 않기 때문에 자유롭고 편한 프로그래밍이 가능하지만, 실행 시점이 되어서야 오류가 확인되거나 잘못된 자료형에 의한 오류의 위험성이 높다. JavaScript도 이런 한계를 갖는데, 이를 보완하고자 정적 타입의 TypeScript가 탄생했다.  프로그래밍 할때에는 타입스크립트로 안정적이게, 배포할 떄에는 js로 빌드해서 사용한다.\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa9965159-fd05-4b48-95dd-9d481e855c94%2FUntitled.png?table=block&id=1345a313-250c-4883-b932-478031682857&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n*이 작업을 언제 실행하느냐에 따라 둘 중 한 범주(컴파일 언어, 인터프리터 언어)에 들어가게 됩니다. 사실 컴파일 언어에도 인터프리터가 있고, 인터프리터 언어에서도 컴파일 과정이 있다고 한다. 그렇기 때문에  해당 구분이 절대적인 것은 아니며, 어디까지나 일반적인 ‘경향’으로 기억하면 된다.*\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F81dd8d34-a398-4650-a122-76cad10f32f1%2FUntitled.png?table=block&id=c738926e-c858-450e-a602-eaf0f956077c&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2ac6d39c-0ca0-41d1-923e-63c6a1f9367b%2FUntitled.png?table=block&id=f3e2b03a-0554-457b-a668-1ee727c8bf35&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n[인터프리터와 컴파일러 (한국어 자막을 켜고 보세요)](https://www.youtube.com/watch?v=Dx2tSsd3aFc)\r\n\r\n\r\n\r\n[자료형과 정적/동적 타입 (+ 컴파일/인터프리터 언어와의 관계)](https://www.youtube.com/watch?v=50N_NiDUKpw)",
        "qna": ""
      }
    ]
  },
  {
    "title": "React",
    "items": [
      {
        "id": "5",
        "title": "React",
        "topic": "라이브러리란 무엇인가",
        "texture": "## 1. 주제 선정 이유 \n각종 프로젝트를 준비하는 과정에서 라이브러리의 중요성을 많이 언급되며, 실제 기업에서도 특정 라이브러리를 사용하여 프로젝트를 진행한 경험을 요구하는 경우가 많다고 느꼈을 것이다. 라이브러리가 정확하게 무엇이며 어떤 종류가 있으며, 왜 사용하는지에 대해 자세히 알아보고자 준비함\n\n## 2. 라이브러리란\n\n# 2-1. 라이브러리의 정의\n- 소프트웨어를 개발할 때, 컴퓨터 프로그램이 사용하는 '비휘발성 자원(리소스)'의 집합이다.\n- 사전적 용어인 도서관(library)와 비슷하게, 특정한 코드들(책들)을 모아둔 집합이라 생각하면 된다.\n- 이는 소프트웨어 개발시에 사용되는 프로그램의 구성요소로, 공통으로 사용될 수 있는 특정한 기능들을 모듈(module)화 한 것이다.\n- API와의 차이점 : API는 프로그래밍 언어에서 라이브러리를 사용할 수 있도록 소스코드 수준에서 인터페이스를 노출 시킨 것이지만, 라이브러리는 실제 실행되어 기능을 수행하는 **단편화된 프로그램** 이다.\n- 즉, 라이브러리는 완전한 프로램이 아니라 특정한 기능만을 수행하도록 제작된 프로그램이다.\n\n# 2-2. 라이브러리를 사용하는 이유\n- 모든 기능을 직접 코딩하지 못하며, 시간을 절약하기 위해서이다.동일한 기능을 간단한 코드로 방법화시키는 라이브러리 코드를 본인이 직접짜기엔 너무 많은 시간을 소요되며, 실제로 정해진 기간내에 처리하기도 어렵기 때문이다.\n- 즉, 라이브러리를 사용할수 있으면, 보다 복잡한 코드를 짜는데 **더 빠르고, 더 편리하게** 할 수 있기에, 사용이 권장된다.\n\n# 2-3. 라이브러리의 종류\n- 표준 라이브러리: 특정한 언어의 개발 환경에 기본적으로 포함된 것들로, 언어의 기본 기능을 확장시키는 역할을 담당한다.Python의 표준 라이브러리에는 문자열 처리, 파일 조작, 네트워크 통신 등 다양한 모듈들이 포함되어 있다.참고문헌 : https://docs.python.org/ko/3/library/index.html\n- 웹 개발 라이브러리 : 웹 개발의 편의성을 제공하는 역할을 한다.대표적인 예로 JavaScript의 경우, jQuery, React, Angular 등이 있다.\n- 데이터베이스 라이브러리 : 데이터베이스와 상호 작용하는 역할을 수행한다.\n- 그래픽스 및 시각화 라이브러리 : 데이터 시각화나 그래픽스 작업을 위해 사용하는 라이브러리대표적인 예로 JavaScript의 D3.js가 있다.\n- 상태관리 라이브러리: 애플리케이션의 상태를 보다 효과적으로 관리(상태 업데이트나 추적...)하기 위한 라이브러리대표적인 예로 Redux와 Recoil이 있다.\n\n## 3. 라이브러리와 프레임 워크의 차이점\n- 주도권의 차이라고 설명할 수 있다.\n- 라이브러리의 경우, 개발자가 필요에 따라 선택적으로 사용할 수 있다.\n- 프레임 워크의 경우, 애플리케이션의 개발을 위한 일종의 뼈대 역할을 하기에, 개발자 프레임 워크에 맞춰서 개발을 해야한다.\n\n# 3-1. React는 라이브러리인가 프레임 워크인가?\n- React는 '프레임 워크같은' 라이브러리라 정의할 수 있다.\n- React 개발당시, UI개발을 위한 라이브러리로 개발되었으나, React Router를 통한 라우팅 기능이나, Redux와 같은 다양한 상태관리 라이브러리와의 조합으로 점차 '프레임 워크화'되어간 것이다.\n- 즉, React는 **프레임워크처럼 동작하는 라이브러리**라고 소개하면 된다.",
        "qna": "## 4. 요약 정리 및 면접형 QnA\n\n# Q1. 라이브러리에 대해 설명해주세요\n- 라이브러리는 재사용 가능한 코드의 집합을 의미합니다.\n- 해당 코드에는 특정 기능을 수행하는 함수, 클래스, 모듈 등으로 구성되어 있습니다.\n- 개발자가 필요에 따라 선택적으로 사용할 수 있다는 특징이 있습니다.\n- 프런트엔드 개발자인 저희에게 가장 익숙한 라이브러리에는 웹개발 라이브러리인 React와 상태관리 라이브러리인 Recoil과 Redux가 있습니다.\n\n# Q2. 혹시 Redux와 Recoil의 차이에 대해 설명가능하실까요?\n- Redux와 Recoil은 둘 다 상태 관리를 위한 라이브러리이지만, 사용 범위나 상태 업데이트 방식, 성능면에서 차이를 보입니다.\n- Redux의 경우, JavaScript 기반의 라이브러리(React, Angular, Vue)에서 모두 사용가능합니다. 반면 Recoil의 경우, Meta에서 React만을 위해 개발한 라이브러리여서 오로지 React에서만 작동가능합니다.\n- Redux는 Reducer를 활용한 일방적인 데이터 흐름으로 상태를 업로드 하지만, Recoil은 React의 useState와 유사하게 Atom이라는 상태 단위를 활용하여 상태를 업로드 합니다.\n- Recoil은 Redux보다 간단한 API를 제공하고 성능 최적화면에서도 React의 컴포넌트 라이프사이클과 잘 맞기에 우수합니다.\n\n# Q3. React는 라이브러리일까요, 아니면 프레임워크일까요?\n- React의 개념적으로 라이브러리가 맞습니다. 개발 초창기에 웹개발을 용이하게 하기 위해 개발된 웹개발 라이브러리 였으나, 다양한 상태관리 라이브러리를 함께 사용하고, 라우터를 활용한 라우팅이 가능해져서 컴포넌트간 보다 편리한 매핑이 가능해져 더이상 라이브러리가 아닌 프레임워크로 인식되는 경우가 있습니다.\n- 즉, React는 **프레임워크처럼 동작하는 라이브러리**라고 정의할 수 있습니다."
      },
      {
        "id": "6",
        "title": "React",
        "topic": "React의 상태관리란 무엇인가",
        "texture": "## 1. 주제 선정 이유\n React라이브러리를 사용하다보면 상태관리가 필수이며 그에 따른 각종 기능들을 숙지하고 있어야한다. 이에 대해 알지 못하면 React를 사용하지 않는 수준이며, 협업을 하는데 있어 큰 지장이 되기에 이번 기회에 상태관리에 대한 정확한 정의를 학습하고, React의 상태관리 방법에는 어떤 것들이 있는지 살펴보도록 하자.\n\n## 2. 상태관리란\n\n# 2-1. 상태관리의 정의\n- 상태(State) : 컴퍼넌트 내부에서 관리되며 어플리케이션의 렌더에 영향을 미치는 자바스크립트 객체를 의미. 즉, **변화하는 데이터**라고 이해하면 된다. (ex, 쇼핑몰 사이트에서 구매할 물건의 수량을 늘리고 줄이는 행위를 상태가 변화한다고 한다.)\n- 상태관리 : 상태는 어는 컴퍼넌트에서나 일관되어야 한다. 이를 데이터의 무결성이라 한다. 왜냐하면, 상태가 컴퍼넌트마다 다르다면, 유저나 관리자가 받아들이는 데이터에 차이가 생겨 소통에 차질이 생기기 때문이다.\n따라서 상태를 일관되게 관리해야하며, React의 경우, **신뢰할 수 있는 단일 출처(동일한 데이터는 항상 같은 곳에서 가져온다)**라는 방법론으로 상태를 관리하고 있다.\n\n# 2-2. 상태의 종류\n- 지역상태(localState) : 특정 컴퍼넌트 안에서만 관리되는 상태를 의미한다. 이는 주로 작은 프로젝트처럼 좁은 영역에서만 관리되는 데이터들이다.\n- 컴퍼넌트 간 상태: 다수의 컴퍼넌트에서 사용되고 영향을 주는 데이터들을 의미한다. 대표적인 예시로 여러 컴퍼넌트가 동시에 사용하는 모달창 등이 있다\n2개 이상의 컴퍼넌트간에 상태를 주고 받을 경우, 상위 컴퍼넌트에서 하위 컴퍼넌트로만 상태를 전달하며, 이를 Props Driling이라 한다.\n- 전역 상태(globalState) : 프로젝트 전체에 영향을 끼치는 데이터를 의미한다. 대표적인 예로, 모든 컴퍼넌트에서 사용되는 페이지의 헤더 컴퍼넌트 등이 있다.\n- 상태관리가 필요한 이유: 걱 컴퍼넌트가 부모자식 관계로 되어있지 않은 이상 각 컴퍼넌트간의 직접적인 데이터 전달은 어렵우며, 구조가 복잡하여 Props Driling이 많아지면 Props의 출처를 찾기 어려워기 때문에 이를 관리해줘야 한다.\n\n## 3. React의 상태관리\n\n# 3-1. Context API\n- Context API : React 컴포넌트 트리 안에서 전역 상태를 공유할 수 있도록 만들어진 방법이다.명칭은 API이기는 하지만, 실질적인 관리는 API가 아니라 useState를 통해 이루어진다.\n- useState() :\n`cosnt [state, setState] = useState()`의 형태로 구성되어 있다.\n앞에서서부터 state라는 상태변수와 상태에 변화를 주는 setState라는 함수가 있다. useState()의 파라미터에는 초기 state값이 들어가며, 이후 setState를 통해 state의 값에 변화를 주는 방식으로 상태를 관리한다.\nuseState()는 상태를 새로 추가하거나 삭제하는 것이 아니라 단순 비교를 통해 상태를 업데이트 시키는 원리로 작동한다.\n즉, **동일한 데이터의 key값이면 키의 value값의 차이를 비교하여 최신의 value값으로 갱신하며 상태를 관리한다.**\n이는 중간에 있는 요소들에게 props를 넘기지 않고도 데이터를 가져다 사용할 수 있기에 props Drilling을 피할 수 있으며, 주로 전역적으로 쓰이는 데이터들을 사용할 때 자주 사용된다.\n- context API의 구조 : context, provider, comsumer 로 구성\n context : 전역상태를 저장하는 곳으로 , 내부에는 provider와 consumer로 구성되어있다.\n provider : 전역상태를 제공하는 역할을 한다. 주로 Root Component(index.js / app.js)에서 정의된다.\n consumer 제공받은 전역상태를 받아서 사용하는 역할을 한다.\n\n# 3-2. Redux\n- Redux : 공식 문서에 따르면 자바스크립트 앱을 위한 예측 가능한 상태 컨테이너라고 정의한다.\n 이를 풀어 설명하면, 전역 상태를 관리하는 도구, 즉, 어플리케이션 전체에 대한 중앙 저장소 역할을 한다고 생각하면 된다.\n- 'Store','Action', 'Reducer'로 구성되어 있다.\n Store는 전역상태를 저장하는 저장소 역할을 하며, 오직 Reducer를 통해서만 접근이 가능하다. 주로 index.js에 정의되며 Store는 오직 1개만 존재할 수 있다.\n Action은 Store에 저장된 상태의 변화를 Reducer에 명령하는 자바스크립트 객체이다. 변화를 주기 위해 dispatch라는 메서드를 사용하여 Reducer에게 전달된다.\n Reducer는 변화를 감지하여 상태를 변화시키는 역할을 하는 순수함수로서, 전역 상태를 변경하고 업데이트시킨다. 바닐라 자바스크립트의 '이벤트리스너'와 동일한 역할을 한다고 파악해도 좋다.\n 다만, Redux의 경우, 상태관리를 할 때, 이전상태를 변경시키는 것이 아닌 **새로운 상태의 객체를 생성하여 반환한다**는 점을 명시해야한다.\n *순수함수 : 다른 외부의 상태를 변경하지 않으면서도, 어떤 동일한 인자에 대해 항상 동일한 값을 리턴하는 함수이다.\n\n# 3-3. Recoil 라이브러리\n- 앞서 언급한 Redux는 단방향의 흐름에서 상태관리가 용이하지만, 이를 위한 action, reducer와 같은 초기 세팅이 상당히 번거롭고 React와 잘 맞지 않는다는 여론이 주를 이루었다.\n- React의 상태관리를 보다 React스럽게(hook을 전역으로 확장시킴) 하기 위해, 메타(전 페이스북)사에서 제작한 React 상태관리 라이브러리이다.\n- Recoil은 atom과 selector라는 객체를 사용하여 상태를 관리한다.\n- atom은 구독, 옵저버와 같은 개념을 생각할 필요없이 hook을 사용하듯이 사용하면 된다.\n hook를 사용했던 개발자라면 쉽게 사용할 수 있다.\n- selector를 이용하면 리듀서 없이 복잡한 연산도 간단하게 할 수 있다.",
        "qna": "추가해야함"
      },
      {
        "id": "11",
        "title": "React",
        "topic": "React를 사용하는 이유",
        "texture": "## 🎈주제 선정 이유?\n\n리액트를 활용한 프로젝트를 하면서, 리액트의 장점이 어느정도 느껴졌다. 하지만 누군가 리액트를 왜 사용하나요? 라고 묻는다면 바로 대답하기가 어려울 것 같다는 생각이 들었다. 그래서 이번에 리액트를 왜 사용하는지에 대해 조사하기로 했다.\n\n## ⛳ 학습 목표\n\n리액트는 무엇인지, 그리고 왜 리액트를 사용하는 지에 대해서 학습한다.\n\n## 📖 React를 사용하는 이유\n\n### React란?\n\n![이미지](https://www.notion.so/image/https%3A%2F%2Fvelog.velcdn.com%2Fimages%2Fchoi94%2Fpost%2F9d658f0c-d7a8-4599-991b-015b71e5e644%2Fimage.png?table=block&id=e3459bba-2a1e-4eda-84f7-f147b050c18c&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1890&userId=dcdf2b80-be66-4034-892e-78f7f0c793fa&cache=v2)\n\n**라이브러리**: 라이브러리(영어: library)는 주로 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임이다.\n\n사용자 인터페이스: 사람(사용자)과 사물 또는 시스템, 기계, 컴퓨터 프로그램 등 사이에서 의사소통을 할 수 있도록 일시적 또는 영구적인 접근을 목적으로 만들어진 물리적, 가상적 매개체를 뜻한다.\n\n출처: 위키백과\n\n### React의 특징\n\n1. 가상 돔의 사용으로 DOM 업데이트 최적화\n \n 리액트 개발자들의 DOM 업데이트를 위해서 하는 최적화 행위를 가상 돔을 만들어 비교하고 DOM을 추상화하여 필요한 부분만 다시 그리는 방식으로 개발자들이 DOM 업데이트를 오용하는 일을 피했다.\n \n2. 컴포넌트 기반\n \n 컴포넌트 기반인 리액트는 특정 기능을 구현하거나 특정 화면을 구현할 때 그 화면을 구성하는 일에만 집중할 수 있게 해준다. 여러 명의 프론트엔드 개발자가 하나의 페이지를 만든다고 해도 서로 다른 파일을 작업하도록 구성할 수 있기 때문에 효율적인 코드 분리가 가능하다.\n \n3. 생태계 및 수 많은 커뮤니티와 지속적인 개발\n \n 리액트의 생태계는 여러 다른 라이브러리, 프레임워크 커뮤니티보다 활발하다. 단순 View만을 관리하는 리액트가 프레임워크처러 사람들이 사용할 수 있을 정도이다. 페이스북이 만들었고 주도하고 있으며, AiRbnb, Netflix같은 기업들이 리액트를 사용 중에 있다.\n \n4. React Native의 앱 개발 기능\n \n React Native는 모바일 앱을 만들기 위한 프레임워크로 React 기반으로 만들어졌습니다. 그래서 React로 기존에 개발을 하는 웹 개발자라면 React Native를 금방 배울 수 있고 쉽게 모바일 앱을 만들 수 있다.",
        "qna": "## 4. 요약 정리 및 면접형 QnA\n\n# Q. React은 무엇이고, 왜 사용하는가?\n\n # A.\n\n 리액트는 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리입니다.\n\n그리고 리액트는 아래와 같은 이점이 있어 많이 사용되고 있습니다.\n\n1. 컴포넌트 단위로 구성하여 조합, 분해하기가 쉽습니다.\n\n2. 로직과 뷰를 분리하여 구분하기 쉽습니다.(로직은 컴포넌트의 동작과 상태를 처리하고, 뷰는 컴포넌트의 외형과 사용자 인터페이스를 정의합니다. 이렇게 분리된 코드는 이해하기 쉽고 유지보수가 용이합니다.)\n\n3. 가상 DOM을 활용하기 때문에 화면이 자주 바뀌는 경우 렌더링 자원을 아낄 수 있습니다.\n\n4. 상태 관리와 이에 따른 뷰의 변화를 제어하기 쉽습니다.(상태의 변화를 감지하고, 이에 따른 뷰의 업데이트를 자동으로 처리할 수 있는 기능과 패턴을 제공한다.)"
      },
      {
        "id": "22",
        "title": "React",
        "topic": "CSR과 SSR",
        "texture": "**SPA(Single Page Application)**\r\n\r\n\r\n\r\n하나의 페이지로 구성된 웹 애플리케이션으로 자바스크립트를 이용해 동적으로 화면의 컨텐츠를 바꾼다.\r\n\r\n\r\n\r\n**MPA(Multi Page Application)**\r\n\r\n\r\n\r\n전통적인 방식으로 다른 경로를 이동할 때마다 서버로부터 새로운 HTML파일을 받아와 렌더링한다.\r\n\r\n\r\n\r\n일반적으로 SPA는 CSR방식을, MPA는 SSR방식으로 렌더링 한다. \r\n\r\n\r\n\r\n SPA, MPA는 페이지의 수를 말하는 것이고, CSR, SSR은 렌더링을 어디에서 하냐는 것이다.\r\n\r\n\r\n\r\n## CSR\r\n\r\n\r\n\r\n### 동작 과정\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F56e4dd20-f47e-44cf-a9cb-85710fa8756e%2FUntitled.png?table=block&id=e0c320c0-648f-460c-8f8b-c9a42aa9a5d1&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1130&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n1. 브라우저가 서버에 컨텐츠 요청\r\n\r\n2. 서버는 뼈대만 있는 HTML파일을 응답\r\n\r\n3. 브라우저가 연결된 링크로 자바스크립트 파일 다운로드\r\n\r\n4. 자바스크립트 파일로 동적으로 페이지를 생성해 보여준다.\r\n\r\n\r\n\r\n### 장점\r\n\r\n\r\n\r\n- 초기 로딩 이후에 구동 속도가 빠르다.\r\n\r\n- HTML을 생성하지 않고 파일만 넘겨주기 때문에 서버의 부하가 적다.\r\n\r\n- 전체 페이지가 다시 로드되지 않기 때문에 화면 깜빡임이 없다.\r\n\r\n- 자바스크립트 파일이 다운로드되고 실행돼야 페이지가 보이기 시작하기 때문에 TTV와 TTI가 같다.\r\n\r\n\r\n\r\n<aside>\r\n\r\n💡 TTV, TTI\r\n\r\nTTV(Time To View): 페이지가 로드되어 보이기 시작하는 시점.\r\n\r\nTTI(Time To Interactive): 페이지가 사용자와 상호작용 할 수 있는 상태가 되는 시점.\r\n\r\n\r\n\r\n</aside>\r\n\r\n\r\n\r\n### 단점\r\n\r\n\r\n\r\n- 자바스크립트 파일은 앱에서 필요한 로직 뿐만 아니라 앱을 구동하는 코드도 포함하기 때문에 크기가 크기 때문에 초기 로딩 속도가 느리다.\r\n\r\n- 웹 크롤러는 HTML을 기반으로 검색하기 때문에 SEO에 불리하다. CSR도 크롤링이 가능하지만 여전히 SSR보다는 좋지 않다.\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5e294f5a-9bc4-499d-8cd3-4c4d8dc39e14%2FUntitled.png?table=block&id=247a1420-a338-42ca-b044-ee76c1a6bd33&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n## SSR\r\n\r\n\r\n\r\n### 동작 과정\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5e294f5a-9bc4-499d-8cd3-4c4d8dc39e14%2FUntitled.png?table=block&id=247a1420-a338-42ca-b044-ee76c1a6bd33&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n1. 브라우저가 서버에 컨텐츠 요청\r\n\r\n2. 서버에서 필요한 데이터를 가져와 HTML생성 후 JS파일과 함께 응답\r\n\r\n3. 브라우저는 전달 받은 페이지를 보여준다.\r\n\r\n\r\n\r\n### 장점\r\n\r\n\r\n\r\n- 첫 번째 페이지 로딩이 빠르다.\r\n\r\n- 모든 컨텐츠가 HTML에 담긴채로 브라우저에 전달하기 때문에 SEO에 유리하다.\r\n\r\n\r\n\r\n### 단점\r\n\r\n\r\n\r\n- 페이지 이동 시 html 파일을 서버에서 다시 받아오기 때문에 깜빡이는 현상이 발생한다.\r\n\r\n- 서버에 걸리는 부하가 크다.\r\n\r\n- HTML은 다운로드가 되어 빠르게 볼 수 있지만 자바스크립트가 다운로드 되기까지 반응이 없는 경우가 발생할 수 있다. (TTV와 TTI의 간극이 있다.)\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F79daa224-9e82-40d5-a69d-7109b898494a%2FUntitled.png?table=block&id=c6a1bd44-efdd-4c8c-9d31-6113d7730061&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n### SSG (Static Site Generation)\r\n\r\n\r\n\r\nSSR은 클라이언트의 요청에 대해 HTML을 동적으로 생성해서 전달하지만, SSG는 미리 만들어둔 다음에 준다. 때문에 페이지의 내용이 거의 바뀌지 않는 경우에 적합하다.\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n",
        "qna": "## 정리\r\n\r\n\r\n\r\n### Q. 클라이언트 사이드 렌더링(CSR)과 서버 사이드 렌더링(SSR)의 차이는?\r\n\r\n\r\n\r\n|  | CSR | SSR |\r\n\r\n| --- | --- | --- |\r\n\r\n| 장점 | 화면 깜빡임이 없다.\r\n\r\n초기 로딩 이후 구동 속도 빠름\r\n\r\nTTV와 TTI가 같다.\r\n\r\n서버 부하 분산 | 초기 구동 속도가 빠름\r\n\r\nSEO에 유리하다 |\r\n\r\n| 단점 | 초기 로딩 속도 느림\r\n\r\nSEO에 불리함 | 페이지 이동시 화면 깜빡임 있음\r\n\r\nTTV와 TTI 사이 간극이 있다\r\n\r\n서버 부하가 있다. |\r\n\r\n\r\n\r\n- **Reference**"
      }
    ]
  },
  {
    "title": "CS",
    "items": [
      {
        "id": "3",
        "title": "CS",
        "topic": "API란 무엇인가",
        "texture": " ## 1. 주제 선정 이유\n\n💡 IT업계에서 API라는 용어를 상당히 많이 사용하는 것을 목격할 수 있다. 물론 이러한 문화에 친화적인 개발자라면 당연히 이해하고 넘어갔을 것이지만, 업계에 처음 진입한 사람에게는 너무나도 낯설은 용어라고 생각한다. 특히, 필자인 내가 그랬다. 그래서 이번 기회에 API에 대한 기초적인 개념을 쉬운 비유에 빗대어 설명하고자 한다.\n\n ## 2. API\n\n## 2-1. API의 개념\n\n- API는 Application Programming Interface의 앞자리를 조합하여 만든 용어이다.\n- Application은 기능이나 응용 프로그램을 의미하며, Interface는 상호작용을 의미한다.\n- 즉, API는 **응용 프로그램을 프로그래밍하기 위해 서로 데이터를 주고 받는 상호작용의 방법**이라고 정의할 수 있다.\n\n## 2-2. API의 기능\n\n- API를 실상의 예로 설명한다면, 식당의 메뉴가 적힌 **메뉴판**이라고 빗대어 표현할 수 있다.\n- 여기서 메뉴는 API가 제공하는 데이터 형식의 정보라고 생각하면 된다.\n- 식당에 들어온 손님은 메뉴판을 보고 주방장에게 메뉴를 요청하고, 주방장은 그 메뉴에 맞는 음식을 손님에게 제공한다.\n- 데이터를 요청하는 클라이언트(프론트엔드)에게 서버(백엔드)가 데이터를 제공해주며, 이러한 상호작용을 가능하게 해주는 것이 API이다.\n\n## 2-3. API의 형태\n\n- 웹에서 사용하는 API를 '웹 API'라고 부르며, 모바일에서 사용하는 API를 '모바일 API'라고 부르며, 프론트엔드 개발자가 주로 접하는 API는 HTTP API이다.\n- HTTP는 HyperText Transfer Protocol의 약자로, 인터넷에서 웹페이지를 전송하기 위해 사용하는 프로토콜(규칙)을 의미한다. HTTP는 클라이언트와 서버 간에 데이터를 주고받는 방식을 정의하고 있으며, 웹 브라우저와 웹 서버 간의 통신에 주로 사용한다 ex).네이버 URL : https://www.naver.com/\n- API는 요청방식, 요청자료내용, 자료요청에 필요한 추가정보 순으로 구성되어있다.\nex). 클라이언트가 서버에 영화정보를 요청하는 HTTP API: GET /movies/123456789\n서버가 갖고있는 영화정보:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  'id': 123456789,\n  'title': 'The Shawshank Redemption',\n  'year': 1994,\n  'director': 'Frank Darabont',\n  'genres': ['Drama', 'Crime'],\n  'rating': 9.3\n}\n\n``` \n\n- GET /movies/123456789 : 요청방식 / 요청자료내용 / 추가정보\n\n## 2-4. REST API\n\n- Representational State Transfer의 약자로, 웹 서비스를 위한 아키텍처 스타일, 일종의 **방법론**이라 이해하면 편하다.\n- REST API는 HTTP 프로토콜을 기반으로 동작하며, 클라이언트와 서버 간의 통신을 위해 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용한다.\n- REST API의 특징:\n1. 자원(Resource) 중심적: 리소스(데이터)를 중심으로 API를 설계한다. 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하다.\n2. 상태를 전달(Stateless): 서버는 클라이언트의 상태를 관리하지 않는다. 요청은 필요한 모든 정보를 포함하고, 서버는 각 요청을 독립적으로 처리한다. 클라이언트의 세션 상태는 서버에 저장되지 않으며, 클라이언트는 필요한 경우 인증 토큰 등을 요청에 포함시켜 식별할 수 있다.\n3. 표준화된 인터페이스: REST API는 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)와 HTTP 상태 코드(200 OK, 404 Not Found 등)를 사용하여 일관된 인터페이스를 제공한다. 이는 개발자가 API를 이해하고 사용하기 쉽도록 도와준다.\n4. 계층 구조(Layered System): RESTful 서비스는 다중 계층으로 구성될 수 있다. 중간 서버, 로드 밸런서, 캐싱 서버 등을 통해 보안, 로드 분산, 성능 향상 등을 달성할 수 있다.\n- 정리하면, **REST API는 HTTP API기반으로 개발자들이 보다 쉽게 서버와 상호작용할 수 있도록 하는 표준화된 방법으로, 단순하고 가독성이 좋다는 장점이 있다.**\n\nREST API에 대한 자세한 설명자료영상 :\n\n [![이미지 텍스트](https://img.youtube.com/embed/lsMQRaeKNDk?si=m76TFUVBL0iQENFr/0.jpg)](https://www.youtube.com/watch?v=lsMQRaeKNDk&si=m76TFUVBL0iQENFr)\n\n## 2-5. API의 종류\n\n- API의 종류에는 크게 3가지가 있다.\n1. public API(open API) : 누구나 사용가능한 공개 API (ex. 기상청 : https://www.data.go.kr/data/15095109/openapi.do#tab_layer_detail_function)\n2. private API : 사내에서만 사용하는 API\n3. partner API : 미리 정해준 사용자끼리 사용하는 API",
        "qna": " ## 3. 요약 정리 및 면접형 QnA\n\n # QnA : API는 무엇인가요?\n\n- API는 Application Programming Interface의 약자로, 응용 프로그램을 프로그래밍하기 위해 클라이언트와 서버가 서로 데이터를 주고 받는 상호작용의 방법입니다.\n\n# QnA : 혹시 REST API가 무엇인지 알고 계신가요?\n\n- REST API는 Representational State Transfer의 약자로, HTTP API기반하여 개발자들이 보다 쉽게 서버와 상호작용할 수 있도록 하는 표준화된 API 스타일입니다. 특히 자원중심적인 스타일이기에, 각 리소스가 고유한 URI를 가져 가독성이 좋으며, 표준화된 HTTP 메서드를 사용하기에 단순하다는 장점이 있기 때문에, 현업에서 거의 REST 방식을 사용합니다."
      },
      {
        "id": "4",
        "title": "CS",
        "topic": "REST API란 무엇인가",
        "texture": "## 1. 주제 선정 이유 \n\n지난 IT용어 정리에서 API에 대한 설명을 했으나, 가장 중요한 REST API에 대한 설명을 간략하게 했다고 생각해서 해당 주제에 대해 자세히 설명하고자 선정했다. 프론트 엔드뿐만 아니라 IT업계에서 가장 많이 사용하는 API 방식이기에 이에 대한 정확한 개념은 반드시 숙지해야 할 것이다.\n\n## 2. API란 무엇인가? === 메뉴판 \n\n- Application Programming Interface의 앞자리를 조합하여 만든 용어로, **응용 프로그램을 프로그래밍하기 위해 서로 데이터를 주고 받는 상호작용의 방법**이라고 정의할 수 있다.\n\n- 데이터를 요청하는 클라이언트(프론트엔드)에게 서버(백엔드)가 데이터를 제공해주며, 이러한 상호작용을 가능하게 해주는 것이 API이다.\n\n## 3. REST API란 무엇인가?\n\n# 3-1. REST API의 개념\n- REpresentational State Transfer의 약자로, 웹 서비스를 위한 아키텍처 스타일이다.\n- 어원적으로 분석하면 '대표적인 상태 전달자'로 API 방식 중 가장 많이 그리고 표준적으로 사용되는 **방법론**이다.\n- 아키텍처는 시스템을 구성하는 구성요소들의 조합과 그들 간의 상호작용 방식을 **설계하는 것**을 의미하며, REST API에서 언급하는 웹 서비스를 위한 아키텍처는 **클라이언트-서버 아키텍처**를 의미한다.\n- 클라이언트-서버 아키텍츠는 클라이언트와 서버가 각자의 역할을 분배하여 시스템을 구성한다. 클라이언트는 사용자 인터페이스나 요청을 처리하고, 서버는 그에 필요한 데이터를 전달 및 처리를 하는 역할을 수행한다.\n- 즉, REST API는 웹 서비스를 위한 클라이언트와 서버의 시스템(아키텍처)적 스타일이라 정리 할 수 있다.\n- **REST API는 HTTP 프로토콜을 기반으로 동작한다.**\n\n# 3-2. REST API를 사용하는 이유\n- 자원(Resource) 중심적: 리소스(데이터)를 중심으로 API를 설계한다. 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하다.\n- 표준화된 인터페이스: REST API는 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)와 HTTP 상태 코드(200 OK, 404 Not Found 등)를 사용하여 일관된 인터페이스를 제공한다. 이는 개발자가 API를 이해하고 사용하기 쉽도록 도와준다.\n\n# 3-3. HTTP는 무엇인가?\n- HyperText Transfer Protocol의 약자로, 인터넷에서 웹페이지를 전송하기 위해 사용하는 프로토콜(규칙)을 의미한다.\n- HTTP는 클라이언트가 데이터를 '요청'하고 서버가 이에 '응답'하여 데이터를 주고받는 형태로 이루어져 있다.\n- REST API는 HTTP 프로토콜을 기반으로 동작하기에, 각종 HTTP 메서드를 활용하여 사용자에게 표준화된 인터페이스를 제공한다.\n\n## 4. HTTP 메서드 정리\n- **GET** : 요청받은 URI의 정보를 검색하여 응답한다. 주로 사용자가 클릭하는 대부분의 버튼들이 GET 메서드를 사용한다고 생각해도 무방하다.\n- **POST** : 요청된 자원을 생성(create)한다. 즉, 서버에 새로운 리소스를 생성하거나, 서버에 데이터를 제출하여 처리하고자 할 때 사용한다. 주로 게시물을 작성하거나, 주문 정보를 생성하거나, 새로운 파일을 업로드 하는 등, **새로운 자원을 생성**할 때 사용한다.\n- **PUT** : 요청된 자원 전체를 수정(update)한다. 기존의 URI에 내용을 수정하는 것이기에 새로운 URI를 생성하는 POST와는 차이를 두어야 한다. 주로 리소스를 업데이트할때 PUT 메서드를 사용한다고 이해하면 된다.\n- **PATCH** : 요청된 자원을 수정(update)한다. 다만, 자원 전체를 수정하는 PUT메서드와는 달리, PATCH메서드의 경우 해당자원의 일부만을 교체한다는 차이점이 있다.\n- **DELETE** : 요청된 자원을 삭제할 것을 요청한다. 하지만 안정성의 문제로 대부분의 서버에서는 비활성화 되어있으며, 주로 PATCH를 통해 수정한다고 한다.\n\n# 4-1. POST와 PUT의 차이는 무엇인가?\n- POST 메서드는 INSERT이며 PUT 메서드는 UPDATE이다.\n- POST메서드의 경우, 멱등하지 않아 동일한 자원을 여러 번 POST하면 서버자원에 변화가 생긴다.\n- PUT메서드의 경우, 생성이 아닌 수정을 하며, 여러번 요청해도 서버 리소스에 변화가 없다.\n\n# 4-2. PUT과 PATCH의 차이는 무엇인가?\n- PUT은 해당 자원의 전체를 교체하지만, PATCH는 일부만 변경한다.\n- PUT은 멱등하지만, PATCH는 멱등하지 못하다.\n\n# 4-3. 멱등(Idempotent)은 무엇인가?\n- 동일한 작업을 여러 번 실행하더라도 결과가 동일하게 유지되는 성질을 의미한다.\n- 즉, 동일한 요청을 여러 번 실행하더라도 처음 요청과 같은 상태와 결과를 얻을 수 있다는 것을 의미한다.\n- 이는 요청의 반복 실행이나 중복 전송이 발생해도 시스템의 상태가 변하지 않는 것을 의미한다.",
        "qna": "## 5. 요약 정리 및 면접형 QnA\n\n# 5-1. Q. REST API가 무엇인가요?\n- REST API는 HTTP 프로토콜을 기반으로 동작하는, 웹 서비스를 위한 클라이언트와 서버의 시스템(아키텍처)적 스타일입니다.\n- REST API가 각광받는 이유는 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하고, 일관된 HTTP 프로토콜을 따르기에 개발자로 하여금 친숙하고 편리하기에 자주 사용됩니다.\n\n# 5-2. Q. POST와 PUT의 차이는 무엇인가?\n- POST 메서드는 INSERT이며 PUT 메서드는 UPDATE이다.\n- POST메서드의 경우, 멱등하지 않아 동일한 자원을 여러번 POST하면 서버자원에 변화가 생긴다.\n- PUT메서드의 경우, 멱등하여 동일한 자원을 여러번 PUT하면 서버자원이 변화하지 않고 동일한 리소스로 응답한다.\n- 즉, POST메서드는 새로운 자원을 생성하기에 여러번 요청하면 서버 리소스에 변화가 생기지만, PUT의 경우, 생성이 아닌 수정을 하며, 여러번 요청해도 서버 리소스에 변화가 없다.\n\n# 5-3. Q. PUT과 PATCH의 차이는 무엇인가?\n- PUT은 해당 자원의 전체를 교체하지만, PATCH는 일부만 변경한다.\n- PUT은 멱등하지만, PATCH는 멱등하지 못하다.\n\n# 5-4. Q. 멱등(Idempotent)은 무엇인가?\n- 동일한 작업을 여러 번 실행하더라도 결과가 동일하게 유지되는 성질을 의미한다.\n- 즉, 동일한 요청을 여러 번 실행하더라도 처음 요청과 같은 상태와 결과를 얻을 수 있다는 것을 의미한다.\n- 이는 요청의 반복 실행이나 중복 전송이 발생해도 시스템의 상태가 변하지 않는 것을 의미한다."
      },
      {
        "id": "20",
        "title": "CS",
        "topic": "동기와 비동기, 블로킹과 논블로킹",
        "texture": "## 블로킹/논블로킹\r\n\r\n호출자와 피호출자의 제어권과 관련\r\n\r\n제어권: 코드의 실행 순서를 제어하는 권리로 제어권을 가진 함수는 코드 실행 후 자신을 호출한 함수로 이동한다.\r\n\r\n![블로킹 함수](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F63c27193-518b-4f49-9b5e-5e600e624602%2Fimages_nittre_post_8cdc0a02-d469-47d5-96c8-f6aeef204eb7_image.png?table=block&id=96d24daf-5ab1-4e18-b791-eb7b61700488&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=770&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n블로킹 함수\r\n\r\n![논블로킹 함수](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/44b1e7dd-aed5-4720-80c5-14065f71c4cc/images_nittre_post_c839fc04-1788-4063-ab38-b0d4a312dbf4_image.png)\r\n\r\n논블로킹 함수\r\n\r\n**블로킹**\r\n\r\n1. A함수가 B함수를 호출 (제어권 A → B)\r\n\r\n2. 제어권이 넘어갔기 때문에 A함수는 실행을 중단하고 B함수 실행\r\n\r\n3. B함수 실행이 끝나면 다시 A함수로 제어권 이동\r\n\r\n**논블로킹**\r\n\r\n1. A함수가 B함수 호출(제어권 이동X)\r\n\r\n2. 제어권이 A함수에 있기 때문에 중단하지 않고 코드를 실행\r\n\r\n**제어권이 없는 함수가 어떻게 실행될 수 있을까?**\r\n\r\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6c1adbc7-41e1-42cb-9f53-53c153bae6f0/Untitled.png)\r\n\r\n이벤트 루프, 태스크 큐를 사용!\r\n\r\n비동기 함수의 콜백함수는 태스크 큐에 푸시되어 기다리다가 콜 스택이 비어있으면 이벤트 루프에 의해 다시 콜 스택에 푸시되어 실행한다.\r\n\r\n## 동기/비동기\r\n\r\n작업을 수행하는 시점과 관련\r\n\r\n![동기, 비동기](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5505c0de-1737-4ed5-891a-665bcf50b058/img1.daumcdn.png)\r\n\r\n동기, 비동기\r\n\r\n**동기**\r\n\r\n함수 1을 호출하고 처리 결과를 받아서 확인 후 2번 함수를 수행한다면 동기\r\n\r\n**비동기**\r\n\r\n함수 1을 호출하고 결과를 확인하지 않고 함수 2를 호출한다면 비동기\r\n\r\n## 비동기 == 논블로킹??\r\n\r\n일반적으로 동기와 블로킹, 비동기와 논블로킹이 연관되어 쓰이기 때문에 이 개념을 혼동할 수 있다.\r\n\r\n비동기와 논블로킹의 차이:\r\n\r\n```jsx\r\n\r\nconsole.log(\"시작\");\r\n\r\nsetTimeout(() => {\r\n\r\n  console.log(\"1초 후에 실행됩니다!\");\r\n\r\n}, 1000);\r\n\r\nconsole.log(\"끝\");\r\n\r\n// 결과\r\n\r\n// 시작\r\n\r\n// 끝\r\n\r\n// 1초 후에 실행됩니다!\r\n\r\n```\r\n\r\n자바스크립트의 `setTimeout()`를 예로 들면 이는 비동기, 논블로킹 함수이다.\r\n\r\n`setTimeout()`의 결과가 제일 늦게 나온다. 순서의 관점 ⇒ 비동기\r\n\r\n함수는 타이머 작업을 수행하기 위해 함수를 block하지 않고 백그라운드에서 별도로 처리 ⇒ 논블로킹\r\n\r\n## 크로스오버 예시\r\n\r\n[[Blocking-NonBlocking-Synchronous-Asynchronous - 뒤태지존의 끄적거림 (homoefficio.github.io)](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)](https://camo.githubusercontent.com/b7b28ae739c50d5ed8a4594f52f24e671aeeae234befd0991e5230561ba303bf/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d6874747073253341253246253246626c6f672e6b616b616f63646e2e6e6574253246646e25324664613530597a2532466274713044736a65345a562532466c47653848386e5a676442646746766f3749637a5330253246696d672e706e67)\r\n\r\n[Blocking-NonBlocking-Synchronous-Asynchronous - 뒤태지존의 끄적거림 (homoefficio.github.io)](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)\r\n\r\n두 명의 요리사가 피자, 파스타를 만들어 파는 레스토랑 예시\r\n\r\n- 동기 - 블로킹\r\n\r\n두 요리사는 각각 피자 또는 파스타 요리를 담당하고 있다. 이들이 요리할 때 반드시 순차적으로 처리해야 하는 부분이 있다. 가령 도우 반죽이 완성되어야 반죽을 오븐에 구울 수 있다. 요리사는 도우 반죽이 완성될 때까지 밀대를 놓을 수 없으며(블로킹), 반죽이 다 된 것을 확인한 후에 오븐에 넣을 수 있다(동기).\r\n\r\n- 동기 - 논블로킹\r\n\r\n피자 담당 요리사는 오븐에서 도우가 다 구워진 것을 확인한 다음, 꺼내서 토핑을 얹을 수 있다(동기). 하지만 그동안 다른 일을 할 수 없는 것은 아니다. 요리사는 주기적으로 남은 오븐 시간을 확인하고, 완료되지 않았다면 그동안 토핑을 만들 수 있다(논블로킹). 마침내 시간이 되어 도우가 구워졌다면 꺼내어 토핑을 얹는다.\r\n\r\n- 비동기 - 논블로킹\r\n\r\n피자 담당 요리사와 파스타 담당 요리사는 각자 맡은 요리만 할 뿐, 서로의 요리 과정에는 별 관심이 없다. 각자가 어떤 단계를 수행하고 있는지 확인하지 않고(비동기), 서로의 작업을 방해하지도 않는다(논블로킹). 다만 두 요리가 함께 나가야 한다면, 먼저 완성된 요리와 나중에 완성된 요리를 모아줄 주체가 필요하다.\r\n\r\n- 비동기 - 블로킹\r\n\r\n비동기와 블로킹은 특수한 상황으로 볼 수 있다. 피자 요리사와 파스타 요리사는 서로의 작업에 대해 확인할 필요가 없지만, 모종의 이유로 작업을 번갈아서 수행한다. 피자 요리사가 도우를 반죽하는 동안 파스타 요리사는 쉬고, 파스타 요리사가 면을 삶는 동안 피자 요리사는 쉬는 것이다.\r\n\r\n---\r\n\r\n",
        "qna": "## 정리\r\n\r\n\r\n\r\n### Q. 동기와 비동기, 블로킹과 논블로킹의 차이점은?\r\n\r\n**동기 / 비동기**\r\n\r\n작업을 수행하는 시점과 관련있다.\r\n\r\n- 동기: 요청한 작업에 대해 완료 여부를 따져 순차대로 처리하는 것\r\n\r\n- 비동기: 요청한 작업에 대해 완료 여부를 따지지 않고 다음 작업 수행\r\n\r\n**블로킹 / 논블로킹**\r\n\r\n호출자와 피호출자의 제어권과 관련있다.\r\n\r\n- 블로킹: 요청받은 함수가 작업을 완료하면 요청자에게 제어권이 이동(요청한 작업을 마칠 때까지 기다려야한다.)\r\n\r\n- 논블로킹: 요청받은 함수가 요청자에게 제어권을 바로 넘겨줌(요청한 작업을 즉시 마칠 수 없으면 바로 return)\r\n\r\n- Reference\r\n\r\n    \r\n\r\n    [👩‍💻 완벽히 이해하는 동기/비동기 & 블로킹/논블로킹 (tistory.com)](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC#%EB%8F%99%EA%B8%B0/%EB%B9%84%EB%8F%99%EA%B8%B0_+_%EB%B8%94%EB%A1%9C%ED%82%B9/%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9_%EC%A1%B0%ED%95%A9)\r\n\r\n    \r\n\r\n    [주니어 웹 개발자가 알아야 할 ‘비동기 통신’ | 요즘IT (wishket.com)](https://yozm.wishket.com/magazine/detail/1982/)\r\n\r\n    \r\n\r\n    [[10분 테코톡] 🐰 멍토의 Blocking vs Non-Blocking, Sync vs Async - YouTube](https://www.youtube.com/watch?v=oEIoqGd-Sns&t=259s)\r\n\r\n    \r\n\r\n    [백엔드 개발자들이 알아야할 동시성 2 — 블로킹과 논블로킹, 동기와 비동기 | by Choi Geonu | Medium](https://choi-geonu.medium.com/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EB%8F%99%EC%8B%9C%EC%84%B1-2-%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-e11b3d01fdf8)\r\n\r\n    \r\n\r\n    [Blocking-NonBlocking-Synchronous-Asynchronous - 뒤태지존의 끄적거림 (homoefficio.github.io)](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)\r\n\r\n    \r\n\r\n    [블로킹(Blocking)/논블로킹(Non-Blocking), 동기(Sync)/비동기(Async) 구분하기 (tistory.com)](https://joooing.tistory.com/entry/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9)\r\n\r\n    \r\n\r\n    [블로킹 Vs. 논블로킹, 동기 Vs. 비동기 (velog.io)](https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0)\r\n\r\n    \r\n\r\n    [동기-비동기, 블로킹-논블로킹, 대체 차이가 뭐에요? (velog.io)](https://velog.io/@ohzzi/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8C%80%EC%B2%B4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%AD%90%EC%97%90%EC%9A%94)\""
      },
      {
        "id": "21",
        "title": "CS",
        "topic": "Linked List와 Array",
        "texture": "# Linked List와 Array\r\n\r\n\r\n\r\n선형 자료구조의 배열과 연결 리스트 비교.\r\n\r\n\r\n\r\n<aside>\r\n\r\n💡 **자바스크립트의 배열과 다른 점**\r\n\r\n자바스크립트의 배열은 인덱스를 키로 갖고, length 프로퍼티를 가지고 있는 일반적인 배열을 흉내 낸 특수한 객체이다.\r\n\r\n****\r\n\r\n자바스크립트의 배열은 메모리 공간의 크기가 다르고, 연속적으로 이어져 있지 않는 희소 배열이다.\r\n\r\n자료구조에서 말하는 배열은 같은 데이터 타입과 동일한 크기의 메모리 공간이 연속적으로 나열된 자료구조(밀집 배열)를 말한다.\r\n\r\n\r\n\r\n</aside>\r\n\r\n\r\n\r\n## Array (배열)\r\n\r\n\r\n\r\n데이터 타입과 크기가 정해져 있고, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합이다.\r\n\r\n\r\n\r\n인덱스가 있어 랜덤(직접) 접근이 가능하다.\r\n\r\n\r\n\r\n데이터의 크기는 정해져 있기 때문에 생성 후 변경할 수 없다.\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so//image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F22b0756a-c5c8-4d51-b2f4-2f2f6003b924%2FUntitled.png?table=block&id=32546754-ed15-49a5-8da5-33b1aea9825b&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=&cache=v2)\r\n\r\n\r\n\r\n## Linked List (연결 리스트)\r\n\r\n\r\n\r\n각 노드의 데이터가 포인터로 연결되어 있는 선형 자료구조.\r\n\r\n\r\n\r\n인덱스가 존재하지 않아 랜덤 접근이 불가능하다.\r\n\r\n\r\n\r\n노드: 데이터와 포인터로 구성\r\n\r\n\r\n\r\nhead 노드: 맨 앞에 있는 노드\r\n\r\n\r\n\r\n포인터: 메모리 주소를 가리키는 변수, 다른 노드의 위치 정보\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffe282cb0-ba2a-4219-9bc6-b0cec32fcd86%2FUntitled.png?table=block&id=9b0ca961-11fa-45b8-978c-9df74ab17e27&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=&cache=v2)\r\n\r\n\r\n\r\n단일 연결 리스트: 각 노드에 자료 공간과 next 포인터 한 개만 가진다.\r\n\r\n\r\n\r\n이중 연결 리스트: 포인터 공간이 두 개 있고 next, prev 포인터를 가진다.\r\n\r\n\r\n\r\n원형 연결 리스트: 단일 연결 리스트에서 마지막 노드의 next 포인터가 헤드 노드를 가리킨다.\r\n\r\n\r\n\r\n- 자바스크립트에서 Linked List 구현\r\n\r\n    \r\n\r\n    ```jsx\r\n\r\n    class Node {\r\n\r\n      constructor(value) {\r\n\r\n        this.value = value;\r\n\r\n        this.next = null;\r\n\r\n      }\r\n\r\n    }\r\n\r\n    \r\n\r\n    class LinkedList {\r\n\r\n      constructor() {\r\n\r\n        this.head = null;\r\n\r\n        this.tail = null;\r\n\r\n      }\r\n\r\n    \r\n\r\n      // 맨 끝에 노드 추가\r\n\r\n      append(value) {\r\n\r\n        const newNode = new Node(value);\r\n\r\n    \r\n\r\n        if (!this.head) {\r\n\r\n          // 리스트가 비어있을 경우\r\n\r\n          this.head = newNode;\r\n\r\n          this.tail = newNode;\r\n\r\n        } else {\r\n\r\n          // 이미 노드가 있는 경우\r\n\r\n          this.tail.next = newNode;\r\n\r\n          this.tail = newNode;\r\n\r\n        }\r\n\r\n      }\r\n\r\n    \r\n\r\n      // 특정 위치에 노드 삽입\r\n\r\n      insertAt(index, value) {\r\n\r\n        if (index === 0) {\r\n\r\n          // 리스트의 맨 앞에 삽입하는 경우\r\n\r\n          const newNode = new Node(value);\r\n\r\n          newNode.next = this.head;\r\n\r\n          this.head = newNode;\r\n\r\n          if (!this.tail) {\r\n\r\n            // 리스트가 비어있을 경우\r\n\r\n            this.tail = newNode;\r\n\r\n          }\r\n\r\n        } else {\r\n\r\n          let currentNode = this.head;\r\n\r\n          let currentIndex = 0;\r\n\r\n          while (currentNode && currentIndex < index - 1) {\r\n\r\n            currentNode = currentNode.next;\r\n\r\n            currentIndex++;\r\n\r\n          }\r\n\r\n          if (!currentNode) {\r\n\r\n            // 인덱스가 리스트의 길이보다 큰 경우\r\n\r\n            this.append(value);\r\n\r\n          } else {\r\n\r\n            const newNode = new Node(value);\r\n\r\n            newNode.next = currentNode.next;\r\n\r\n            currentNode.next = newNode;\r\n\r\n            if (currentNode === this.tail) {\r\n\r\n              // 리스트의 맨 끝에 삽입하는 경우\r\n\r\n              this.tail = newNode;\r\n\r\n            }\r\n\r\n          }\r\n\r\n        }\r\n\r\n      }\r\n\r\n    \r\n\r\n      // 특정 위치의 노드 삭제\r\n\r\n      removeAt(index) {\r\n\r\n        if (!this.head) {\r\n\r\n          // 리스트가 비어있는 경우\r\n\r\n          return;\r\n\r\n        }\r\n\r\n    \r\n\r\n        let currentNode = this.head;\r\n\r\n        let previousNode = null;\r\n\r\n        let currentIndex = 0;\r\n\r\n    \r\n\r\n        if (index === 0) {\r\n\r\n          // 리스트의 맨 앞 노드 삭제\r\n\r\n          this.head = currentNode.next;\r\n\r\n          if (currentNode === this.tail) {\r\n\r\n            // 리스트에 노드가 하나만 남아있는 경우\r\n\r\n            this.tail = null;\r\n\r\n          }\r\n\r\n        } else {\r\n\r\n          while (currentNode && currentIndex < index) {\r\n\r\n            previousNode = currentNode;\r\n\r\n            currentNode = currentNode.next;\r\n\r\n            currentIndex++;\r\n\r\n          }\r\n\r\n    \r\n\r\n          if (!currentNode) {\r\n\r\n            // 인덱스가 리스트의 길이보다 큰 경우\r\n\r\n            return;\r\n\r\n          }\r\n\r\n    \r\n\r\n          previousNode.next = currentNode.next;\r\n\r\n    \r\n\r\n          if (currentNode === this.tail) {\r\n\r\n            // 리스트의 맨 끝 노드 삭제\r\n\r\n            this.tail = previousNode;\r\n\r\n          }\r\n\r\n        }\r\n\r\n      }\r\n\r\n    \r\n\r\n      // 리스트 출력\r\n\r\n      print() {\r\n\r\n        let currentNode = this.head;\r\n\r\n        const values = [];\r\n\r\n        while (currentNode) {\r\n\r\n          values.push(currentNode.value);\r\n\r\n          currentNode = currentNode.next;\r\n\r\n        }\r\n\r\n        console.log(values.join(\" -> \"));\r\n\r\n      }\r\n\r\n    }\r\n\r\n    \r\n\r\n    // LinkedList 사용 예시\r\n\r\n    const linkedList = new LinkedList();\r\n\r\n    linkedList.append(1);\r\n\r\n    linkedList.append(2);\r\n\r\n    linkedList.append(3);\r\n\r\n    linkedList.print(); // 출력: 1 -> 2 -> 3\r\n\r\n    \r\n\r\n    linkedList.insertAt(1, 4);\r\n\r\n    linkedList.print(); // 출력: 1 -> 4 -> 2 ->\r\n\r\n    ```\r\n\r\n    \r\n\r\n\r\n\r\n## 배열과 연결 리스트 비교\r\n\r\n\r\n\r\n### 접근\r\n\r\n\r\n\r\n배열은 랜덤 접근이 가능하지만 연결 리스트는 불가능하기 때문에 어떤 요소에 접근하기 위해서는 반드시 첫 번째 요소부터 접근해야 한다.\r\n\r\n\r\n\r\n따라서 접근을 할 때, 배열은 배열의 크기와 상관 없이 동일한 시간이 걸리지만, 연결 리스트는 배열의 크기에 따라 커지게 된다.\r\n\r\n\r\n\r\n### 삽입/삭제\r\n\r\n\r\n\r\n배열은 마지막 요소면 삽입, 삭제 만으로 끝나지만 마지막 요소가 아니라면 해당 요소 뒤의 요소들을 한 칸씩 옮겨야 한다.\r\n\r\n연결 리스트는 첫 번째 요소라면 다음 요소만 연결해 주면 끝나지만 그 이후의 요소라면 순차적으로 탐색하는 시간이 걸린다.\r\n\r\n\r\n\r\n### 메모리\r\n\r\n\r\n\r\n연결 리스트는 데이터 외에도 포인터를 저장할 공간이 필요하기 때문에 더 많은 메모리가 필요하다.\r\n\r\n\r\n\r\n> **시간 복잡도:** 문제를 해결하는데 걸리는 시간과 입력 함수 관계를 나타내는 척도. 주로 빅-오 표기법을 사용해 나타낸다.\r\n\r\n> \r\n\r\n> \r\n\r\n> 빅 오(Big O) 표기법: 계수와 낮은 차수의 항을 제외시키는 방법. \r\n\r\n> \r\n\r\n> ex) 입력의 크기가 n일 때 걸리는 시간이 $O(2n^2 + 2n)$인 경우 $O(n^2)$로 표기\r\n\r\n> \r\n\r\n> ![Untitled](https://www.notion.so//image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb89cdf69-3e2d-4409-915a-e7def4fc63ff%2FUntitled.png?table=block&id=107e525c-7f9e-48f4-b391-0a5d0107fdb6&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=&cache=v2)\r\n\r\n> \r\n\r\n> |  | 접근 | 첫 요소 삽입/삭제 | 중간 요소 삽입/삭제 | 마지막 요소 삽입/삭제 |\r\n\r\n> | --- | --- | --- | --- | --- |\r\n\r\n> | Linked List | O(n) | O(1) | O(n) / search time + O(1) | O(n) |\r\n\r\n> | Array | O(1) | O(n)  | O(n)  | O(1)  |\r\n\r\n\r\n\r\n일반적으로 접근이 잦은 작업이라면 Array, 삽입/삭제가 많은 작업이라면 Linked List를 사용하는 것이 좋다.\r\n\r\n\r\n\r\n",
        "qna": "## 정리\r\n\r\n\r\n\r\n### Q. 연결 리스트와 배열의 차이점은?\r\n\r\n\r\n\r\n|  | Linked List | Array |\r\n\r\n| --- | --- | --- |\r\n\r\n| 접근 | 순차적으로 접근하기 때문에 느림 | 임의로 접근 가능하기 때문에 빠름 |\r\n\r\n| 삽입/삭제 | 요소를 찾아서 연결만 바꿔주면 되기 때문에 빠름 | 삽입/삭제 위치 이후 요소들을 한 칸씩 이동해야하기 때문에 느림 |\r\n\r\n| 메모리 | 연속적으로 배치되지 않기 때문에 포인터 공간과 데이터 공간을 모두 사용해야 하므로 비효율적 | 연속적으로 배치되므로 효율적 |\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n- Reference\r\n\r\n    - 면접을 위한 CS 전공지식 노트\r\n\r\n    - 모던 자바스크립트 딥 다이브\r\n\r\n    - [Difference between Linked List and Arrays (faceprep.in)](https://www.faceprep.in/data-structures/linked-list-vs-array/)\r\n\r\n    - [Interview_Question_for_Beginner/DataStructure at master · JaeYeopHan/Interview_Question_for_Beginner (github.com)](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#array-vs-linked-list)\r\n\r\n    - [Array 배열 기초개념? 10분안에 정리해줌! - YouTube](https://www.youtube.com/watch?v=NFETSCJON2M)\r\n\r\n    - [연결리스트(Linked List)와 배열(Array), 그리고 시간복잡도의 차이에 대해 : 네이버 블로그 (naver.com)](https://m.blog.naver.com/raylee00/221944085465)"
      },
      {
        "id": "23",
        "title": "CS",
        "topic": "디자인 패턴",
        "texture": "### 디자인 패턴\r\n\r\n\r\n\r\n디자인 패턴이란 소프트웨어 개발에서 자주 발생하는 문제들에 대한 재사용 가능한 해결책이다.\r\n\r\n\r\n\r\n디자인 패턴은 구체적인 구현 방법이 아니라 일종의 설계 원칙이므로, 다양한 프로그래밍 언어와 도구에 적용할 수 있다.\r\n\r\n\r\n\r\n**디자인 패턴이 필요한 이유**\r\n\r\n\r\n\r\n- 소프트웨어 디자인의 일반적인 문제들에 대해 시도되고 검증된 해결책을 모은 것이다.\r\n\r\n이런 문제를 다루지 않더라고 객체 지향 디자인 원칙들을 사용해 많은 종류의 문제를 해결하는 방법을 배울 수 있다.\r\n\r\n- 팀원과 더 효율적으로 의사소통 할 수 있는 공통 언어를 정의한다.\r\n\r\n예를 들어 팀의 모두가 디자인 패턴을 이해하면 ‘그 문제를 위해서는 싱글턴을 사용하세요’ 라고 말하면 무엇을 뜻하는지 이해할 수 있고 설명할 필요도 없다.\r\n\r\n\r\n\r\n### GoF 디자인 패턴의 종류\r\n\r\n\r\n\r\n- 생성 패턴\r\n\r\n    - 기존 코드의 재활용과 유연성을 증가시키는 객체 생성 매커니즘들을 제공한다.\r\n\r\n- 구조 패턴\r\n\r\n    - 구조를 유연하고 효율적으로 유지하면서 객체와 클래스를 더 큰 구조로 조합하는 방법을 설명한다.\r\n\r\n- 행동 패턴\r\n\r\n    - 객체 간의 효과적인 의사소통과 책임 할당을 처리한다.\r\n\r\n\r\n\r\n| 생성 패턴 | 구조 패턴 | 행동 패턴 |\r\n\r\n| --- | --- | --- |\r\n\r\n| - 추상 팩토리 (Abstract Factory)\r\n\r\n- 빌더 (Builder)\r\n\r\n- 팩토리 메서드 (Factory Method)\r\n\r\n- 프로토타입 (Prototype)\r\n\r\n- 싱글톤 (Singleton) | - 어댑터 (Adapter)\r\n\r\n- 브리지 (Bridge)\r\n\r\n- 복합체 (Composite)\r\n\r\n- 데코레이터 (Decorator)\r\n\r\n- 퍼사드 (Facade)\r\n\r\n- 플라이웨이트 (Flyweight)\r\n\r\n- 프록시 (Proxy) | - 책임 연쇄 (Chain of Responsibility)\r\n\r\n- 커맨드 (Command)\r\n\r\n- 인터프리터 (Interpreter)\r\n\r\n- 이터레이터 (Iterator)\r\n\r\n- 미디에이터 (Mediator)\r\n\r\n- 메멘토 (Memento)\r\n\r\n- 옵저버 (Observer)\r\n\r\n- 상태 (State)\r\n\r\n- 전략 (Strategy)\r\n\r\n- 템플릿 메서드 (Template Method)\r\n\r\n- 방문자 (Visitor) |\r\n\r\n\r\n\r\n**예시)** **싱글톤 패턴**\r\n\r\n\r\n\r\n하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴이다. \r\n\r\n\r\n\r\n주로 DB연결 모듈에 많이 사용된다.\r\n\r\n\r\n\r\n```jsx\r\n\r\nclass Singleton {\r\n\r\n  constructor() {\r\n\r\n    if (!Singleton.instance) {\r\n\r\n      Singleton.instance = this;\r\n\r\n    }\r\n\r\n    return Singleton.instance;\r\n\r\n  }\r\n\r\n\r\n\r\n  getInstance() {\r\n\r\n    return this.instance;\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\nconst a = new Singleton();\r\n\r\nconst b = new Singleton();\r\n\r\nconsole.log(a === b);\r\n\r\n```\r\n\r\n\r\n\r\n장점: \r\n\r\n\r\n\r\n- 반복적인 인스턴스 생성을 피하고 생성된 인스턴스를 재사용함으로써 메모리 공간을 절약할 수 있다.\r\n\r\n- 인스턴스에 대한 전역 접근 지점을 얻는다.\r\n\r\n\r\n\r\n단점:\r\n\r\n\r\n\r\n- 독립적인 인스턴스를 만들기 어렵기 때문에 단위 테스트가 어렵다.\r\n\r\n\r\n\r\n",
        "qna": "## 정리\r\n\r\n\r\n\r\n### Q. 디자인 패턴이란?\r\n\r\n\r\n\r\n소프트웨어 개발에서 자주 발생하는 문제들에 대한 재사용 가능한 해결책으로 재사용성, 호환성, 유지보수성을 위해 사용한다.\r\n\r\n\r\n\r\n객체의 생성방식을 결정하는 생성 패턴, 객체간의 관계를 조직하는 구조 패턴, 객체의 행위를 관리하는 행위 패턴으로 분류할 수 있다.\r\n\r\n\r\n\r\n- Reference\r\n\r\n    - 면접을 위한 CS 전공지식 노트\r\n\r\n    - [디자인 패턴들 (refactoring.guru)](https://refactoring.guru/ko/design-patterns)\r\n\r\n    - [개발자가 알아야할 디자인패턴 | ep1. Singleton Pattern | 자바스크립트 싱글톤 패턴 - YouTube](https://www.youtube.com/watch?v=M4q3sY81gR8&list=PL3xNAKVIm80JldJ6IZBx5eQxck5JA6VuV)\r\n\r\n    - [Singleton 패턴 | Patterns.dev.kr - 모던 웹 앱 디자인 패턴 (patterns-dev-kr.github.io)](https://patterns-dev-kr.github.io/design-patterns/singleton-pattern/)\r\n\r\n\r\n\r\n더 공부하면 좋을 내용: [프론트엔드에서 MV* 아키텍쳐란 무엇인가요? (velog.io)](https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94#%EA%B3%A0%EC%A0%84-%EC%A4%91%EC%9D%98-%EA%B3%A0%EC%A0%84-mvc-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98)"
      },
      {
        "id": "24",
        "title": "CS",
        "topic": "CORS",
        "texture": "## SOP\r\n\r\n\r\n\r\nSOP(Same-Origin Policy, 동일 출처 정책)\r\n\r\n\r\n\r\n어떤 출처에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 보안 방식이다. 동일 출처 정책은 잠재적으로 해로울 수 있는 문서를 분리함으로써 공격받을 수 있는 경로를 줄여준다.\r\n\r\n\r\n\r\n**Origin(출처)란?**\r\n\r\nOrigin = Protocol + Host + Port(명시한 경우)\r\n\r\n\r\n\r\n![URL 구조](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fc69962b0-3951-485b-b10a-5bb29576bba8%2F27087fe0-dc9e-42e9-971a-01f0874288c0%2FUntitled.png?table=block&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&id=35514320-4eab-46ae-82ad-49633f4120c0&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\nURL 구조\r\n\r\n\r\n\r\n예시) `http://store.company.com/dir/page.html`와 출처 비교\r\n\r\n\r\n\r\n| URL | 결과 | 이유 |\r\n\r\n| --- | --- | --- |\r\n\r\n| http://store.company.com/dir2/other.html | 성공 | 경로만 다름 |\r\n\r\n| http://store.company.com/dir/inner/another.html | 성공 | 경로만 다름 |\r\n\r\n| https://store.company.com/secure.html | 실패 | 프로토콜 다름 |\r\n\r\n| http://store.company.com:81/dir/etc.html | 실패 | 포트 다름 (http://는 80이 기본값) |\r\n\r\n| http://news.company.com/dir/other.html | 실패 | 호스트 다름 |\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbb10b935-5b57-46dd-b3eb-f4fe7aee0d64%2FUntitled.png?table=block&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&id=59d93e45-fc67-464c-8cf0-e486e5ad3e7c&width=1850&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n웹에서는 다른 출처에 있는 리소스를 사용하는 일이 굉장히 흔한 일이기 때문에 몇 가지 예외 조항을 두고 이 조항에 해당 리소스 요청은 출처가 다르더라도 허용하기로 했는데, 그중 하나가 CORS 정책을 지킨 리소스 요청이다.\r\n\r\n\r\n\r\n## CORS\r\n\r\n\r\n\r\nCORS(Cross-Origin Resource Sharing, 교차 출처 리소스 공유)\r\n\r\n\r\n\r\n교차 출처란 다른 출처를 의미한다.\r\n\r\n\r\n\r\nHTTP 헤더를 사용해, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제이다.\r\n\r\n\r\n\r\n### **동작 방식**\r\n\r\n\r\n\r\n1. **Preflight Request**\r\n\r\n    \r\n\r\n    프리플라이트 방식은 웹 개발시 가장 많이 마주치는 시나리오이다.\r\n\r\n    \r\n\r\n    브라우저는 요청을 한번에 보내지 않고 예비 요청과 본 요청으로 나눠 서버로 전송한다.\r\n\r\n    \r\n\r\n    이때 본 요청을 보내기 전에 보내는 예비요청을 Preflight라고 하며, 이 요청에는 HTTP의 `OPTIONS`메소드가 사용된다.\r\n\r\n    \r\n\r\n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fc69962b0-3951-485b-b10a-5bb29576bba8%2F51b5d872-11ca-45e5-90fa-872bcba3dca5%2FUntitled.png?table=block&id=f8b09407-fcf6-4be8-b111-b89890a2760d&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1280&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n    \r\n\r\n    브라우저가 서버에 예비 요청을 먼저 보내고, 서버는 응답으로 자신이 어떤 것을 허용하고 있는지에 대한 정보를 응답 헤더에 담아 브라우저에 다시 보내준다.\r\n\r\n    \r\n\r\n    브라우저는 예비 요청과 서버가 보낸 응답의 허용 정책을 비교한 후 요청을 보내는 것이 안전하다고 판단되면 다시 본 요청을 보낸다.\r\n\r\n    \r\n\r\n2. **Simple Request**\r\n\r\n    \r\n\r\n    단순 요청은 예비 요청을 보내지 않고 바로 서버에게 요청한다. 서버가 응답으로 헤더에 `Access-Control-Allow-Origin`헤더를 전송하면 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다.\r\n\r\n    \r\n\r\n    - 단순 요청은 아래 조건을 **모두** 만족해야 사용할 수 있다.\r\n\r\n        \r\n\r\n        > 다음 중 하나의 메서드\r\n\r\n        > \r\n\r\n        > - `GET`\r\n\r\n        > - `HEAD`\r\n\r\n        > - `POST`\r\n\r\n        > \r\n\r\n        > 유저 에이전트가 자동으로 설정 한 헤더\r\n\r\n        > \r\n\r\n        > - `Accept`\r\n\r\n        > - `Accept-Language`\r\n\r\n        > - `Content-Language`\r\n\r\n        > - `Content-Type` (아래의 추가 요구 사항에 유의하세요.)\r\n\r\n        > \r\n\r\n        > `Content-Type` 헤더는 다음의 값들만 허용됩니다.\r\n\r\n        > \r\n\r\n        > - `application/x-www-form-urlencoded`\r\n\r\n        > - `multipart/form-data`\r\n\r\n        > - `text/plain`\r\n\r\n        > - 요청에 사용된 `XMLHttpRequestUpload` 객체에는 이벤트 리스너가 등록되어 있지 않습니다. 이들은 `XMLHttpRequest.upload` 프로퍼티를 사용하여 접근합니다..\r\n\r\n        > - 요청에 `ReadableStream` 객체가 사용되지 않습니다.\r\n\r\n    \r\n\r\n    ![Untitled](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fc69962b0-3951-485b-b10a-5bb29576bba8%2Fc9d7b2ab-1790-415b-a179-52392e298685%2FUntitled.png?table=block&id=d27bb389-c32c-4f6e-a362-786b37ef6a2e&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1280&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n    \r\n\r\n3. **Credentialed Request**\r\n\r\n\r\n\r\n인증된 요청은 다른 출처 간 통신에서 보안을 강화하고 싶을 때 사용한다.\r\n\r\n\r\n\r\n기본적으로 다른 출처에 대한 요청은 자격 증명(쿠키, 인증 관련 헤더)을 보내지 않는다.\r\n\r\n\r\n\r\ncredential 옵션을 통해 요청에 인증과 관련된 정보를 담을 수 있다.\r\n\r\n\r\n\r\n인증된 요청에서는 `Access-Control-Allow-Origin`에 모든 출처를 허용하는 *(와일드 카드)를 지정할 수 없고 명시적인 URL이어야 한다.\r\n\r\n\r\n\r\n응답 헤더에는 반드시 `Access-Control-Allow-Credentials: true`가 있어야 한다.\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n",
        "qna": "## 정리\r\n\r\n\r\n\r\n### Q1. SOP란?\r\n\r\n\r\n\r\n동일 출처 정책은 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 중요한 보안 방식이다. 악의를 가진 모방 사이트를 제지하기 위해 필요한 제약사항이다.\r\n\r\n\r\n\r\n출처란 프로토콜, 호스트, 포트를 포함한 것을 의미한다.\r\n\r\n\r\n\r\n### Q2. CORS에러가 무엇이고 해결하는 방법은?\r\n\r\n\r\n\r\nSOP를 지키기 위해서 나온 에러고, 그 에러를 해결하기 위해서는 서버에서 CORS 설정을 해주는 것이다. Simple request가 아니라면 예비 요청을 한 번 더 요청하게 된다. 민감한 인증 정보같은 경우는 `Access-Control-Allow-Credentials`를 true로 설정해줘야 하고 이 때 *(와일드카드)를 넣으면 에러가 발생한다.\r\n\r\n\r\n\r\n- - Reference\r\n\r\n  \r\n\r\n  [CORS는 왜 이렇게 우리를 힘들게 하는걸까? | Evans Library (evan-moon.github.io)](https://evan-moon.github.io/2020/05/21/about-cors/)\r\n\r\n  \r\n\r\n  [교차 출처 리소스 공유 (CORS) - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/HTTP/CORS)\r\n\r\n  \r\n\r\n  [동일 출처 정책 - 웹 보안 | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/Security/Same-origin_policy)\r\n\r\n  \r\n\r\n  [웹개발 짜증유발자! CORS가 뭔가요? - YouTube](https://www.youtube.com/watch?v=bW31xiNB8Nc)\r\n\r\n  \r\n\r\n  [CORS - YouTube](https://www.youtube.com/watch?v=j2Q2Ev6CZzQ)"
      },
      {
        "id": "25",
        "title": "CS",
        "topic": "렌더링 과정 - 브라우저는 어떻게 화면을 렌더링할까?",
        "texture": "HTML, CSS, 자바스크립트로 작성된 텍스트 문서를 **어떻게 파싱(해석)하여 브라우저에 렌더링**하는지 알아보기\r\n\r\n\r\n\r\n- 파싱(parsing): parse(분석하다)\r\n\r\n    \r\n\r\n    브라우저가 코드를 이해하고 사용하기 쉬운 구조로 변환하는 것을 말한다.\r\n\r\n    \r\n\r\n    파싱(구문 분석)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰(문법적으로 더는 나눌 수 없는 코드의 기본 요소)으로 분해(어휘 분석)하고, 토큰에 문법적 의미와 구조를 반영하여 트리 구조의 자료구조인 파스 트리를 생성하는 일련의 과정을 말한다. \r\n\r\n    \r\n\r\n- 리소스란: resource(재료, 자산)\r\n\r\n    \r\n\r\n    HTML, CSS, 자바스크립트, 이미지, 폰트 등의 정적 파일 또는 서버가 동적으로 생성한 데이터\r\n\r\n    \r\n\r\n    - 동적으로 생성한 데이터 (참고 사이트: 네이버 뉴스 [https://news.naver.com](https://news.naver.com/)/)\r\n\r\n        \r\n\r\n        ChatGPT에게 물어본 질문\r\n\r\n        \r\n\r\n        서버가 동적으로 생성한 데이터는 클라이언트에게 동적으로 제공되는 정보입니다. 이 데이터는 서버 측에서 요청에 따라 생성되며, 주로 데이터베이스나 외부 API와 상호작용하여 생성됩니다.\r\n\r\n        \r\n\r\n        예를 들어, 웹 애플리케이션이 사용자에게 개인화된 환영 메시지를 보여주기 위해 사용자 이름을 가져와야 한다고 가정해 봅시다. 이 경우, 사용자 이름은 클라이언트가 제공하는 정적 데이터가 아닌, 서버에서 동적으로 생성된 데이터입니다. 서버는 사용자가 요청을 보내면, 데이터베이스에서 사용자 이름을 조회하여 클라이언트에게 반환할 수 있습니다.\r\n\r\n        \r\n\r\n        또 다른 예로는 뉴스 웹사이트를 생각해 볼 수 있습니다. 사용자가 뉴스 카테고리를 선택하면, 서버는 해당 카테고리에 대한 동적으로 생성된 데이터를 가져와서 클라이언트에 표시할 수 있습니다. 이 데이터는 사용자가 선택한 카테고리에 따라 계속 변경될 수 있으므로 동적인 데이터입니다.\r\n\r\n        \r\n\r\n        서버가 동적으로 생성한 데이터는 주로 서버 사이드 프로그래밍 언어(예: PHP, Python, Node.js)를 사용하여 생성되며, 클라이언트에게 전달되기 전에 HTML, CSS 및 JavaScript와 결합되어 웹 페이지를 구성합니다.\r\n\r\n        \r\n\r\n    \r\n\r\n- 렌더링이란?: render(만들다)\r\n\r\n    \r\n\r\n    렌더링은 HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.\r\n\r\n    \r\n\r\n- 웹 브라우저란?: browse(둘러보다, 인터넷을 돌아다니다.)\r\n\r\n    \r\n\r\n    웹 브라우저란 웹에서 정보를 탐색하고 HTML 문서, 이미지 등 여러 콘텐츠를 우리에게 표현해주는 소프트웨어로 구글 크롬(Chrome), 애플의 사파리(Safari), 마이크로소프트 엣지(Microsoft Edge), 모질라 파이어폭스(Firefox) 등이 있다.\r\n\r\n    \r\n\r\n    브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다\r\n\r\n    \r\n\r\n\r\n\r\n프론트엔드 개발자와 떼려야 뗄 수 없는 것은 브라우저다. 그렇기에 이제부터 본격적으로 브라우저의 렌더링에 대해서 알아보겠다. \r\n\r\n\r\n\r\n![브라우저렌더링(구글).png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7fbb8dc8-08de-4cad-b01c-cd0022b93981%2F%25EB%25B8%258C%25EB%259D%25BC%25EC%259A%25B0%25EC%25A0%2580%25EB%25A0%258C%25EB%258D%2594%25EB%25A7%2581(%25EA%25B5%25AC%25EA%25B8%2580).png?table=block&id=e1815fa1-218f-42dc-a9bc-c45c2d011e15&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1920&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n### 브라우저의 렌더링 수행 순서 요약\r\n\r\n\r\n\r\n1. 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.\r\n\r\n2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML, CSS를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합하여 렌더 트리를 생성한다.\r\n\r\n3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다. \r\n\r\n- 바이트 코드\r\n\r\n    \r\n\r\n    바이트코드(Bytecode)는 컴퓨터 프로그램을 실행하기 위해 컴파일러나 인터프리터에 의해 생성되는 저수준의 중간 언어입니다. 바이트코드는 기계어보다는 인간이 이해하기 쉬우면서도 컴퓨터가 실행하기에 효율적인 형태로 작성됩니다.\r\n\r\n    \r\n\r\n1. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.\r\n\r\n\r\n\r\n### 1. 요청과 응답\r\n\r\n\r\n\r\n브라우저의 핵심 기능: 필요한 리소스를 서버에 요청하고 서버로부터 응답받아 브라우저에 시각적으로 렌더링하는 것이다. \r\n\r\n\r\n\r\n서버에 요청을 전송하기 위해 브라우저는 주소창을 제공한다.\r\n\r\n\r\n\r\n브라우저의 주소창에 URL을 입력하고 엔터 키를 누르면 URL의 호스트 이름이 DNS를 통해 IP 주소로 변환되고 이 IP주소를 갖는 서버에게 요청을 전송한다.\r\n\r\n\r\n\r\n- 자세한 설명(ChatGPT)\r\n\r\n    1. 호스트 이름 추출: 먼저, 입력한 URL에서 호스트 이름을 추출합니다. 호스트 이름은 일반적으로 \"**[www.example.com\"과](http://www.example.xn--com%22-nl6w/)** 같이 도메인 이름으로 표시됩니다. URL은 \"http://\" 또는 \"https://\"와 같은 프로토콜로 시작하며, 호스트 이름은 프로토콜과 경로 정보 사이에 위치합니다.\r\n\r\n    2. DNS(Domain Name System) 조회: 추출한 호스트 이름을 DNS에게 전달하여 IP 주소로 변환해야 합니다. DNS는 인터넷 상의 도메인 이름을 해당 도메인의 IP 주소로 매핑하는 역할을 합니다. DNS 서버에 호스트 이름을 보내면 DNS 서버는 해당 호스트 이름에 대한 IP 주소를 찾아서 반환합니다.\r\n\r\n    3. IP 주소 획득: 브라우저는 DNS 조회 결과로부터 호스트 이름에 대응하는 IP 주소를 얻습니다. 이 IP 주소는 해당 웹 서버를 식별하는 고유한 주소입니다.\r\n\r\n    4. 서버 요청: 브라우저는 얻은 IP 주소를 사용하여 웹 서버에 요청을 전송합니다. 이 요청은 HTTP(HyperText Transfer Protocol)나 HTTPS와 같은 프로토콜을 사용하여 서버와 통신하며, 요청 내용은 HTTP 메소드(GET, POST, PUT 등)와 함께 전송됩니다. 요청에는 브라우저가 서버에게 필요한 정보(예: 웹 페이지, 이미지, 동영상)를 요청하는 것이 포함될 수 있습니다.\r\n\r\n    5. 서버 응답: 서버는 요청을 받은 후 해당하는 작업을 수행한 뒤, 클라이언트인 브라우저에게 응답을 보냅니다. 응답은 웹 페이지의 HTML, CSS, JavaScript 코드, 이미지, 동영상 등의 형태로 전달될 수 있습니다. 브라우저는 이 응답을 받아서 해석하고, 필요한 경우 웹 페이지를 렌더링하여 사용자에게 보여줍니다.\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F87f8ab4f-7dc4-4bfa-a86b-4426766ffd2a%2FUntitled.png?table=block&id=01ba5a0a-1c54-456f-88ac-7545a3ad3be3&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n참고: HTTP(HyperText Transfer Protocol)는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)이다. \r\n\r\n\r\n\r\n### 2. HTML 파싱과 DOM 생성\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe5f83b9f-0083-415c-8186-81dbac8b3617%2FUntitled.png?table=block&id=ab7d0192-7c58-4f3e-8296-07a862630231&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1960&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n브라우저의 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트다. 순수한 텍스트인 HTML 문서를 브라우저에 시각적인 픽셀로 렌더링하려면 HTML 문서를 브라우저가 이해할 수 있는 자료구조(객체)로 변환하여 메모리에 저장해야한다. 브라우저의 렌더링 엔진은 응답받은 HTML 문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 DOM(Document Object Model)을 생성한다.\r\n\r\n\r\n\r\n- 자세한 설명\r\n\r\n    1. 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답된다. 이때 서버는 브라우저가 요청한 HTML 파일을 읽어 들여 메모리에 저장한 다음 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답한다.\r\n\r\n    2.  브라우저는 서버가 응답한 HTML 문서를 바이트(2진수) 형태로 응답받는다. 그리고 응답된 바이트 형태의 HTML 문서는 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환된다. 참고로 meta 태그의 charset 어트리뷰트에 선언된 인코딩 방식은 content-type:text/html; charset=utf-8과 같이 응답헤더에 담겨 응답된다. 브라우저는 이를 확인하고 문자열로 변환한다.\r\n\r\n    3.  문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 최소 단위인 토큰들로 분해한다.\r\n\r\n    4.  각 토큰들을 객체로 변환하여 노드들을 생성한다. 토큰의 내용에 따라 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드가 생성된다. 노드는 이후 DOM을 구성하는 기본 요소가 된다.\r\n\r\n    5.  HTML 문서는 HTML 요소들의 집합으로 이루어지며 HTML 요소는 중첩 관계를 갖는다. 즉, HTML 요소의 콘텐츠 영역(시작 태그와 종료 태그 사이)에는 텍스트뿐만 아니라 다른 HTML 요소도 포함될 수 있다. 이때 HTML 요소간에는 중첩 관계에 의해 부자 관계가 형성된다. 이러한 HTML 요소 간의 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다. 이 노드들로 구성된 트리 자료구조를 DOM이라 부른다.\r\n\r\n\r\n\r\n즉, DOM은 HTML 문서를 파싱한 결과물이다. \r\n\r\n\r\n\r\n### 3. CSS파싱과 CSSOM 생성\r\n\r\n\r\n\r\n렌더링 엔진은 HTML을 처음부터 한 줄씩 순차적으로 파싱하여 DOM을 생성해 나간다. 이처럼 렌더링 엔진은 DOM을 생성해 나가다가 CSS를 로드하는 link 태그나 style태그를 만나면 DOM 생성을 일시 중단한다. \r\n\r\n\r\n\r\n그리고 link 태그의 href 어트리뷰트에 지정된 css파일을 서버에 요청하여 로드한 CSS 파일이나 style태그 내의 CSS를 HTML과 동일한 파싱 과정(바이트 → 문자 → 토큰 →  노드 → CSSOM)을 거치며 해석하여 CSSOM을 생성한다. 이후 CSS 파싱을 완료하면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작하여 DOM 생성을 재개한다.\r\n\r\n\r\n\r\n### 4. 렌더 트리 생성\r\n\r\n\r\n\r\n렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 각각 DOM과 CSSOM를 생성한다. 그리고 DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합된다. \r\n\r\n\r\n\r\n렌더 트리: 렌더링을 위한 트리 구조의 자료구조다. 따라서 브라우저 화면에 렌더링되지 않는 노드(ex.meta 태그, script 태그 등)와 CSS에 의해 비표시(ex. display: none)되는 노드들은 포함하지 않는다. 다시 말해, 렌더 트리는 브라우저 화면에 렌더링되는 노드만으로 구성된다. \r\n\r\n\r\n\r\n지금까지 살펴본 브라우저의 렌더링 과정은 반복해서 실행될 수 있다. 예를 들어, 다음과 같은 경우 반복해서 레이아웃 계산과 페인팅이 재차 실행된다.\r\n\r\n\r\n\r\n- 자바스크립트에 의한 노드 추가 또는 삭제\r\n\r\n- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경\r\n\r\n- HTML 요소의 레이아웃(위치, 크기)에 변경을 발생시키는 width/height, margin, padding, border, display, position, top/right/bottom/left 등의 스타일 변경\r\n\r\n\r\n\r\n레이아웃 계산과 페인팅을 다시 실행하는 리렌더링은 비용이 많이 드는, 즉 성능에 악영향을 주는 작업이다.\r\n\r\n\r\n\r\n따라서 가급적 리렌더링이 빈번하게 발생하지 않도록 주의할 필요가 있다.\r\n\r\n\r\n\r\n### 5. 자바스크립트 파싱과 실행\r\n\r\n\r\n\r\nHTML 문서를 파싱한 결과물로서 생성된 DOM은 HTML 문서의 구조와 정보뿐만 아니라 HTML 요소와 스타일 등을 변경할 수 있는 프로그래밍 인터페이스로서 DOM API를 제공한다. 즉, 자바스크립트 코드에서 DOM API를 사용하면 이미 생성된 DOM을 동적으로 조작할 수 있다.\r\n\r\n\r\n\r\n자바스크립트 파싱과 실행은 브라우저의 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. 자바스크립트 엔진은 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행하는 역할을 한다. \r\n\r\n\r\n\r\n렌더링 엔진이 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하듯이 자바스크립트 엔진은 자바스크립트를 해석하여 AST(Abstract Syntax Tree 추상적 구문 트리)를 생성한다. 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다.\r\n\r\n\r\n\r\n바이트코드: 바이트코드는 기계가 이해하기 쉬운 형태로, AST의 추상적인 구문을 구체적인 연산 명령어로 변환한 것입니다. 바이트코드는 일반적으로 인터프리터나 JIT(Just-In-Time) 컴파일러를 통해 실행됩니다.\r\n\r\n\r\n\r\n### 6. 리플로우와 리페인트\r\n\r\n\r\n\r\n만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM이나 CSSOM이 변경된다. 이때 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 리플로우, 리페인트라 한다.\r\n\r\n\r\n\r\n리플로우: 레이아웃 계산을 다시 하는 것을 말하며, 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우에 한하야 실행된다.\r\n\r\n\r\n\r\n리페인트: 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것을 말한다.\r\n\r\n\r\n\r\n따라서 리플로우와 리페인트가 반드시 순차적으로 동시에 실행되는 것은 아닌다. 레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 실행된다. \r\n\r\n\r\n\r\n### 7. 자바스크립트 파싱에 의한 HTML 파싱 중단\r\n\r\n\r\n\r\nDOM을 변경하는 DOM API를 사용할 때 DOM 생성이 완료되지 않은 상태라면 문제가 발생할 수 있다. 이러한 문제를 회피하기 위해 body 요소의 가장 아래에 자바스크립트를 위치시키는 것은 좋은 아이디어다.\r\n\r\n\r\n\r\n- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수 있다.\r\n\r\n- 자바스크립트 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.\r\n\r\n\r\n\r\n### 8. script 태그의 async/defer 어트리뷰트\r\n\r\n\r\n\r\n```jsx\r\n\r\n<!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />\r\n\r\n    <title>Document</title>\r\n\r\n    <script src=\"main.js\"><script>\r\n\r\n  </head>\r\n\r\n  <body></body>\r\n\r\n</html>\r\n\r\n```\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6e338a9b-8dab-432d-acac-115fe4345c95%2FUntitled.png?table=block&id=243c1eb7-5fe6-4f2c-84cd-ad785a47c6e7&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1730&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n1. HTML을 쭉 파싱하다가 script 태그가 보이면 main.js를 다운받아야하네 하고 HTML 파싱을 잠시 멈춘다.\r\n\r\n2. 필요한 JavaScript 파일을 서버에서 다운받아서 이것을 실행한 다음에 다시 HTML 파싱하는 부분으로 넘어간다. // fetch: 가져오다. \r\n\r\n\r\n\r\n→ 단점: JavaScript 파일의 사이즈가 어마어마하게 크고, 인터넷이 엄청 느리면 사용자가 웹사이트를 보는데까지 많은 시간이 소요된다.\r\n\r\n\r\n\r\n그래서 많이 쓰는 방식이 아래와 같다.\r\n\r\n\r\n\r\n```jsx\r\n\r\n<!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />\r\n\r\n    <title>Document</title>\r\n\r\n  </head>\r\n\r\n  <body>\r\n\r\n    <div></div>\r\n\r\n    <script src=\"main.js\"></script>\r\n\r\n  </body>\r\n\r\n</html>\r\n\r\n```\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F43d49b76-3dd2-4078-b241-2c73ebbb6ba2%2FUntitled.png?table=block&id=6a79020f-70ec-48ec-9cc0-30e8dee41278&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1730&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n1. 브라우저가 HTML 다운받아서 쭉 파싱해서 페이지가 다 준비된다.\r\n\r\n2. 다음에 script 태그를 만나서 script를 서버에서 받아오고(fetch), 실행하게 된다.\r\n\r\n\r\n\r\n→ 단점: 사용자가 기본적인 HTML 컨텐츠를 빠르게 볼 수 있지만, 웹사이트가 JavaScript에 매우 의존적이면 사용자가 의미있는 콘텐츠를 보기 위해서 자바스크립트를 이용해서 서버에 있는 데이터를 받아온다던지, DOM 요소를 더 이쁘게 꾸며주는 웹사이트라면 사용자가 정상적인 페이지를 보기 전까지는 오래기다려야한다. \r\n\r\n\r\n\r\n**자바스크립트 파싱에 의한 DOM 생성이 중단되는 문제를 근본적으로 해결하기 위해 HTML5부터 script 태그에 async와 defer 어트리뷰트가 추가되었다.** async와 defer 어트리뷰트는 src 어트리뷰트를 통해 외부 자바스크립트 파일을 로드하는 경우에만 사용할 수 있다.                                                            \r\n\r\n\r\n\r\nasync와 defer 어트리뷰트를 사용하면 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 하지만 실행 시점에 차이가 있다.\r\n\r\n\r\n\r\n1) async 어트리뷰트\r\n\r\n\r\n\r\n: HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 단 자바스크립트의 파싱과 실행은 자바스크립트 파일의 로드가 완료된 직후 진행되며, 이때 HTML 파싱이 중단된다. \r\n\r\n\r\n\r\n```jsx\r\n\r\n!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />페\r\n\r\n    <title>Document</title>\r\n\r\n    <script async src=\"main.js\"><script>\r\n\r\n  </head>\r\n\r\n  <body>\r\n\r\n    <div></div>\r\n\r\n<p></p>\r\n\r\n  </body>\r\n\r\n</html>\r\n\r\n```\r\n\r\nCORS\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdfa4667f-6f24-4e5c-b625-e62165043dbe%2FUntitled.png?table=block&id=c44f5412-4f60-4a78-a2e1-3864567fa5b1&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1730&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\nasync는 불리언타입의 속성값이기 때문에 이렇게 선언하는 것만으로도 true로 설정이 되어서 async 옵션을 사용할 수 있다.\r\n\r\n\r\n\r\n1. async를 사용하게 되면 브라우저가 HTML을 다운로드 받아서 파싱하다가 async가 있으면 병렬로 main.js를 다운로드받자고 명령한다.\r\n\r\n2.  다시 파싱하다가 main.js가 다 다운로드되면 그때 파싱을 멈추고 다운로드된 js파일을 실행한다. \r\n\r\n3. 실행 다하고 나서 나머지 HTML을 파싱하게 된다. \r\n\r\n\r\n\r\n→ 장점: body끝에 사용하는 것보다 fetching이 pasing하는 동안 병렬적으로 일어나기 때문에 다운로드 받는 시간을 절약할 수 있다. \r\n\r\n\r\n\r\n→ 단점: 하지만 js가 HTML이 파싱되기도 전에 실행되어서 만약 js 파일에서 queryselector를 이용해서 DOM 요소를 조작한다고하면 이 조작하려는 시점에 HTML이 원하는 요소가 아직 정의되어 있지 않을 수 있다. 그리고 HTML 파싱하는 동안에 언제든지 js를 실행하기 위해서 멈출 수 있어서 사용자가 페이지를 보는데 시간이 여전히 걸릴 수 있다.\r\n\r\n\r\n\r\n2) defer 어트리뷰트 \r\n\r\n\r\n\r\n: defer 어트리뷰트도 HTML 파싱과 외부 자바스크립트 파일이 로드가 비동기적으로 동시에 진행된다. 단, 자바스크립트의 파싱과 실행은 HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후(이때 DOMContentLoaded 이벤트가 발생한다) 진행된다. 따라서 DOM 생성이 완료된 이후 실행되어야 할 자바스크립트에 유용하다. \r\n\r\n\r\n\r\n```jsx\r\n\r\n!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />\r\n\r\n    <title>Document</title>\r\n\r\n    <script defer src=\"main.js\"><script>\r\n\r\n  </head>\r\n\r\n  <body>\r\n\r\n    <div></div>\r\n\r\n  </body>\r\n\r\n</html>\r\n\r\n```\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F19bfd3a6-4e28-44ce-a102-2fb79ee78ffa%2FUntitled.png?table=block&id=7d041916-7bc6-47df-aee0-4b87c6e236fa&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1730&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n1. 파싱을 하다가 script에 defer가 있으면 main.js를 다운로드 받자 명령만 시켜놓고, 나머지 HTML을 끝까지 파싱한다.\r\n\r\n2. 마지막에 파싱이 끝난 다음에 다운로드된 자바스크립트를 실행한다.\r\n\r\n\r\n\r\n즉, HTML을 파싱하는 동안 필요한 js를 다 다운로드 받고, HTML 파싱을 먼저해서 사용자에게 페이지를 보여준 다음에 바로 이어서 js를 실행한다.\r\n\r\n\r\n\r\n두 개의 차이점을 더 명확하게 파악해보자! \r\n\r\n\r\n\r\n```jsx\r\n\r\n!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />\r\n\r\n    <title>Document</title>\r\n\r\n    <script async src=\"a.js\"><script>\r\n\r\n    <script async src=\"b.js\"><script>\r\n\r\n    <script async src=\"c.js\"><script>\r\n\r\n  </head>\r\n\r\n```\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa2945c44-6882-4bab-81d8-5e8f54ab5e90%2FUntitled.png?table=block&id=fe458900-38ec-48b0-951f-4da4cf489d4a&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1820&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n여러 개의 script 태그에 async 어트리뷰트를 지정하면 script 태그의 순서와는 상관없이 로드가 완료된 자바스크립트부터 먼저 실행되므로 순서가 보장되지 않는다. 따라서 순서 보장이 필요한 script 태그에는 async 어트리뷰트를 지정하지 않아야 한다. (순서에 의존적인거라면 문제가 될 수 있다.)\r\n\r\n\r\n\r\n```jsx\r\n\r\n!DOCTYPE html>\r\n\r\n<html lang=\"ko\">\r\n\r\n  <head>\r\n\r\n    <meta charset=\"UTF-8\" />\r\n\r\n    <title>Document</title>\r\n\r\n    <script defer src=\"a.js\"><script>\r\n\r\n    <script defer src=\"b.js\"><script>\r\n\r\n    <script defer src=\"c.js\"><script>\r\n\r\n  </head>\r\n\r\n```\r\n\r\n\r\n\r\n![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F95e84e91-9b6b-4282-8510-6fe78ac99caf%2FUntitled.png?table=block&id=04532ec6-cd8a-4484-a846-e4800cd07d31&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=1730&userId=62199654-612c-4222-ad05-1416f95ae55b&cache=v2)\r\n\r\n\r\n\r\n파싱하는동안 필요한 js를 다 다운로브받고 순서대로 실행된다. 즉, 정의한 순서가 지켜진다. → 제일 효율적이고 안전하다\r\n\r\n\r\n\r\n",
        "qna": "**브라우저 렌더링 원리에 대해서 설명해보세요.**\r\n\r\n    \r\n\r\n    브라우저 렌더링은 HTML, CSS, JavaScript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정을 말합니다. 브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성됩니다.\r\n\r\n    \r\n\r\n    1. 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.\r\n\r\n    2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML, CSS를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합하여 렌더 트리를 생성한다.\r\n\r\n    3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다. \r\n\r\n    4. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다."
      }
    ]
  }
]
