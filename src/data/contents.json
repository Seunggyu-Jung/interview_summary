[
  {
    "title": "HTML/CSS",
    "items": [
      {
        "id": "1",
        "title": "HTML/CSS",
        "topic": "position",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "2",
        "title": "HTML/CSS",
        "topic": "flex",
        "texture": "![사진](https://likelion.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F22b0756a-c5c8-4d51-b2f4-2f2f6003b924%2FUntitled.png?table=block&id=32546754-ed15-49a5-8da5-33b1aea9825b&spaceId=c69962b0-3951-485b-b10a-5bb29576bba8&width=2000&userId=&cache=v2)",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "3",
        "title": "HTML/CSS",
        "topic": "grid",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "4",
        "title": "HTML/CSS",
        "topic": "tag",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      }
    ]
  },
  {
    "title": "JavaScript",
    "items": [
      {
        "id": "5",
        "title": "JavaScript",
        "topic": "객체",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "6",
        "title": "JavaScript",
        "topic": "props",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "7",
        "title": "JavaScript",
        "topic": "class",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "8",
        "title": "JavaScript",
        "topic": "호이스팅",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      }
    ]
  }
]
