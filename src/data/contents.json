[
  {
    "title": "HTML/CSS",
    "items": [
      {
        "id": "1",
        "title": "JavaScript",
        "topic": "객체",
        "texture": "# 1. 주제 선정 이유:\n\n자바스크립트가 객체 지향 언어라는 것은 다들 알고 있을 것이다. 그럼 여기서 말하는 객체란 과연 무엇인가?\n우리가 알고 있는 객체는 키와 값으로 이루어진 중괄호 라고 알고있는데, 이에 대해 자세히 파악하여 **수업을 하거나 협업을 할 때, 보다 더 원활하게 소통할 수 있도록 돕고자** 조사해봤다.\n\n# Ⅱ. 객체\n\n## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```\n\n### 4). 추상화\n\n- 객체의 핵심적인 특징을 강조하고, 불필요한 부분을 생략하는 것\n- 객체를 단순화시키고, 객체가 내부적으로 어떻게 구현되었는지 숨기기 때문에 코드의 가독성과 안정성이 향상\n\n## 3-2). 객체 지향 프로그래밍 언어의 장점\n\n### 1). 재사용성\n\n- 객체간에 계층이 부여되면 상속을 할 수 있고, 그 과정에서 공통된 코드는 다시 작성할 필요가 없어 **구동 시간이나 로딩 시간이 상당히 절약됨**\n\n### 2). 가독성\n\n- 객체지향 프로그래밍에서는 객체의 속성과 메서드를 **명확하게 정의**하고, 객체 간의 상호작용을 **명확하게 표현 가능**\n- 이를 통해 코드의 가독성이 높아지며, 코드의 이해 및 유지보수가 용이해짐\n\n### 3). 유지보수성\n\n- 객체지향 프로그래밍에서는 코드를 **객체 단위로 모듈화**하여 작성하기 때문에, **수정이나 추가를 할 때 해당 객체만 수정**하면 되기에 관리에 용이\n\n※ 모듈화 : 코드를 하나의 파일에 작성하는 것이 아니라, **나누어** 마치 조립하듯이 구조화시키는 것을 의미\n\n- 자바스크립트의 경우, ES6(ES2015)의 모듈 방식을 주로 사용하는데, 이는 import와 export를 사용하는 방식이며, 이를 위해 **Babel**과 같은 도구를 사용하여 코드를 컴파일해야 함\n\n```jsx\n// myModule.js // 보내는 모듈\nexport const foo = function() {\n  console.log('Hello, World!');\n};\nexport const bar = function() {\n  console.log('Bye, World!');\n};\n\n// app.js  // 받는 모듈\nimport { foo, bar } from './myModule';\nfoo(); // 'Hello, World!' 출력\nbar(); // 'Bye, World!' 출력\n\n```\n\n# **번외)**. 함께 알아두면 좋은 용어\n\n### 1. Babel\n\n- 자바스크립트 코드를 컴파일러로 변환해주는 오픈소스 도구\n- 주로 최신 버전의 자바스크립트 코드를 예전 버전으로 변환하여, 구형 브라우저에서도 실행 가능한 코드로 변환하는데 사용\n\n### 2. 컴파일러(Compiler)\n\n- 프로그래밍 언어로 작성된 소스 코드를 기계어로 변환해주는 소프트웨어\n- 자바스크립트의 경우, 인터프리터 언어라서 별도의 컴파일러가 필요\n\n### 3. 인터프리터 언어\n\n- 프로그램의 소스 코드를 직접 실행하는 언어로, 컴파일러와는 달리 컴파일 과정 없이 소스 코드를 바로 실행\n- 대표적인 인터프리터 언어 : JavaScript, Ruby, PHP...\n- 코드를 한 줄 한 줄씩 읽어 들이며 실행하기에 명령 자체의 속도는 컴파일러 언어에 비해 느리다는 단점이 있음\n- 오류 발견 즉시 해결할 수 있다는 장점이 있음",
        "qna": "아직 없음"
      },
      {
        "id": "2",
        "title": "JavaScript",
        "topic": "상속",
        "texture": "# 1. 주제 선정 이유\n\n코딩을 하다보면, 종종 상속이라는 용어를 많이 들어봤을 것이다. 물론, 상속의 사전적인 개념인 '하위존재가 상위존재로부터 무언가를 물림받는다.' 는 것 정도는 유추할 수 있을 것이다. 하지만, 코딩이나 IT업계에서 언급하는 상속에 대해 제대로 알고 넘어가는 것이 실제로 프로젝트에 적용할 때, 보다 수월하고 익숙하게 사용할 수 있을 것이기에 선정했다.\n\n# 2. 상속\n\n## 2-1. 상속의 정의 및 종류\n\n- 자바스크립트에서 사용되는 상속은 프로토타입 상속과 클래스 상속 크게 두 가지로 나뉜다. \n- 프로토타입 상속 : 상속을 받든 객체가 상속을 해주는 객체의 프로퍼티나 메서드를 추가로 사용할 수 있게 해주는 체계를 의미한다. \n- 클래스 상속 : 기존의 클래스를 확장시키는 개념으로 이해하면 좋다. 상속받은 기존의 클래스를 토대로 새로운 기능을 추가하는 시스템을 의미한다.\n\n## 2-2. 프로토타입과 상속의 관계\n\n- 프로토타입 (객체) : 다른 객체에 대한 참조 하는 대상을 의미한다. 모든 객체는 [[prototype]]이라는 내부 프로퍼티를 갖는다. [[prototype]]를 저장창고라고 이해면 좋다.\n\n - 예를 들어, 아래의 경우, 전부 객체로 이루어져있기에 객체의 프로토타입은, [[prototype]] : Object 즉, Object.prototype이다. 그리고 상속받는 객체들이 [[prototype]]안으로 들어간다. \n- `__proto__` : 객체가 자신의 프로토타입에 접근하도록 해주는 접근자 프로퍼티이다. 일종의 **다리(bridge)**라고 이해하면 좋을 듯하다. 해당 프로퍼티를 사용하여 상속받을 객체가 자신의 프로토타입에 들어갈 수 있도록 연결해준다. \n - 즉, `__proto__` 를 사용하여 상위(부모) 객체가 하위(자식) 객체의 프로토타입에 추가되는 과정을 상속이라고 한다.\n\n![사진](https://velog.velcdn.com/images/dainel-q/post/0ba7368c-6a60-4f68-8da4-be69a0422c37/image.png) \n\n## Q. 그런데 왜 프로토타입 상속을 하는 것인가요??\n\n -우선은 한 사례를 통해 살펴보자\n\n![사진](https://velog.velcdn.com/images/dainel-q/post/7f14b541-0997-4b62-b31f-86a9e4328d7c/image.png)\n - 위 예시의 경우, food를 상속받은 pasta 객체가 cook이라는 메서드를 자유롭게 사용할 수 있는 사례이다. 즉, pasta 객체에서 cook메서드를 더 만들지 않고 상속받아 편하게 사용할 수 있다는 것을 의미한다. 이는 곧, 코드의 재사용성을 높이고 , 관리를 용이하게 해준다는 장점을 갖고 있다.\n\n## 2-3. 클래스와 상속의 관계\n\n- 클래스(class) : 하나의 생성자 함수를 여러개 찍어낼 수 있게 해주는 문법으로 흔히 붕어빵 틀에 비유한다. - 먼저 상속을 할 부모 클래스를 생성한다.\n\nclass Food {\n constructor (name) {\n this.name = name;\n this.won = 0;\n }\n\n price(won) {\n this.won = won;\n console.log(${this.name}의 가격은 ${this.won}원 입니다.)\n }\n\n pay(){\n console.log(${this.won}원을 지불하셨습니다.)\n }\n}\n\nconst food = new Food('음식');\n\nclass Pasta extends Food {\n tasty(){\n console.log(${this.name} 맛있네요!)\n }\n}\n\nconst pasta = new Pasta('아라비따 파스타');\n\n- 위 예시를 합치면\nclass Food {\n constructor (name) {\n this.name = name;\n this.won = 0;\n }\n\n price(won) {\n this.won = won;\n console.log(${this.name}의 가격은 ${this.won}원 입니다.)\n }\n\n pay(){\n console.log(${this.won}원을 지불하셨습니다.)\n }\n}\n\nconst food = new Food('음식');\n\nclass Pasta extends Food {\n tasty(){\n console.log(${this.name} 맛있네요!)\n }\n}\n\nconst pasta = new Pasta('아라비따 파스타');\n\n- pasta클래스는 food 클래스를 상속받고 있다는 것을 의미한다. 그렇기에 food클래스의 메서드를 사용할 수 있다.\npasta.price(12000; // 아라비따 파스타의 가격은 12000원 입니다.\npasta.pay(12000); // 12000원을 지불하셨습니다.\npasta.tasty(); // 아라비따 파스타 맛있네요!\n\n## Q. 그런데 왜 클래스 상속을 하는 것인가요??\n\n- 프로토타입의 상속을 하는 이유와 유사하게, 상속을 주고 받기에, 작성해야할 코드의 양이 줄어든다. 특히, 클래스의 경우, 생성자 메서드등 작성해야할 내용이 많기에, 상속의 장점이 더욱 부각된다. - 코드의 재사용성을 높이고 , 관리를 용이하게 해준다는 장점이 있기 때문에 사용한다.",
        "qna": "# 3. 요약 정리 및 면접형 QnA\n\nQnA: 자바스크립트에서 사용하는 상속은 무엇이고, 그 기능이 무엇인가요?\n\n상속은 상속받는 자식요소가 상속해주는 부모요소의 프로퍼티나 메서드를 **추가로** 사용할 수 있도록 **확장**해주는 기능입니다. 자바스크립트의 경우, **프로토타입 상속**과 **클래스 상속** 두 가지 유형의 상속이 있습니다.\n\n- 프로토타입의 상속은, 객체 안의 `[[prototype]]`라는 내부 프로퍼티 안에 `__proto__`라는 접근자 프로퍼티로 객체들을 상속받아 저장하여 사용합니다.\n- 클래스 상속은, 부모 클래스를 `extends`라는 키워드를 사용하여 자식 클래스가 상속받아 사용합니다.\n\n상속을 사용하는 이유는 코드의 재사용성을 높이고, 유지보수가 필요한 경우 특정 부분만 수정해도 되기에 관리를 용이하게 만든다는 장점이 있습니다."
      },
      {
        "id": "3",
        "title": "CS",
        "topic": "API란 무엇인가",
        "texture": " ## 1. 주제 선정 이유\n\n💡 IT업계에서 API라는 용어를 상당히 많이 사용하는 것을 목격할 수 있다. 물론 이러한 문화에 친화적인 개발자라면 당연히 이해하고 넘어갔을 것이지만, 업계에 처음 진입한 사람에게는 너무나도 낯설은 용어라고 생각한다. 특히, 필자인 내가 그랬다. 그래서 이번 기회에 API에 대한 기초적인 개념을 쉬운 비유에 빗대어 설명하고자 한다.\n\n ## 2. API\n\n## 2-1. API의 개념\n\n- API는 Application Programming Interface의 앞자리를 조합하여 만든 용어이다.\n- Application은 기능이나 응용 프로그램을 의미하며, Interface는 상호작용을 의미한다.\n- 즉, API는 **응용 프로그램을 프로그래밍하기 위해 서로 데이터를 주고 받는 상호작용의 방법**이라고 정의할 수 있다.\n\n## 2-2. API의 기능\n\n- API를 실상의 예로 설명한다면, 식당의 메뉴가 적힌 **메뉴판**이라고 빗대어 표현할 수 있다.\n- 여기서 메뉴는 API가 제공하는 데이터 형식의 정보라고 생각하면 된다.\n- 식당에 들어온 손님은 메뉴판을 보고 주방장에게 메뉴를 요청하고, 주방장은 그 메뉴에 맞는 음식을 손님에게 제공한다.\n- 데이터를 요청하는 클라이언트(프론트엔드)에게 서버(백엔드)가 데이터를 제공해주며, 이러한 상호작용을 가능하게 해주는 것이 API이다.\n\n## 2-3. API의 형태\n\n- 웹에서 사용하는 API를 '웹 API'라고 부르며, 모바일에서 사용하는 API를 '모바일 API'라고 부르며, 프론트엔드 개발자가 주로 접하는 API는 HTTP API이다.\n- HTTP는 HyperText Transfer Protocol의 약자로, 인터넷에서 웹페이지를 전송하기 위해 사용하는 프로토콜(규칙)을 의미한다. HTTP는 클라이언트와 서버 간에 데이터를 주고받는 방식을 정의하고 있으며, 웹 브라우저와 웹 서버 간의 통신에 주로 사용한다 ex).네이버 URL : https://www.naver.com/\n- API는 요청방식, 요청자료내용, 자료요청에 필요한 추가정보 순으로 구성되어있다.\nex). 클라이언트가 서버에 영화정보를 요청하는 HTTP API: GET /movies/123456789\n서버가 갖고있는 영화정보:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  'id': 123456789,\n  'title': 'The Shawshank Redemption',\n  'year': 1994,\n  'director': 'Frank Darabont',\n  'genres': ['Drama', 'Crime'],\n  'rating': 9.3\n}\n\n``` \n\n- GET /movies/123456789 : 요청방식 / 요청자료내용 / 추가정보\n\n## 2-4. REST API\n\n- Representational State Transfer의 약자로, 웹 서비스를 위한 아키텍처 스타일, 일종의 **방법론**이라 이해하면 편하다.\n- REST API는 HTTP 프로토콜을 기반으로 동작하며, 클라이언트와 서버 간의 통신을 위해 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용한다.\n- REST API의 특징:\n1. 자원(Resource) 중심적: 리소스(데이터)를 중심으로 API를 설계한다. 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하다.\n2. 상태를 전달(Stateless): 서버는 클라이언트의 상태를 관리하지 않는다. 요청은 필요한 모든 정보를 포함하고, 서버는 각 요청을 독립적으로 처리한다. 클라이언트의 세션 상태는 서버에 저장되지 않으며, 클라이언트는 필요한 경우 인증 토큰 등을 요청에 포함시켜 식별할 수 있다.\n3. 표준화된 인터페이스: REST API는 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)와 HTTP 상태 코드(200 OK, 404 Not Found 등)를 사용하여 일관된 인터페이스를 제공한다. 이는 개발자가 API를 이해하고 사용하기 쉽도록 도와준다.\n4. 계층 구조(Layered System): RESTful 서비스는 다중 계층으로 구성될 수 있다. 중간 서버, 로드 밸런서, 캐싱 서버 등을 통해 보안, 로드 분산, 성능 향상 등을 달성할 수 있다.\n- 정리하면, **REST API는 HTTP API기반으로 개발자들이 보다 쉽게 서버와 상호작용할 수 있도록 하는 표준화된 방법으로, 단순하고 가독성이 좋다는 장점이 있다.**\n\nREST API에 대한 자세한 설명자료영상 :\n\nhttps://www.youtube.com/watch?v=lsMQRaeKNDk\n\n## 2-5. API의 종류\n\n- API의 종류에는 크게 3가지가 있다.\n1. public API(open API) : 누구나 사용가능한 공개 API (ex. 기상청 : https://www.data.go.kr/data/15095109/openapi.do#tab_layer_detail_function)\n2. private API : 사내에서만 사용하는 API\n3. partner API : 미리 정해준 사용자끼리 사용하는 API",
        "qna": " ## 3. 요약 정리 및 면접형 QnA\n\n # QnA : API는 무엇인가요?\n\n- API는 Application Programming Interface의 약자로, 응용 프로그램을 프로그래밍하기 위해 클라이언트와 서버가 서로 데이터를 주고 받는 상호작용의 방법입니다.\n\n# QnA : 혹시 REST API가 무엇인지 알고 계신가요?\n\n- REST API는 Representational State Transfer의 약자로, HTTP API기반하여 개발자들이 보다 쉽게 서버와 상호작용할 수 있도록 하는 표준화된 API 스타일입니다. 특히 자원중심적인 스타일이기에, 각 리소스가 고유한 URI를 가져 가독성이 좋으며, 표준화된 HTTP 메서드를 사용하기에 단순하다는 장점이 있기 때문에, 현업에서 거의 REST 방식을 사용합니다."
      },
      {
        "id": "4",
        "title": "CS",
        "topic": "REST API란 무엇인가",
        "texture": "## 1. 주제 선정 이유 \n\n지난 IT용어 정리에서 API에 대한 설명을 했으나, 가장 중요한 REST API에 대한 설명을 간략하게 했다고 생각해서 해당 주제에 대해 자세히 설명하고자 선정했다. 프론트 엔드뿐만 아니라 IT업계에서 가장 많이 사용하는 API 방식이기에 이에 대한 정확한 개념은 반드시 숙지해야 할 것이다.\n\n## 2. API란 무엇인가? === 메뉴판 \n\n- Application Programming Interface의 앞자리를 조합하여 만든 용어로, **응용 프로그램을 프로그래밍하기 위해 서로 데이터를 주고 받는 상호작용의 방법**이라고 정의할 수 있다.\n\n- 데이터를 요청하는 클라이언트(프론트엔드)에게 서버(백엔드)가 데이터를 제공해주며, 이러한 상호작용을 가능하게 해주는 것이 API이다.\n\n## 3. REST API란 무엇인가?\n\n# 3-1. REST API의 개념\n- REpresentational State Transfer의 약자로, 웹 서비스를 위한 아키텍처 스타일이다.\n- 어원적으로 분석하면 '대표적인 상태 전달자'로 API 방식 중 가장 많이 그리고 표준적으로 사용되는 **방법론**이다.\n- 아키텍처는 시스템을 구성하는 구성요소들의 조합과 그들 간의 상호작용 방식을 **설계하는 것**을 의미하며, REST API에서 언급하는 웹 서비스를 위한 아키텍처는 **클라이언트-서버 아키텍처**를 의미한다.\n- 클라이언트-서버 아키텍츠는 클라이언트와 서버가 각자의 역할을 분배하여 시스템을 구성한다. 클라이언트는 사용자 인터페이스나 요청을 처리하고, 서버는 그에 필요한 데이터를 전달 및 처리를 하는 역할을 수행한다.\n- 즉, REST API는 웹 서비스를 위한 클라이언트와 서버의 시스템(아키텍처)적 스타일이라 정리 할 수 있다.\n- **REST API는 HTTP 프로토콜을 기반으로 동작한다.**\n\n# 3-2. REST API를 사용하는 이유\n- 자원(Resource) 중심적: 리소스(데이터)를 중심으로 API를 설계한다. 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하다.\n- 표준화된 인터페이스: REST API는 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE)와 HTTP 상태 코드(200 OK, 404 Not Found 등)를 사용하여 일관된 인터페이스를 제공한다. 이는 개발자가 API를 이해하고 사용하기 쉽도록 도와준다.\n\n# 3-3. HTTP는 무엇인가?\n- HyperText Transfer Protocol의 약자로, 인터넷에서 웹페이지를 전송하기 위해 사용하는 프로토콜(규칙)을 의미한다.\n- HTTP는 클라이언트가 데이터를 '요청'하고 서버가 이에 '응답'하여 데이터를 주고받는 형태로 이루어져 있다.\n- REST API는 HTTP 프로토콜을 기반으로 동작하기에, 각종 HTTP 메서드를 활용하여 사용자에게 표준화된 인터페이스를 제공한다.\n\n## 4. HTTP 메서드 정리\n- **GET** : 요청받은 URI의 정보를 검색하여 응답한다. 주로 사용자가 클릭하는 대부분의 버튼들이 GET 메서드를 사용한다고 생각해도 무방하다.\n- **POST** : 요청된 자원을 생성(create)한다. 즉, 서버에 새로운 리소스를 생성하거나, 서버에 데이터를 제출하여 처리하고자 할 때 사용한다. 주로 게시물을 작성하거나, 주문 정보를 생성하거나, 새로운 파일을 업로드 하는 등, **새로운 자원을 생성**할 때 사용한다.\n- **PUT** : 요청된 자원 전체를 수정(update)한다. 기존의 URI에 내용을 수정하는 것이기에 새로운 URI를 생성하는 POST와는 차이를 두어야 한다. 주로 리소스를 업데이트할때 PUT 메서드를 사용한다고 이해하면 된다.\n- **PATCH** : 요청된 자원을 수정(update)한다. 다만, 자원 전체를 수정하는 PUT메서드와는 달리, PATCH메서드의 경우 해당자원의 일부만을 교체한다는 차이점이 있다.\n- **DELETE** : 요청된 자원을 삭제할 것을 요청한다. 하지만 안정성의 문제로 대부분의 서버에서는 비활성화 되어있으며, 주로 PATCH를 통해 수정한다고 한다.\n\n# 4-1. POST와 PUT의 차이는 무엇인가?\n- POST 메서드는 INSERT이며 PUT 메서드는 UPDATE이다.\n- POST메서드의 경우, 멱등하지 않아 동일한 자원을 여러 번 POST하면 서버자원에 변화가 생긴다.\n- PUT메서드의 경우, 생성이 아닌 수정을 하며, 여러번 요청해도 서버 리소스에 변화가 없다.\n\n# 4-2. PUT과 PATCH의 차이는 무엇인가?\n- PUT은 해당 자원의 전체를 교체하지만, PATCH는 일부만 변경한다.\n- PUT은 멱등하지만, PATCH는 멱등하지 못하다.\n\n# 4-3. 멱등(Idempotent)은 무엇인가?\n- 동일한 작업을 여러 번 실행하더라도 결과가 동일하게 유지되는 성질을 의미한다.\n- 즉, 동일한 요청을 여러 번 실행하더라도 처음 요청과 같은 상태와 결과를 얻을 수 있다는 것을 의미한다.\n- 이는 요청의 반복 실행이나 중복 전송이 발생해도 시스템의 상태가 변하지 않는 것을 의미한다.",
        "qna": "## 5. 요약 정리 및 면접형 QnA\n\n# 5-1. Q. REST API가 무엇인가요?\n- REST API는 HTTP 프로토콜을 기반으로 동작하는, 웹 서비스를 위한 클라이언트와 서버의 시스템(아키텍처)적 스타일입니다.\n- REST API가 각광받는 이유는 각 리소스는 고유한 식별자(URI)를 가지기 때문에 가독성이 좋아 수정이나 변경이 용이하고, 일관된 HTTP 프로토콜을 따르기에 개발자로 하여금 친숙하고 편리하기에 자주 사용됩니다.\n\n# 5-2. Q. POST와 PUT의 차이는 무엇인가?\n- POST 메서드는 INSERT이며 PUT 메서드는 UPDATE이다.\n- POST메서드의 경우, 멱등하지 않아 동일한 자원을 여러번 POST하면 서버자원에 변화가 생긴다.\n- PUT메서드의 경우, 멱등하여 동일한 자원을 여러번 PUT하면 서버자원이 변화하지 않고 동일한 리소스로 응답한다.\n- 즉, POST메서드는 새로운 자원을 생성하기에 여러번 요청하면 서버 리소스에 변화가 생기지만, PUT의 경우, 생성이 아닌 수정을 하며, 여러번 요청해도 서버 리소스에 변화가 없다.\n\n# 5-3. Q. PUT과 PATCH의 차이는 무엇인가?\n- PUT은 해당 자원의 전체를 교체하지만, PATCH는 일부만 변경한다.\n- PUT은 멱등하지만, PATCH는 멱등하지 못하다.\n\n# 5-4. Q. 멱등(Idempotent)은 무엇인가?\n- 동일한 작업을 여러 번 실행하더라도 결과가 동일하게 유지되는 성질을 의미한다.\n- 즉, 동일한 요청을 여러 번 실행하더라도 처음 요청과 같은 상태와 결과를 얻을 수 있다는 것을 의미한다.\n- 이는 요청의 반복 실행이나 중복 전송이 발생해도 시스템의 상태가 변하지 않는 것을 의미한다."
      },
      {
        "id": "5",
        "title": "React",
        "topic": "라이브러리란 무엇인가",
        "texture": "## 1. 주제 선정 이유 \n각종 프로젝트를 준비하는 과정에서 라이브러리의 중요성을 많이 언급되며, 실제 기업에서도 특정 라이브러리를 사용하여 프로젝트를 진행한 경험을 요구하는 경우가 많다고 느꼈을 것이다. 라이브러리가 정확하게 무엇이며 어떤 종류가 있으며, 왜 사용하는지에 대해 자세히 알아보고자 준비함\n\n## 2. 라이브러리란\n\n# 2-1. 라이브러리의 정의\n- 소프트웨어를 개발할 때, 컴퓨터 프로그램이 사용하는 '비휘발성 자원(리소스)'의 집합이다.\n- 사전적 용어인 도서관(library)와 비슷하게, 특정한 코드들(책들)을 모아둔 집합이라 생각하면 된다.\n- 이는 소프트웨어 개발시에 사용되는 프로그램의 구성요소로, 공통으로 사용될 수 있는 특정한 기능들을 모듈(module)화 한 것이다.\n- API와의 차이점 : API는 프로그래밍 언어에서 라이브러리를 사용할 수 있도록 소스코드 수준에서 인터페이스를 노출 시킨 것이지만, 라이브러리는 실제 실행되어 기능을 수행하는 **단편화된 프로그램** 이다.\n- 즉, 라이브러리는 완전한 프로램이 아니라 특정한 기능만을 수행하도록 제작된 프로그램이다.\n\n# 2-2. 라이브러리를 사용하는 이유\n- 모든 기능을 직접 코딩하지 못하며, 시간을 절약하기 위해서이다.동일한 기능을 간단한 코드로 방법화시키는 라이브러리 코드를 본인이 직접짜기엔 너무 많은 시간을 소요되며, 실제로 정해진 기간내에 처리하기도 어렵기 때문이다.\n- 즉, 라이브러리를 사용할수 있으면, 보다 복잡한 코드를 짜는데 **더 빠르고, 더 편리하게** 할 수 있기에, 사용이 권장된다.\n\n# 2-3. 라이브러리의 종류\n- 표준 라이브러리: 특정한 언어의 개발 환경에 기본적으로 포함된 것들로, 언어의 기본 기능을 확장시키는 역할을 담당한다.Python의 표준 라이브러리에는 문자열 처리, 파일 조작, 네트워크 통신 등 다양한 모듈들이 포함되어 있다.참고문헌 : https://docs.python.org/ko/3/library/index.html\n- 웹 개발 라이브러리 : 웹 개발의 편의성을 제공하는 역할을 한다.대표적인 예로 JavaScript의 경우, jQuery, React, Angular 등이 있다.\n- 데이터베이스 라이브러리 : 데이터베이스와 상호 작용하는 역할을 수행한다.\n- 그래픽스 및 시각화 라이브러리 : 데이터 시각화나 그래픽스 작업을 위해 사용하는 라이브러리대표적인 예로 JavaScript의 D3.js가 있다.\n- 상태관리 라이브러리: 애플리케이션의 상태를 보다 효과적으로 관리(상태 업데이트나 추적...)하기 위한 라이브러리대표적인 예로 Redux와 Recoil이 있다.\n\n## 3. 라이브러리와 프레임 워크의 차이점\n- 주도권의 차이라고 설명할 수 있다.\n- 라이브러리의 경우, 개발자가 필요에 따라 선택적으로 사용할 수 있다.\n- 프레임 워크의 경우, 애플리케이션의 개발을 위한 일종의 뼈대 역할을 하기에, 개발자 프레임 워크에 맞춰서 개발을 해야한다.\n\n# 3-1. React는 라이브러리인가 프레임 워크인가?\n- React는 '프레임 워크같은' 라이브러리라 정의할 수 있다.\n- React 개발당시, UI개발을 위한 라이브러리로 개발되었으나, React Router를 통한 라우팅 기능이나, Redux와 같은 다양한 상태관리 라이브러리와의 조합으로 점차 '프레임 워크화'되어간 것이다.\n- 즉, React는 **프레임워크처럼 동작하는 라이브러리**라고 소개하면 된다.",
        "qna": "## 4. 요약 정리 및 면접형 QnA\n\n# Q1. 라이브러리에 대해 설명해주세요\n- 라이브러리는 재사용 가능한 코드의 집합을 의미합니다.\n- 해당 코드에는 특정 기능을 수행하는 함수, 클래스, 모듈 등으로 구성되어 있습니다.\n- 개발자가 필요에 따라 선택적으로 사용할 수 있다는 특징이 있습니다.\n- 프런트엔드 개발자인 저희에게 가장 익숙한 라이브러리에는 웹개발 라이브러리인 React와 상태관리 라이브러리인 Recoil과 Redux가 있습니다.\n\n# Q2. 혹시 Redux와 Recoil의 차이에 대해 설명가능하실까요?\n- Redux와 Recoil은 둘 다 상태 관리를 위한 라이브러리이지만, 사용 범위나 상태 업데이트 방식, 성능면에서 차이를 보입니다.\n- Redux의 경우, JavaScript 기반의 라이브러리(React, Angular, Vue)에서 모두 사용가능합니다. 반면 Recoil의 경우, Meta에서 React만을 위해 개발한 라이브러리여서 오로지 React에서만 작동가능합니다.\n- Redux는 Reducer를 활용한 일방적인 데이터 흐름으로 상태를 업로드 하지만, Recoil은 React의 useState와 유사하게 Atom이라는 상태 단위를 활용하여 상태를 업로드 합니다.\n- Recoil은 Redux보다 간단한 API를 제공하고 성능 최적화면에서도 React의 컴포넌트 라이프사이클과 잘 맞기에 우수합니다.\n\n# Q3. React는 라이브러리일까요, 아니면 프레임워크일까요?\n- React의 개념적으로 라이브러리가 맞습니다. 개발 초창기에 웹개발을 용이하게 하기 위해 개발된 웹개발 라이브러리 였으나, 다양한 상태관리 라이브러리를 함께 사용하고, 라우터를 활용한 라우팅이 가능해져서 컴포넌트간 보다 편리한 매핑이 가능해져 더이상 라이브러리가 아닌 프레임워크로 인식되는 경우가 있습니다.\n- 즉, React는 **프레임워크처럼 동작하는 라이브러리**라고 정의할 수 있습니다."
      },
      {
        "id": "6",
        "title": "React",
        "topic": "React의 상태관리란 무엇인가",
        "texture": "## 1. 주제 선정 이유\n React라이브러리를 사용하다보면 상태관리가 필수이며 그에 따른 각종 기능들을 숙지하고 있어야한다. 이에 대해 알지 못하면 React를 사용하지 않는 수준이며, 협업을 하는데 있어 큰 지장이 되기에 이번 기회에 상태관리에 대한 정확한 정의를 학습하고, React의 상태관리 방법에는 어떤 것들이 있는지 살펴보도록 하자.\n\n## 2. 상태관리란\n\n# 2-1. 상태관리의 정의\n- 상태(State) : 컴퍼넌트 내부에서 관리되며 어플리케이션의 렌더에 영향을 미치는 자바스크립트 객체를 의미. 즉, **변화하는 데이터**라고 이해하면 된다. (ex, 쇼핑몰 사이트에서 구매할 물건의 수량을 늘리고 줄이는 행위를 상태가 변화한다고 한다.)\n- 상태관리 : 상태는 어는 컴퍼넌트에서나 일관되어야 한다. 이를 데이터의 무결성이라 한다. 왜냐하면, 상태가 컴퍼넌트마다 다르다면, 유저나 관리자가 받아들이는 데이터에 차이가 생겨 소통에 차질이 생기기 때문이다.\n따라서 상태를 일관되게 관리해야하며, React의 경우, **신뢰할 수 있는 단일 출처(동일한 데이터는 항상 같은 곳에서 가져온다)**라는 방법론으로 상태를 관리하고 있다.\n\n# 2-2. 상태의 종류\n- 지역상태(localState) : 특정 컴퍼넌트 안에서만 관리되는 상태를 의미한다. 이는 주로 작은 프로젝트처럼 좁은 영역에서만 관리되는 데이터들이다.\n- 컴퍼넌트 간 상태: 다수의 컴퍼넌트에서 사용되고 영향을 주는 데이터들을 의미한다. 대표적인 예시로 여러 컴퍼넌트가 동시에 사용하는 모달창 등이 있다\n2개 이상의 컴퍼넌트간에 상태를 주고 받을 경우, 상위 컴퍼넌트에서 하위 컴퍼넌트로만 상태를 전달하며, 이를 Props Driling이라 한다.\n- 전역 상태(globalState) : 프로젝트 전체에 영향을 끼치는 데이터를 의미한다. 대표적인 예로, 모든 컴퍼넌트에서 사용되는 페이지의 헤더 컴퍼넌트 등이 있다.\n- 상태관리가 필요한 이유: 걱 컴퍼넌트가 부모자식 관계로 되어있지 않은 이상 각 컴퍼넌트간의 직접적인 데이터 전달은 어렵우며, 구조가 복잡하여 Props Driling이 많아지면 Props의 출처를 찾기 어려워기 때문에 이를 관리해줘야 한다.\n\n## 3. React의 상태관리\n\n# 3-1. Context API\n- Context API : React 컴포넌트 트리 안에서 전역 상태를 공유할 수 있도록 만들어진 방법이다.명칭은 API이기는 하지만, 실질적인 관리는 API가 아니라 useState를 통해 이루어진다.\n- useState() :\n`cosnt [state, setState] = useState()`의 형태로 구성되어 있다.\n앞에서서부터 state라는 상태변수와 상태에 변화를 주는 setState라는 함수가 있다. useState()의 파라미터에는 초기 state값이 들어가며, 이후 setState를 통해 state의 값에 변화를 주는 방식으로 상태를 관리한다.\nuseState()는 상태를 새로 추가하거나 삭제하는 것이 아니라 단순 비교를 통해 상태를 업데이트 시키는 원리로 작동한다.\n즉, **동일한 데이터의 key값이면 키의 value값의 차이를 비교하여 최신의 value값으로 갱신하며 상태를 관리한다.**\n이는 중간에 있는 요소들에게 props를 넘기지 않고도 데이터를 가져다 사용할 수 있기에 props Drilling을 피할 수 있으며, 주로 전역적으로 쓰이는 데이터들을 사용할 때 자주 사용된다.\n- context API의 구조 : context, provider, comsumer 로 구성\n context : 전역상태를 저장하는 곳으로 , 내부에는 provider와 consumer로 구성되어있다.\n provider : 전역상태를 제공하는 역할을 한다. 주로 Root Component(index.js / app.js)에서 정의된다.\n consumer 제공받은 전역상태를 받아서 사용하는 역할을 한다.\n\n# 3-2. Redux\n- Redux : 공식 문서에 따르면 자바스크립트 앱을 위한 예측 가능한 상태 컨테이너라고 정의한다.\n 이를 풀어 설명하면, 전역 상태를 관리하는 도구, 즉, 어플리케이션 전체에 대한 중앙 저장소 역할을 한다고 생각하면 된다.\n- 'Store','Action', 'Reducer'로 구성되어 있다.\n Store는 전역상태를 저장하는 저장소 역할을 하며, 오직 Reducer를 통해서만 접근이 가능하다. 주로 index.js에 정의되며 Store는 오직 1개만 존재할 수 있다.\n Action은 Store에 저장된 상태의 변화를 Reducer에 명령하는 자바스크립트 객체이다. 변화를 주기 위해 dispatch라는 메서드를 사용하여 Reducer에게 전달된다.\n Reducer는 변화를 감지하여 상태를 변화시키는 역할을 하는 순수함수로서, 전역 상태를 변경하고 업데이트시킨다. 바닐라 자바스크립트의 '이벤트리스너'와 동일한 역할을 한다고 파악해도 좋다.\n 다만, Redux의 경우, 상태관리를 할 때, 이전상태를 변경시키는 것이 아닌 **새로운 상태의 객체를 생성하여 반환한다**는 점을 명시해야한다.\n *순수함수 : 다른 외부의 상태를 변경하지 않으면서도, 어떤 동일한 인자에 대해 항상 동일한 값을 리턴하는 함수이다.\n\n# 3-3. Recoil 라이브러리\n- 앞서 언급한 Redux는 단방향의 흐름에서 상태관리가 용이하지만, 이를 위한 action, reducer와 같은 초기 세팅이 상당히 번거롭고 React와 잘 맞지 않는다는 여론이 주를 이루었다.\n- React의 상태관리를 보다 React스럽게(hook을 전역으로 확장시킴) 하기 위해, 메타(전 페이스북)사에서 제작한 React 상태관리 라이브러리이다.\n- Recoil은 atom과 selector라는 객체를 사용하여 상태를 관리한다.\n- atom은 구독, 옵저버와 같은 개념을 생각할 필요없이 hook을 사용하듯이 사용하면 된다.\n hook를 사용했던 개발자라면 쉽게 사용할 수 있다.\n- selector를 이용하면 리듀서 없이 복잡한 연산도 간단하게 할 수 있다.",
        "qna": "추가해야함"
      }
    ]
  },
  {
    "title": "JavaScript",
    "items": [
      {
        "id": "5",
        "title": "JavaScript",
        "topic": "객체",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "6",
        "title": "JavaScript",
        "topic": "props",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "7",
        "title": "JavaScript",
        "topic": "class",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "8",
        "title": "JavaScript",
        "topic": "호이스팅",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      }
    ]
  },
  {
    "title": "React",
    "items": [
      {
        "id": "9",
        "title": "React",
        "topic": "객체",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "10",
        "title": "React",
        "topic": "props",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "11",
        "title": "React",
        "topic": "class",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "12",
        "title": "React",
        "topic": "호이스팅",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      }
    ]
  },
  {
    "title": "CS",
    "items": [
      {
        "id": "13",
        "title": "CS",
        "topic": "객체",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "14",
        "title": "CS",
        "topic": "props",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "15",
        "title": "CS",
        "topic": "class",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      },
      {
        "id": "16",
        "title": "CS",
        "topic": "호이스팅",
        "texture": "## 2-1). 객체의 정의 및 구조\n\n- 객체 : 프로그래밍 언어에서 데이터나 함수를 담아내는 참조 자료형으로, 프로퍼티와 메서드로 이루어져 있다.\n- 프로퍼티 : 객체의 상태 데이터를 나타내는 값으로, 키(key)와 값(value)로 이루어져 있다. 프로퍼티와 유사한 용어로, 속성(attribute)이 있다.\n- 메서드 : 프로퍼티 중, 값이 함수인 경우, 다른 함수와 구분하기 위해 해당 프로퍼티를 메서드라고 부른다.\n\n## 2-2). 참조의 정의 및 예시\n\n참조 : 값이 담긴 메모리 주소를 가져온다는 것을 의미, 결국 객체는 식별자(변수)에게 값이 아닌 메모리 주소만 알려주기에 참조 자료형 이라고 한다.\n※객체의 주소를 비교하면 다르지만, 객체의 속성(프로퍼티)에 접근하여 값을 비교하면 같다!\n\n```jsx\n// 예시 1. 객체의 주소 비교와 속성 값 비교\nlet person1 = { age: 27,\n      name : Daniel};\n\nlet person2 = { age: 27,\n      name : Daniel};\n\nperson1 === person2 // 객체 person1과 person2의 주소는 다르기에 false\n\nperson1.age === person2.age // 객체 person1과 person2의 age는 27로 같기에 true\n\n```\n\n# Ⅲ. 객체 지향 프로그래밍\n\n- 객체 지향 프로그래밍 : 데이터나 함수를 하나의 객체 단위로 묶은 독립된 객체간의 상호작용을 하는 프로그래밍 방식\n- 객체 지향 프로그램 언어 : C++, Java, JavaScript...\n\n## 🙄 도대체 왜 객체 지향 프로그래밍 언어를 사용하는 것인가?\n\n## 3-1). 객체 지향 프로그래밍 언어의 특징\n\n### 1). 상속\n\n- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 그대로 사용할 수 있게 해주는 것\n- 상속을 통해 **코드의 재사용성이 높아지며**, 클래스 간의 계층구조를 만들어 **관리하기 쉬워짐**\n\n### 2). 캡슐화\n\n- 중괄호 라는 범위 안에, 객체의 키와 값을 짝지어서 타인이 함부로 객체의 값을 수정하거나 삭제하는 것을 방지한다.\n\n### 3). 다형화\n\n- 여러 객체가 하나의 메서드를 호출해도, 실행 결과가 객체마다 다르게 나타나는 특징이 있다.\n- 하나의 메서드를 메서드 오버라이딩을 통해 다양한 결과를 만들 수 있어, 코드의 재사용률을 높인다.\n\n※ 메서드 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**하여 사용하는 것\n\n```jsx\nclass Animal {  // 부모 클래스\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {  // 처음 선언한 메서드\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {  // 자식 클래스\n  speak() {  // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} barks.`);\n  }\n}\n\nclass Cat extends Animal {\n  speak() { // 같은 명의 클래스를 재정의 -> 다형화\n    console.log(`${this.name} meows.`);\n  }\n}\n\nconst animals = [new Dog('Rufus'), new Cat('Mittens')];\n\nanimals.forEach(animal => {\n  animal.speak();\n});\n\n```",
        "qna": "질문과 답 => 약간 만들어서 임시방편으로 해야할 듯"
      }
    ]
  }
]
